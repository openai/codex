# cocode-error

Unified error utilities with status codes, retry semantics, and virtual stack traces.

## Quick Start

```rust
use cocode_error::{ErrorExt, StatusCode, Location, stack_trace_debug};
use snafu::{ResultExt, Snafu};

#[stack_trace_debug]  // Must be BEFORE #[derive(Snafu)]
#[derive(Snafu)]
pub enum Error {
    #[snafu(display("Failed to read file: {path}"))]
    ReadFile {
        path: String,
        #[snafu(source)]
        source: std::io::Error,
        #[snafu(implicit)]
        location: Location,
    },

    #[snafu(display("Rate limited"))]
    RateLimited {
        retry_after: std::time::Duration,
        #[snafu(implicit)]
        location: Location,
    },
}

impl ErrorExt for Error {
    fn status_code(&self) -> StatusCode {
        match self {
            Self::ReadFile { .. } => StatusCode::IoError,
            Self::RateLimited { .. } => StatusCode::RateLimited,
        }
    }

    fn retry_after(&self) -> Option<std::time::Duration> {
        match self {
            Self::RateLimited { retry_after, .. } => Some(*retry_after),
            _ => None,
        }
    }

    fn as_any(&self) -> &dyn std::any::Any { self }
}
```

## Location

```rust
#[non_exhaustive]
pub struct Location {
    pub file: &'static str,
    pub line: u32,
    pub column: u32,
}
```

Add to error variants with `#[snafu(implicit)]` - auto-captured at error creation site.

## Snafu Usage Patterns

Use snafu context selectors directly. Do NOT write custom constructor functions.

```rust
use crate::error::my_error::*;  // Generated by #[snafu(module)]
use snafu::ResultExt;

// .context() — variant has #[snafu(source)], wraps the original error
fs::read(path).context(IoSnafu { message: "read config" })?;
serde_json::from_str(s).context(JsonParseSnafu { file: "config.json" })?;

// .map_err() — variant has NO source (e.g., PoisonError is !Send)
lock.read().map_err(|e| InternalSnafu {
    message: format!("lock poisoned: {e}"),
}.build())?;

// .fail() — generate error from condition, no source
return NotFoundSnafu { kind: NotFoundKind::Model, name }.fail();

// ensure! — conditional fail
snafu::ensure!(valid, NotFoundSnafu { kind: NotFoundKind::Provider, name: "x" });
```

| Pattern | When to use |
|---------|-------------|
| `.context(XxxSnafu { .. })?` | Variant has `#[snafu(source)]` — wraps original error |
| `.map_err(\|e\| XxxSnafu { .. }.build())?` | Variant has no source — convert error to message string |
| `XxxSnafu { .. }.fail()` | No source error — create error from condition |

## StatusCode Categories

| Category | Range | Examples |
|----------|-------|----------|
| Success | 00_xxx | Success |
| Common | 01_xxx | Unknown, Internal, Cancelled |
| Input | 02_xxx | InvalidArguments, ParseError |
| IO | 03_xxx | IoError, FileNotFound |
| Network | 04_xxx | NetworkError, ConnectionFailed |
| Auth | 05_xxx | AuthenticationFailed, PermissionDenied |
| Config | 10_xxx | InvalidConfig |
| Provider | 11_xxx | ProviderNotFound, ModelNotFound |
| Resource | 12_xxx | RateLimited, Timeout, QuotaExceeded |
