# Agent Follow-Up Enablement

This note captures the design work required to let the primary Codex agent
reuse an existing delegate conversation instead of launching a fresh run every
time. The end goal is that the model can:

1. List delegate sessions that are still available for follow-up.
2. Inspect the latest `N` turns from a delegate before deciding whether to
   re-engage it.
3. Invoke `delegate_agent` in "follow-up" mode by passing the existing
   conversation identifier so the request is appended to that session.

The sections below outline the API changes, orchestrator plumbing, UI surfaces,
and documentation updates needed to ship this capability.

---

## 1. User & Model Experience

- **Discovery** – the primary agent calls the new `delegate_sessions` tool to
  retrieve a list of reusable delegate sessions. Each entry returns:
  - `conversation_id`
  - `agent_id`
  - `mode` (`standard` vs `detached`)
  - `cwd`
  - `last_interacted_at`
  - Optional shadow metrics (e.g., total turns, bytes) if available
- **Preview** – when absolutely necessary, the primary agent can request the
  last `k` messages from a conversation (latest first). This serves as a
  last-resort reminder of what the delegate just did before composing a
  follow-up prompt.
- **Follow-up call** – when the model is ready, it reuses the existing
  conversation by including a `conversation_id` in the `delegate_agent`
  payload. The orchestrator routes the new prompt into that conversation and
  streams the updates back just like a fresh run.

This keeps the user-facing workflow simple: the parent agent chooses from a
list, previews context, then issues a follow-up prompt that continues the
delegate transcript.

---

## 2. API & Schema Updates

We introduce a dedicated read-only tool named `delegate_sessions` alongside the
existing `delegate_agent` function. The new tool handles discovery, preview,
and dismissal so `delegate_agent` can focus solely on launching or resuming
work.

### 2.1 `delegate_sessions` tool

- **Operations**
  - `list` – returns paginated session summaries ordered by
    `last_interacted_at` (newest first).
  - `messages` – returns a page of recent messages for a specific session.
  - `dismiss` – removes a session from the reusable pool (freeing any shadow
    resources).

- **Request schema** (pseudo-JSON):

  ```json
  {
    "operation": "list" | "messages" | "dismiss",
    "conversation_id": "...",        // required for messages/dismiss
    "cursor": "...",                 // optional pagination cursor
    "limit": 3                       // optional page size (default 3)
  }
  ```

- **Response examples**
  - `list` returns `{ "sessions": [ ... ], "next_cursor": "..." }`
  - `messages` returns `{ "messages": [ ... ], "next_cursor": "..." }`
    with messages ordered newest-to-oldest; clients can follow `next_cursor`
    to page back through older history.
  - `dismiss` returns `{ "status": "ok" }`
  - Errors return `{ "status": "error", "error": { "code": "...",
    "message": "..." } }` (e.g., `unknown_conversation`, `invalid_cursor`).

  Message entries include `id`, `role`, `content`, timestamps, and any tool
  metadata needed for replay. Cursors are opaque strings generated by the
  orchestrator (e.g., encoding timestamp + index).

### 2.2 `delegate_agent` follow-up contract

- Extend `DelegateToolRequest` (`codex-rs/core/src/delegate_tool.rs:49-60`) with
  one optional field:
  - `conversation_id: Option<String>` – when present, indicates this is a
    follow-up call using an existing session.

- Update the tool schema (`DELEGATE_TOOL` in
  `codex-rs/core/src/tools/handlers/delegate.rs:33-136`) with the new rules:
  - `conversation_id` is mutually exclusive with `batch`.
  - When `conversation_id` is provided, `prompt` is required but `agent_id` is
    optional (if omitted, reuse the agent recorded on the session).
  - Reject requests where the session id is unknown, inactive, or currently
    processing another follow-up.
  - Always return a new `run_id` even for follow-ups so downstream telemetry and
    notifications can differentiate consecutive prompts within the same
    conversation.

No automatic context is streamed back; the model must call `delegate_sessions`
`messages` if it needs to inspect prior turns.

---

## 3. Orchestrator Changes

All follow-up logic lives in `AgentOrchestrator` and its adapter
(`codex-rs/multi-agent/src/orchestrator.rs`). Key tasks:

1. **Expose session summaries** – add a public method
   `list_sessions(limit, cursor) -> PaginatedSessions` that wraps the existing
   `active_sessions()` helper and returns JSON-friendly data. Results are
   ordered by `last_interacted_at` (desc) and include the next cursor.
2. **Fetch recent history** – new async helper
   `recent_messages(conversation_id, cursor, limit)` that consults
   `ShadowManager` first, then falls back to `CodexConversation::history`. The
   helper returns newest-to-oldest entries plus the next cursor to support
   pagination without loading entire transcripts.
3. **Follow-up entry point** – extend `MultiAgentDelegateAdapter::delegate` to
   branch when `conversation_id` is set:
   - Look up the session via `enter_session` (reusing the live
     `CodexConversation`).
   - Submit the follow-up prompt with `conversation.submit(Op::UserTurn { … })`.
   - Reuse the existing event stream (`SessionEventBroadcaster`) so deltas flow
     back through `DelegateEvent`.
  - Ensure `run_owner_conversations` keeps pointing to the original owner so
    nested delegates still resolve parentage correctly.
  - Mint a fresh `DelegateRunId` for each follow-up. Map it to the reused
    conversation id so telemetry, notifications, and tool responses can
    distinguish consecutive follow-ups on the same session.
4. **Lifecycle management** – when a follow-up completes, leave the session in
   the registry so additional follow-ups remain possible. Only `remove_session`
   (on explicit dismiss/cleanup) should evict it.

Detached runs require extra care: only allow follow-ups once the detached run
has reached the `Ready` state, and update the detached-run registry to reflect
that the session is now “active”.

---

## 4. UI & CLI Considerations

- **TUI session picker** – extend the `/agent` panel to show reusable sessions
  with additional actions:
  - “Preview last N messages” (calls the new preview operation).
  - “Resume conversation” (instructs the model to send a follow-up prompt).
  - “Dismiss session” (fires the new `delegate_sessions` `dismiss` operation).
- **History cells** – add new cell types (`DelegateFollowUpStarted`,
  `DelegateFollowUpCompleted`) so the primary transcript records when we re-enter
  a delegate. This keeps the main chat audit-friendly.
- **Status panel** – include a count of reusable sessions and their total disk
  footprint (via `ShadowMetrics`).
- **Notifications** – follow-ups should reuse the existing delegate
  notifications; no change required beyond possibly annotating messages with
  “(follow-up)”.

Headless front-ends (e.g., `codex exec`) can expose the same operations through
their status commands or JSON APIs.

---

## 5. Documentation & Prompt Updates

- Revise the model-facing instructions (`ai-temp/example-codex-home/AGENTS.md`
  and `docs/multi-agent.md`) to teach the agent flow:
  1. Call `delegate_sessions` with `operation: "list"` to enumerate reusable
     runs when considering a follow-up.
  2. Use `delegate_sessions` with `operation: "messages"` for context (only
     when absolutely necessary).
  3. Provide `conversation_id` when invoking `delegate_agent` to continue that
     session, or `operation: "dismiss"` to clean up when you are done.
- Update `ai-temp/CHANGELOG.md` with the new capabilities once implemented.
- Add sample transcripts in `ai-temp/example-conversation.md` showing a follow-up
  delegation.

---

## 6. Testing Strategy

1. **Unit tests**
   - Tool handler validation (mutually exclusive fields, missing session id,
     etc.).
   - Agent-busy path: follow-up while a run is active returns the expected
     `agent_busy` error payload.
   - `delegate_sessions` operations: list pagination, message cursors, and
     dismiss semantics (including error codes).
   - Orchestrator follow-up path: submit prompt, verify events stream from the
     existing conversation and that no new conversation is created.
   - Recent-message retrieval using both shadow cache and rollout fallback.
2. **TUI snapshot tests** – update `/agent` picker snapshots to include preview
   actions and follow-up entries; ensure history cells render correctly.
3. **Integration test** – create a fake agent home with a sample run, trigger a
   follow-up via the CLI, and assert that the same conversation ID is reused and
   history grows as expected.

---

## 7. Policy Decisions

- **Session eviction:** reusable sessions have no expiry by design; they stay
  available until the user or orchestrator explicitly removes them via the
  `delegate_sessions` `dismiss` operation (or matching UI action).
- **Concurrent follow-ups:** the orchestrator must reject follow-up attempts if
  the target agent is still running. Introduce `DelegateToolError::AgentBusy`
  and serialize it as `{ "status": "error", "error": { "code": "agent_busy",
  "message": "delegate still running" } }` so the parent agent can wait and
  retry deterministically.
- **Automatic context snippets:** the follow-up API never returns extra context
  automatically. The model should request previews explicitly via
  `delegate_sessions` `messages` only when it truly needs them.

---

By following the plan above, we give the primary agent a structured way to
inspect, select, and continue delegate conversations, unlocking true follow-up
capabilities without breaking existing one-shot delegation workflows.

---

## 8. Implementation Roadmap

### Phase 1 – Core Wiring
1. **Schema groundwork** ✅
   - Update `DelegateToolRequest`/`DelegateToolError` to add `conversation_id`
     and new error variants.
   - Introduce shared structs/enums for session listings and message previews.
2. **Delegate handler** (`core/src/tools/handlers/delegate.rs`) ✅
   - Accept `conversation_id`; validate mutually exclusive arguments.
   - Ensure follow-up calls reuse the existing agent id when omitted.
   - Map new error variants to `FunctionCallError` responses.
3. **Tool registry** ✅
   - Register the new `delegate_sessions` tool spec and handler stub.
4. **Adapter interface** ✅
   - Extend `DelegateToolAdapter` trait with list/messages/dismiss methods.

### Phase 2 – Orchestrator Services
5. **Session pagination helpers** ✅
   - Add cursor encoding/decoding, `list_sessions(limit, cursor)` public API.
6. **Message retrieval** ✅
   - Implement `recent_messages(conversation_id, cursor, limit)` with shadow
     cache fallback.
7. **Follow-up orchestration** ✅
   - Support optional `conversation_id` in `delegate()`; mint fresh run ids and
     guard against concurrent follow-ups (AgentBusy path).
8. **Dismissal** ✅
   - Provide `dismiss_session(conversation_id)` that tears down session state
     and shadow artifacts.

### Phase 3 – `delegate_sessions` Tool Handler
9. **Handler implementation** ✅
   - Parse `operation` (`list`/`messages`/`dismiss`), call new adapter methods,
     return structured JSON with pagination cursors.
10. **Error handling** ✅
    - Map orchestrator errors (`SessionNotFound`, `InvalidCursor`, etc.) to
      consistent tool responses.

### Phase 4 – UI & CLI Integration
11. **TUI updates** ✅
    - `/agent` picker: show follow-up sessions, preview/dismiss actions, updated
      history cells for follow-up start/complete.
12. **Status panel**
    - Surface reusable session counts and shadow metrics.
13. **Headless surfaces**
    - Ensure CLI status/info commands expose the same data (if applicable).

### Phase 5 – Documentation & Tests
14. **Docs & prompts** ✅
    - Update `docs/multi-agent.md`, sample instructions, and the changelog.
15. **Unit tests** ✅
    - Add coverage for the new delegate preview history cell (with snapshot) and
      keep TUI behaviour under test.
16. **TUI snapshots/integration**
    - Add snapshots for new UI entries and integration test ensuring identical
      conversation id reuse.

### Phase 6 – Final Polish
17. **Lint & format** (`just fmt`, `just fix -p <project>` as required).
18. **Sanity checks**
    - Manual smoke test with `CODEX_HOME=...` sample agents following the new
      flow.
