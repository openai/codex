# React Server Components architecture

## Summary

Research Summary for "React Server Components architecture" (comprehensive strategy):

Found 5 relevant findings.

Key findings:
- Finding from Server Components - React: Server Components ‚Äì React React v 19.2 Search ‚åò Ctrl K Learn Reference Community Blog react@19.2 Overview Hooks useActionState useCallback useContext useDebugValue useDeferredValue useEffect useEffectEvent useId useImperativeHandle useInsertionEffect useLayoutEffect useMemo useOptimistic useReducer useRef useState useSyncExternalStore useTransition Components <Fragment> (<>) <Profiler> <StrictMode> <Suspense> <Activity> <ViewTransition> - This feature is available in the latest Canary version of React APIs act addTransitionType - This feature is available in the latest Canary version of React cache cacheSignal captureOwnerStack createContext lazy memo startTransition use experimental_taintObjectReference - This feature is available in the latest Experimental version of React experimental_taintUniqueValue - This feature is available in the latest Experimental version of React react-dom@19.2 Hooks useFormStatus Components Common (e.g. <div>) <form> <input> <option> <progress> <select> <textarea> <link> <meta> <script> <style> <title> APIs createPortal flushSync preconnect prefetchDNS preinit preinitModule preload preloadModule Client APIs createRoot hydrateRoot Server APIs renderToPipeableStream renderToReadableStream renderToStaticMarkup renderToString resume resumeToPipeableStream Static APIs prerender prerenderToNodeStream resumeAndPrerender resumeAndPrerenderToNodeStream React Compiler Configuration compilationMode gating logger panicThreshold target Directives "use memo" "use no memo" Compiling Libraries React DevTools React Performance tracks eslint-plugin-react-hooks Lints exhaustive-deps rules-of-hooks component-hook-factories config error-boundaries gating globals immutability incompatible-library preserve-manual-memoization purity refs set-state-in-effect set-state-in-render static-components unsupported-syntax use-memo Rules of React Overview Components and Hooks must be pure React calls Components and Hooks Rules of Hooks React Server Components Server Components Server Functions Directives 'use client' 'use server' Legacy APIs Legacy React APIs Children cloneElement Component createElement createRef forwardRef isValidElement PureComponent Is this page useful? API Reference Server Components Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server. This separate environment is the ‚Äúserver‚Äù in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server. Server Components without a Server Server Components with a Server Adding interactivity to Server Components Async components with Server Components Note How do I build support for Server Components? While React Server Components in React 19 are stable and will not break between minor versions, the underlying APIs used to implement a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x. To support React Server Components as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement React Server Components in the future. Server Components without a Server Server components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system. Without Server Components, it‚Äôs common to fetch static data on the client with an Effect: // bundle.js import marked from 'marked' ; // 35.9K (11.2K gzipped) import sanitizeHtml from 'sanitize-html' ; // 206K (63.3K gzipped) function Page ( { page } ) { const [ content , setContent ] = useState ( '' ) ; // NOTE: loads *after* first page render. useEffect ( ( ) => { fetch ( `/api/content/ ${ page } ` ) . then ( ( data ) => { setContent ( data . content ) ; } ) ; } , [ page ] ) ; return < div > { sanitizeHtml ( marked ( content ) ) } </ div > ; } // api.js app . get ( `/api/content/:page` , async ( req , res ) => { const page = req . params . page ; const content = await file . readFile ( ` ${ page } .md` ) ; res . send ( { content } ) ; } ) ; This pattern means users need to download and parse an additional 75K (gzipped) of libraries, and wait for a second request to fetch the data after the page loads, just to render static content that will not change for the lifetime of the page. With Server Components, you can render these components once at build time: import marked from 'marked' ; // Not included in bundle import sanitizeHtml from 'sanitize-html' ; // Not included in bundle async function Page ( { page } ) { // NOTE: loads *during* render, when the app is built. const content = await file . readFile ( ` ${ page } .md` ) ; return < div > { sanitizeHtml ( marked ( content ) ) } </ div > ; } The rendered output can then be server-side rendered (SSR) to HTML and uploaded to a CDN. When the app loads, the client will not see the original Page component, or the expensive libraries for rendering the markdown. The client will only see the rendered output: < div > < !-- html for markdown --> </ div > This means the content is visible during first page load, and the bundle does not include the expensive libraries needed to render the static content. Note You may notice that the Server Component above is an async function: async function Page ( { page } ) { //... } Async Components are a new feature of Server Components that allow you to await in render. See Async components with Server Components below. Server Components with a Server Server Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components. Without Server Components, it‚Äôs common to fetch dynamic data on the client in an Effect: // bundle.js function Note ( { id } ) { const [ note , setNote ] = useState ( '' ) ; // NOTE: loads *after* first render. useEffect ( ( ) => { fetch ( `/api/notes/ ${ id } ` ) . then ( data => { setNote ( data . note ) ; } ) ; } , [ id ] ) ; return ( < div > < Author id = { note . authorId } /> < p > { note } </ p > </ div > ) ; } function Author ( { id } ) { const [ author , setAuthor ] = useState ( '' ) ; // NOTE: loads *after* Note renders. // Causing an expensive client-server waterfall. useEffect ( ( ) => { fetch ( `/api/authors/ ${ id } ` ) . then ( data => { setAuthor ( data . author ) ; } ) ; } , [ id ] ) ; return < span > By: { author . name } </ span > ; } // api import db from './database' ; app . get ( `/api/notes/:id` , async ( req , res ) => { const note = await db . notes . get ( id ) ; res . send ( { note } ) ; } ) ; app . get ( `/api/authors/:id` , async ( req , res ) => { const author = await db . authors . get ( id ) ; res . send ( { author } ) ; } ) ; With Server Components, you can read the data and render it in the component: import db from './database' ; async function Note ( { id } ) { // NOTE: loads *during* render. const note = await db . notes . get ( id ) ; return ( < div > < Author id = { note . authorId } /> < p > { note } </ p > </ div > ) ; } async function Author ( { id } ) { // NOTE: loads *after* Note, // but is fast if data is co-located. const author = await db . authors . get ( id ) ; return < span > By: { author . name } </ span > ; } The bundler then combines the data, rendered Server Components and dynamic Client Components into a bundle. Optionally, that bundle can then be server-side rendered (SSR) to create the initial HTML for the page. When the page loads, the browser does not see the original Note and Author components; only the rendered output is sent to the client: < div > < span > By: The React Team </ span > < p > React 19 is... </ p > </ div > Server Components can be made dynamic by re-fetching them from a server, where they can access the data and render again. This new application architecture combines the simple ‚Äúrequest/response‚Äù mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds. Adding interactivity to Server Components Server Components are not sent to the browser, so they cannot use interactive APIs like useState . To add interactivity to Server Components, you can compose them with Client Component using the "use client" directive. Note There is no directive for Server Components. A common misunderstanding is that Server Components are denoted by "use server" , but there is no directive for Server Components. The "use server" directive is used for Server Functions. For more info, see the docs for Directives . In the following example, the Notes Server Component imports an Expandable Client Component that uses state to toggle its expanded state: // Server Component import Expandable from './Expandable' ; async function Notes ( ) { const notes = await db . notes . getAll ( ) ; return ( < div > { notes . map ( note => ( < Expandable key = { note . id } > < p note = { note } /> </ Expandable > ) ) } </ div > ) } // Client Component "use client" export default function Expandable ( { children } ) { const [ expanded , setExpanded ] = useState ( false ) ; return ( < div > < button onClick = { ( ) => setExpanded ( ! expanded ) } > Toggle </ button > { expanded && children } </ div > ) } This works by first rendering Notes as a Server Component, and then instructing the bundler to create a bundle for the Client Component Expandable . In the browser, the Client Components will see output of the Server Components passed as props: < head > < !-- the bundle for Client Components --> < script src = "bundle.js" /> </ head > < body > < div > < Expandable key = { 1 } > < p > this is the first note </ p > </ Expandable > < Expandable key = { 2 } > < p > this is the second note </ p > </ Expandable > < !--...--> </ div > </ body > Async components with Server Components Server Components introduce a new way to write Components using async/await. When you await in an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense. You can even create a promise on the server, and await it on the client: // Server Component import db from './database' ; async function Page ( { id } ) { // Will suspend the Server Component. const note = await db . notes . get ( id ) ; // NOTE: not awaited, will start here and await on the client. const commentsPromise = db . comments . get ( note . id ) ; return ( < div > { note } < Suspense fallback = { < p > Loading Comments... </ p > } > < Comments commentsPromise = { commentsPromise } /> </ Suspense > </ div > ) ; } // Client Component "use client" ; import { use } from 'react' ; function Comments ( { commentsPromise } ) { // NOTE: this will resume the promise from the server. // It will suspend until the data is available. const comments = use ( commentsPromise ) ; return comments . map ( comment => < p > { comment } </ p > ) ; } The note content is important data for the page to render, so we await it on the server. The comments are below the fold and lower-priority, so we start the promise on the server, and wait for it on the client with the use API. This will Suspend on the client, without blocking the note content from rendering. Since async components are not supported on the client, we await the promise with use . Next Server Functions Copyright ¬© Meta Platforms, Inc no uwu plz uwu? Logo by @sawaratsuki1004 Learn React Quick Start Installation Describing the UI Adding Interactivity Managing State Escape Hatches API Reference React APIs React DOM APIs Community Code of Conduct Meet the Team Docs Contributors Acknowledgements More Blog React Native Privacy Terms On this page Overview Server Components without a Server Server Components with a Server Adding interactivity to Server Components Async components with Server Components (confidence: 0.80)
- Finding from Server Components and Server Actions in React 19: A Revolution in React ...: Server Components and Server Actions in React 19: A Revolution in React Architecture | by Erick Zanetti | Medium Sitemap Open in app Sign up Sign in Medium Logo Write Search Sign up Sign in Server Components and Server Actions in React 19: A Revolution in React Architecture Erick Zanetti 5 min read ¬∑ Dec 21, 2024 -- 1 Listen Share Discover Server Components and Server Actions in React 19: boosting performance, security, and simplicity for modern, scalable apps. Server Components and Server Actions React 19 introduced impressive new features that promise to transform how we build applications, especially when it comes to server-side rendering and the interaction between client and server. Among these innovations are Server Components and Server Actions, which introduce more efficient paradigms for rendering and state management. In this article, we will dive deeply into these concepts, including examples that show how to apply them in real-world projects. What Are Server Components? Server Components are an extension of the idea of server-side rendering (SSR). Instead of rendering only the final HTML on the server, Server Components allow you to create components that exist only on the server. This means they can directly access databases, APIs, and other resources without sensitive code or data needing to be sent to the client. Benefits of Server Components Better Performance: Since Server Components avoid hydration, the client does not need to re-execute JavaScript to rebuild the application state. Enhanced Security: Sensitive code is not exposed to the client, reducing the risk of information leaks. Smaller Bundle Size: The client only receives the necessary HTML and scripts, reducing the bundle size. How React Distinguishes Client and Server Components React distinguishes between Client Components and Server Components based on specific rules and configurations: Using Directives Components intended for the client must include the directive 'use client' at the top of the file. This explicitly tells React that the component should run on the client. 'use client'; import { useState } from 'react'; export default function Counter() { const [count, setCount] = useState(0); return ( <button onClick={() => setCount(count + 1)}> Count: {count} </button> ); } If the 'use client' directive is not present, React assumes the component is a Server Component and renders it on the server by default. Context of Usage Server Components can import other Server Components or Client Components, but Client Components cannot import Server Components. // Server Component import ClientComponent from './ClientComponent'; export default function ServerComponent() { return ( <div> <h1>This is a Server Component</h1> <ClientComponent /> </div> ); } // Client Component 'use client'; export default function ClientComponent() { return <p>This is a Client Component</p>; } APIs and Hooks Used If a component uses browser-dependent hooks or APIs like useState , useEffect , or DOM manipulation, it must be explicitly marked as a Client Component using 'use client' . Components that access sensitive data or interact with the server environment are automatically treated as Server Components unless explicitly overridden. This clear distinction ensures optimal performance and security while simplifying the development workflow. Server Actions: Handling Data with Simplicity Server Actions allow you to manage state and interactions directly on the server without needing to create REST or GraphQL endpoints for every action. They integrate natively with Server Components and offer a declarative API for handling events and updates. Practical Example: A Contact Form Here is a more complex example that combines Server Components and Server Actions to implement a contact form with server-side validation and real-time feedback. // app/contact/page.server.jsx import { handleContactSubmission } from './actions'; export default function ContactPage() { return ( <ContactForm onSubmit={handleContactSubmission} /> ); } // app/contact/ContactForm.client.jsx 'use client'; import { useState } from 'react'; export default function ContactForm({ onSubmit }) { const [formData, setFormData] = useState({ name: '', email: '', message: '' }); const [isSubmitting, setIsSubmitting] = useState(false); const [error, setError] = useState(null); const [success, setSuccess] = useState(false); const handleChange = (e) => { const { name, value } = e.target; setFormData({ ...formData, [name]: value }); }; const handleSubmit = async (e) => { e.preventDefault(); setIsSubmitting(true); setError(null); try { const response = await onSubmit(formData); if (response.success) { setSuccess(true); } else { setError(response.error); } } catch (err) { setError('Unexpected error. Please try again later.'); } finally { setIsSubmitting(false); } }; if (success) { return <p>Thank you for reaching out! We will respond shortly.</p>; } return ( <form onSubmit={handleSubmit}> <label> Name: <input type="text" name="name" value={formData.name} onChange={handleChange} required /> </label> <label> Email: <input type="email" name="email" value={formData.email} onChange={handleChange} required /> </label> <label> Message: <textarea name="message" value={formData.message} onChange={handleChange} required /> </label> <button type="submit" disabled={isSubmitting}> {isSubmitting ? 'Sending...' : 'Send'} </button> {error && <p className="error">{error}</p>} </form> ); } // app/contact/actions.server.js export async function handleContactSubmission({ name, email, message }) { if (!name || !email || !message) { return { success: false, error: 'All fields are required.' }; } // Simulating a database call try { await saveToDatabase({ name, email, message }); return { success: true }; } catch (error) { return { success: false, error: 'Failed to save to the database.' }; } } async function saveToDatabase(data) { // Replace with your actual implementation console.log('Saving to database:', data); } In this example, the ContactForm component runs on the client, while the form processing logic is abstracted into a Server Action called handleContactSubmission . This separation ensures security and performance by preventing sensitive logic from being exposed on the client. Precautions and Limitations Complexity Management: Mixing Server Components and Client Components can add cognitive load to the project. Carefully plan the boundaries between client and server logic. Latency Concerns: Server Actions rely on network communication. Poorly optimized server infrastructure can lead to high latency. Server Load: Offloading more logic to the server can increase its load. Monitor resource usage to avoid bottlenecks. Browser Support: Ensure your application gracefully degrades for older browsers or environments that do not fully support modern JavaScript features. Debugging Challenges: Debugging issues that span client and server can be more complex, requiring robust logging and monitoring solutions. Best Practices for Working with Server Components and Server Actions Minimize Client-Side JavaScript: Use Server Components whenever possible to reduce the amount of JavaScript executed on the browser. Smart Abstractions: Organize your Server Actions into reusable modules. Avoid Overfetching: Only load the data necessary for each Server Component. Test Extensively: Simulate failure scenarios to ensure the resilience of your Server Actions. Conclusion Server Components and Server Actions in React 19 represent a significant step towards more efficient and secure applications. By combining the simplicity of React with the power of server-side rendering and state management, these tools become indispensable for developers aiming to create modern and scalable applications. Try out these features and see how they can transform your development workflow. Follow me on LinkedIn: https://www.linkedin.com/in/erickzanetti React React 19 Server Components Server Action -- -- 1 Written by Erick Zanetti 1.5K followers ¬∑ 5 following Full Stack developer with Node and React. Learning Go. Responses ( 1 ) See all responses Help Status About Careers Press Blog Privacy Rules Terms Text to speech (confidence: 0.80)
- Finding from React Server Components: React Server Components | React Router latest Branches latest ( 7.9.4 ) dev Versions 7.9.4 6.30.1 v4/5.x v3.x API Reference Search Light Dark System React Server Components Changelog Getting Started Picking a Mode Framework Mode Installation Routing Route Module Rendering Strategies Data Loading Actions Navigating Pending UI Testing Deploying Data Mode Installation Routing Route Object Data Loading Actions Navigating Pending UI Custom Framework Testing Declarative Mode Installation Routing Navigating URL Values Upgrading Future Flags Upgrading from v6 Upgrading from Remix Framework Adoption from Component Routes Framework Adoption from RouterProvider API Components Await Form Link Links Meta NavLink Navigate Outlet PrefetchPageLinks Route Routes Scripts ScrollRestoration Hooks useActionData useAsyncError useAsyncValue useBeforeUnload useBlocker useFetcher useFetchers useFormAction useHref useInRouterContext useLinkClickHandler useLoaderData useLocation useMatch useMatches useNavigate useNavigation useNavigationType useOutlet useOutletContext useParams usePrompt üß™ useResolvedPath useRevalidator useRouteError useRouteLoaderData useRoutes useSearchParams useSubmit useViewTransitionState Framework Conventions root.tsx routes.ts react-router.config.ts entry.client.tsx entry.server.tsx .client modules .server modules Framework Routers HydratedRouter ServerRouter Data Routers RouterProvider StaticRouterProvider createBrowserRouter createHashRouter createMemoryRouter createStaticHandler createStaticRouter Declarative Routers BrowserRouter HashRouter HistoryRouter üß™ MemoryRouter Router StaticRouter RSC (Unstable) RSCHydratedRouter üß™ RSCStaticRouter üß™ createCallServer üß™ getRSCStream üß™ matchRSCServerRequest üß™ routeRSCServerRequest üß™ Utils IsCookieFunction IsSessionFunction RouterContextProvider createContext createCookie createCookieSessionStorage createMemorySessionStorage createPath createRoutesFromElements createRoutesStub createSearchParams data generatePath href isCookie isRouteErrorResponse isSession matchPath matchRoutes parsePath redirect redirectDocument renderMatches replace resolvePath Other API @react-router/{adapter} @react-router/dev (CLI) @react-router/serve Tutorials Quick Start Address Book How-Tos Accessibility Client Data Error Boundaries Error Reporting Using Fetchers File Route Conventions File Uploads Form Validation HTTP Headers Middleware Navigation Blocking Pre-Rendering Presets React Server Components üß™ Resource Routes Route Module Type Safety Security Server Bundles Single Page App (SPA) Status Codes Streaming with Suspense Using handle View Transitions Explanations Backend For Frontend Automatic Code Splitting Network Concurrency Management Form vs. fetcher Hot Module Replacement Index Query Param Lazy Route Discovery Progressive Enhancement Race Conditions Sessions and Cookies State Management Type Safety Community API Development Strategy Contributing Changelog Getting Started Picking a Mode Framework Mode Installation Routing Route Module Rendering Strategies Data Loading Actions Navigating Pending UI Testing Deploying Data Mode Installation Routing Route Object Data Loading Actions Navigating Pending UI Custom Framework Testing Declarative Mode Installation Routing Navigating URL Values Upgrading Future Flags Upgrading from v6 Upgrading from Remix Framework Adoption from Component Routes Framework Adoption from RouterProvider API Components Await Form Link Links Meta NavLink Navigate Outlet PrefetchPageLinks Route Routes Scripts ScrollRestoration Hooks useActionData useAsyncError useAsyncValue useBeforeUnload useBlocker useFetcher useFetchers useFormAction useHref useInRouterContext useLinkClickHandler useLoaderData useLocation useMatch useMatches useNavigate useNavigation useNavigationType useOutlet useOutletContext useParams usePrompt üß™ useResolvedPath useRevalidator useRouteError useRouteLoaderData useRoutes useSearchParams useSubmit useViewTransitionState Framework Conventions root.tsx routes.ts react-router.config.ts entry.client.tsx entry.server.tsx .client modules .server modules Framework Routers HydratedRouter ServerRouter Data Routers RouterProvider StaticRouterProvider createBrowserRouter createHashRouter createMemoryRouter createStaticHandler createStaticRouter Declarative Routers BrowserRouter HashRouter HistoryRouter üß™ MemoryRouter Router StaticRouter RSC (Unstable) RSCHydratedRouter üß™ RSCStaticRouter üß™ createCallServer üß™ getRSCStream üß™ matchRSCServerRequest üß™ routeRSCServerRequest üß™ Utils IsCookieFunction IsSessionFunction RouterContextProvider createContext createCookie createCookieSessionStorage createMemorySessionStorage createPath createRoutesFromElements createRoutesStub createSearchParams data generatePath href isCookie isRouteErrorResponse isSession matchPath matchRoutes parsePath redirect redirectDocument renderMatches replace resolvePath Other API @react-router/{adapter} @react-router/dev (CLI) @react-router/serve Tutorials Quick Start Address Book How-Tos Accessibility Client Data Error Boundaries Error Reporting Using Fetchers File Route Conventions File Uploads Form Validation HTTP Headers Middleware Navigation Blocking Pre-Rendering Presets React Server Components üß™ Resource Routes Route Module Type Safety Security Server Bundles Single Page App (SPA) Status Codes Streaming with Suspense Using handle View Transitions Explanations Backend For Frontend Automatic Code Splitting Network Concurrency Management Form vs. fetcher Hot Module Replacement Index Query Param Lazy Route Discovery Progressive Enhancement Race Conditions Sessions and Cookies State Management Type Safety Community API Development Strategy Contributing Copy Page Copy Page Copy Page as Markdown Edit Page Edit this page on Github On this page Quick Start RSC Framework Mode Template RSC Data Mode Templates RSC Framework Mode New React Router RSC Vite Plugin Build Output React Elements From Loaders/Actions Server Component Routes .server / .client Modules MDX Route Support Unsupported Config Options RSC Data Mode Configuring Routes Server Component Routes Server Functions Client Properties Bundler Configuration Entry points Parcel Vite On this page Quick Start RSC Framework Mode Template RSC Data Mode Templates RSC Framework Mode New React Router RSC Vite Plugin Build Output React Elements From Loaders/Actions Server Component Routes .server / .client Modules MDX Route Support Unsupported Config Options RSC Data Mode Configuring Routes Server Component Routes Server Functions Client Properties Bundler Configuration Entry points Parcel Vite React Server Components Framework Data Declarative React Server Components support is experimental and subject to breaking changes. React Server Components (RSC) refers generally to an architecture and set of APIs provided by React since version 19. From the docs: Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server. - React "Server Components" docs React Router provides a set of APIs for integrating with RSC-compatible bundlers, allowing you to leverage Server Components and Server Functions in your React Router applications. If you're unfamiliar with these React features, we recommend reading the official Server Components documentation before using React Router's RSC APIs. RSC support is available in both Framework and Data Modes. For more information on the conceptual difference between these, see "Picking a Mode" . However, note that the APIs and features differ between RSC and non-RSC modes in ways that this guide will cover in more detail. Quick Start The quickest way to get started is with one of our templates. These templates come with React Router RSC APIs already configured, offering you out of the box features such as: Server Component Routes Server Side Rendering (SSR) Client Components (via "use client" directive) Server Functions (via "use server" directive) RSC Framework Mode Template The RSC Framework Mode template uses the unstable React Router RSC Vite plugin along with the experimental @vitejs/plugin-rsc plugin . npx create-react-router@latest --template remix-run/react-router-templates/unstable_rsc-framework-mode RSC Data Mode Templates When using RSC Data Mode, you can choose between the Vite and Parcel templates. The Vite RSC Data Mode template uses the experimental Vite @vitejs/plugin-rsc plugin. npx create-react-router@latest --template remix-run/react-router-templates/unstable_rsc-data-mode-vite The Parcel RSC Data Mode template uses the official React react-server-dom-parcel plugin. npx create-react-router@latest --template remix-run/react-router-templates/unstable_rsc-data-mode-parcel RSC Framework Mode Most APIs and features in RSC Framework Mode are the same as non-RSC Framework Mode, so this guide will focus on the differences. New React Router RSC Vite Plugin RSC Framework Mode uses a different Vite plugin than non-RSC Framework Mode, currently exported as unstable_reactRouterRSC . This new Vite plugin also has a peer dependency on the experimental @vitejs/plugin-rsc plugin. Note that the @vitejs/plugin-rsc plugin should be placed after the React Router RSC plugin in your Vite config. import { defineConfig } from " vite "; import { unstable_reactRouterRSC as reactRouterRSC } from " @react-router/dev/vite "; import rsc from " @vitejs/plugin-rsc "; export default defineConfig ({ plugins: [ reactRouterRSC (), rsc ()], }); Build Output The RSC Framework Mode server build file ( build/server/index.js ) now exports a default request handler function ( (request: Request) => Promise<Response> ) for document/data requests. If needed, you can convert this into a standard Node.js request listener for use with Node's built-in http.createServer function (or anything that supports it, e.g. Express ) by using the createRequestListener function from @remix-run/node-fetch-server . For example, in Express: import express from " express "; import requestHandler from " ./build/server/index.js "; import { createRequestListener } from " @remix-run/node-fetch-server "; const app = express (); app . use ( " /assets ", express . static (" build/client/assets ", { immutable: true , maxAge: " 1y ", }), ); app . use ( express . static (" build/client ")); app . use ( createRequestListener ( requestHandler )); app . listen ( 3000 ); React Elements From Loaders/Actions In RSC Framework Mode, loaders and actions can now return React elements along with other data. These elements will only ever be rendered on the server. import type { Route } from " ./+types/route "; export async function loader () { return { message: " Message from the server! ", element: < p >Element from the server!</ p >, }; } export default function Route ({ loaderData , } : Route . ComponentProps ) { return ( <> < h1 > { loaderData . message } </ h1 > { loaderData . element } </> ); } If you need to use client-only features (e.g. Hooks , event handlers) within React elements returned from loaders/actions, you'll need to extract components using these features into a client module : " use client "; export function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < button onClick = { () => setCount ( count + 1 ) } > Count: { count } </ button > ); } import type { Route } from " ./+types/route "; import { Counter } from " ./counter "; export async function loader () { return { message: " Message from the server! ", element : ( <> < p >Element from the server!</ p > < Counter /> </> ), }; } export default function Route ({ loaderData , } : Route . ComponentProps ) { return ( <> < h1 > { loaderData . message } </ h1 > { loaderData . element } </> ); } Server Component Routes If a route exports a ServerComponent instead of the typical default component export, this component along with other route components ( ErrorBoundary , HydrateFallback , Layout ) will be server components rather than the usual client components. import type { Route } from " ./+types/route "; import { Outlet } from " react-router "; import { getMessage } from " ./message "; export async function loader () { return { message: await getMessage (), }; } export function ServerComponent ({ loaderData , } : Route . ComponentProps ) { return ( <> < h1 >Server Component Route</ h1 > < p >Message from the server: { loaderData . message } </ p > < Outlet /> </> ); } If you need to use client-only features (e.g. Hooks , event handlers) within a server-first route, you'll need to extract components using these features into a client module : " use client "; export function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < button onClick = { () => setCount ( count + 1 ) } > Count: { count } </ button > ); } import { Counter } from " ./counter "; export function ServerComponent () { return ( <> < h1 >Counter</ h1 > < Counter /> </> ); } .server / .client Modules To avoid confusion with RSC's "use server" and "use client" directives, support for .server modules and .client modules is no longer built-in when using RSC Framework Mode. As an alternative solution that doesn't rely on file naming conventions, we recommend using the "server-only" and "client-only" imports provided by @vitejs/plugin-rsc . For example, to ensure a module is never accidentally included in the client build, simply import from "server-only" as a side effect within your server-only module. import " server-only "; // Rest of the module... Note that while there are official npm packages server-only and client-only created by the React team, they don't need to be installed. @vitejs/plugin-rsc internally handles these imports and provides build-time validation instead of runtime errors. If you'd like to quickly migrate existing code that relies on the .server and .client file naming conventions, we recommend using the vite-env-only plugin directly. For example, to ensure .server modules aren't accidentally included in the client build: import { defineConfig } from " vite "; import { denyImports } from " vite-env-only "; import { unstable_reactRouterRSC as reactRouterRSC } from " @react-router/dev/vite "; import rsc from " @vitejs/plugin-rsc "; export default defineConfig ({ plugins: [ denyImports ({ client: { files: [" **/.server/* ", " **/*.server.* "] }, }), reactRouterRSC (), rsc (), ], }); MDX Route Support MDX routes are supported in RSC Framework Mode when using @mdx-js/rollup v3.1.1+. Note that any components exported from an MDX route must also be valid in RSC environments, meaning that they cannot use client-only features like Hooks . Any components that need to use these features should be extracted into a client module . Unsupported Config Options For the initial unstable release, the following options from react-router.config.ts are not yet supported in RSC Framework Mode: buildEnd prerender presets routeDiscovery serverBundles ssr: false (SPA Mode) future.unstable_splitRouteModules future.unstable_subResourceIntegrity Custom build entry files are also not yet supported. RSC Data Mode The RSC Framework Mode APIs described above are built on top of lower-level RSC Data Mode APIs. RSC Data Mode is missing some of the features of RSC Framework Mode (e.g. routes.ts config and file system routing, HMR and Hot Data Revalidation), but is more flexible and allows you to integrate with your own bundler and server abstractions. Configuring Routes Routes are configured as an argument to matchRSCServerRequest . At a minimum, you need a path and component: function Root () { return < h1 >Hello world</ h1 >; } matchRSCServerRequest ({ // ...other options routes: [{ path: " / ", Component: Root }], }); While you can define components inline, we recommend using the lazy() option and defining Route Modules for both startup performance and code organization The Route Module API up until now has been a Framework Mode only feature. However, the lazy field of the RSC route config expects the same exports as the Route Module exports, unifying the APIs even further. import type { unstable_RSCRouteConfig as RSCRouteConfig } from " react-router "; export function routes () { return [ { id: " root ", path: "", lazy : () => import (" ./root/route "), children: [ { id: " home ", index: true , lazy : () => import (" ./home/route "), }, { id: " about ", path: " about ", lazy : () => import (" ./about/route "), }, ], }, ] satisfies RSCRouteConfig ; } Server Component Routes By default each route's default export renders a Server Component export default function Home () { return ( < main > < article > < h1 >Welcome to React Router RSC</ h1 > < p > You won't find me running any JavaScript in the browser! </ p > </ article > </ main > ); } A nice feature of Server Components is that you can fetch data directly from your component by making it asynchronous. export default async function Home () { let user = await getUserData (); return ( < main > < article > < h1 >Welcome to React Router RSC</ h1 > < p > You won't find me running any JavaScript in the browser! </ p > < p > Hello, { user ? user . name : " anonymous person " } ! </ p > </ article > </ main > ); } Server Components can also be returned from your loaders and actions. In general, if you are using RSC to build your application, loaders are primarily useful for things like setting status codes or returning a redirect . Using Server Components in loaders can be helpful for incremental adoption of RSC. Server Functions Server Functions are a React feature that allow you to call async functions executed on the server. They're defined with the "use server" directive. " use server "; export async function updateFavorite ( formData : FormData ) { let movieId = formData . get (" id "); let intent = formData . get (" intent "); if ( intent === " add ") { await addFavorite ( Number ( movieId )); } else { await removeFavorite ( Number ( movieId )); } } import { updateFavorite } from " ./action.ts "; export async function AddToFavoritesForm ({ movieId , } : { movieId : number ; }) { let isFav = await isFavorite ( movieId ); return ( < form action = { updateFavorite } > < input type = " hidden " name = " id " value = { movieId } /> < input type = " hidden " name = " intent " value = { isFav ? " remove " : " add " } /> < AddToFavoritesButton isFav = { isFav } /> </ form > ); } Note that after server functions are called, React Router will automatically revalidate the route and update the UI with the new server content. You don't have to mess around with any cache invalidation. Client Properties Routes are defined on the server at runtime, but we can still provide clientLoader , clientAction , and shouldRevalidate through the utilization of client references and "use client" . " use client "; export function clientAction () {} export function clientLoader () {} export function shouldRevalidate () {} We can then re-export these from our lazy loaded route module: export { clientAction , clientLoader , shouldRevalidate , } from " ./route.client "; export default function Root () { // ... } This is also the way we would make an entire route a Client Component. import { default as ClientRoot } from " ./route.client "; export { clientAction , clientLoader , shouldRevalidate , } from " ./route.client "; export default function Root () { // Adding a Server Component at the root is required by bundlers // if you're using css side-effects imports. return < ClientRoot />; } Bundler Configuration React Router provides several APIs that allow you to easily integrate with RSC-compatible bundlers, useful if you are using React Router Data Mode to make your own custom framework . The following steps show how to setup a React Router application to use Server Components (RSC) to server-render (SSR) pages and hydrate them for single-page app (SPA) navigations. You don't have to use SSR (or even client-side hydration) if you don't want to. You can also leverage the HTML generation for Static Site Generation (SSG) or Incremental Static Regeneration (ISR) if you prefer. This guide is meant merely to explain how to wire up all the different APIs for a typically RSC-based application. Entry points Besides our route definitions , we will need to configure the following: A server to handle the incoming request, fetch the RSC payload, and convert it into HTML A React server to generate RSC payloads A browser handler to hydrate the generated HTML and set the callServer function to support post-hydration server actions The following naming conventions have been chosen for familiarity and simplicity. Feel free to name and configure your entry points as you see fit. See the relevant bundler documentation below for specific code examples for each of the following entry points. These examples all use express and @remix-run/node-fetch-server for the server and request handling. Routes See Configuring Routes . Server You don't have to use SSR at all. You can choose to use RSC to "prerender" HTML for Static Site Generation (SSG) or something like Incremental Static Regeneration (ISR). entry.ssr.tsx is the entry point for the server. It is responsible for handling the request, calling the RSC server, and converting the RSC payload into HTML on document requests (server-side rendering). Relevant APIs: routeRSCServerRequest RSCStaticRouter RSC Server Even though you have a "React Server" and a server responsible for request handling/SSR, you don't actually need to have 2 separate servers. You can simply have 2 separate module graphs within the same server. This is important because React behaves differently when generating RSC payloads vs. when generating HTML to be hydrated on the client. entry.rsc.tsx is the entry point for the React Server. It is responsible for matching the request to a route and generating RSC payloads. Relevant APIs: matchRSCServerRequest Browser entry.browser.tsx is the entry point for the client. It is responsible for hydrating the generated HTML and setting the callServer function to support post-hydration server actions. Relevant APIs: createCallServer getRSCStream RSCHydratedRouter Parcel See the Parcel RSC docs for more information. You can also refer to our Parcel RSC Data Mode template to see a working version. In addition to react , react-dom , and react-router , you'll need the following dependencies: # install runtime dependencies npm i @parcel/runtime-rsc react-server-dom-parcel # install dev dependencies npm i -D parcel package.json To configure Parcel, add the following to your package.json : { " scripts ": { " build ": " parcel build --no-autoinstall ", " dev ": " cross-env NODE_ENV=development parcel --no-autoinstall --no-cache ", " start ": " cross-env NODE_ENV=production node dist/server/entry.rsc.js " }, " targets ": { " react-server ": { " context ": " react-server ", " source ": " src/entry.rsc.tsx ", " scopeHoist ": false , " includeNodeModules ": { " @remix-run/node-fetch-server ": false , " compression ": false , " express ": false } } } } routes/config.ts You must add "use server-entry" to the top of the file where you define your routes. Additionally, you need to import the client entry point, since it will use the "use client-entry" directive (see below). " use server-entry "; import type { unstable_RSCRouteConfig as RSCRouteConfig } from " react-router "; import " ../entry.browser "; // This needs to be a function so Parcel can add a `bootstrapScript` property. export function routes () { return [ { id: " root ", path: "", lazy : () => import (" ./root/route "), children: [ { id: " home ", index: true , lazy : () => import (" ./home/route "), }, { id: " about ", path: " about ", lazy : () => import (" ./about/route "), }, ], }, ] satisfies RSCRouteConfig ; } entry.ssr.tsx The following is a simplified example of a Parcel SSR Server. import { renderToReadableStream as renderHTMLToReadableStream } from " react-dom/server.edge "; import { unstable_routeRSCServerRequest as routeRSCServerRequest , unstable_RSCStaticRouter as RSCStaticRouter , } from " react-router "; import { createFromReadableStream } from " react-server-dom-parcel/client.edge "; export async function generateHTML ( request : Request , fetchServer : ( request : Request ) => Promise < Response >, bootstrapScriptContent : string | undefined , ) : Promise < Response > { return await routeRSCServerRequest ({ // The incoming request. request , // How to call the React Server. fetchServer , // Provide the React Server touchpoints. createFromReadableStream , // Render the router to HTML. async renderHTML ( getPayload ) { const payload = getPayload (); return await renderHTMLToReadableStream ( < RSCStaticRouter getPayload = { getPayload } />, { bootstrapScriptContent , formState: await payload . formState , }, ); }, }); } entry.rsc.tsx The following is a simplified example of a Parcel RSC Server. import { createRequestListener } from " @remix-run/node-fetch-server "; import express from " express "; import { unstable_matchRSCServerRequest as matchRSCServerRequest } from " react-router "; import { createTemporaryReferenceSet , decodeAction , decodeFormState , decodeReply , loadServerAction , renderToReadableStream , } from " react-server-dom-parcel/server.edge "; // Import the generateHTML function from the react-client environment import { generateHTML } from " ./entry.ssr " with { env : " react - client " }; import { routes } from " ./routes/config "; function fetchServer ( request : Request ) { return matchRSCServerRequest ({ // Provide the React Server touchpoints. createTemporaryReferenceSet , decodeAction , decodeFormState , decodeReply , loadServerAction , // The incoming request. request , // The app routes. routes: routes (), // Encode the match with the React Server implementation. generateResponse ( match ) { return new Response ( renderToReadableStream ( match . payload ), { status: match . statusCode , headers: match . headers , }, ); }, }); } const app = express (); // Serve static assets with compression and long cache lifetime. app . use ( " /client ", compression (), express . static (" dist/client ", { immutable: true , maxAge: " 1y ", }), ); // Hook up our application. app . use ( createRequestListener (( request ) => generateHTML ( request , fetchServer , ( routes as unknown as { bootstrapScript ?: string }) . bootstrapScript , ), ), ); app . listen ( 3000 , () => { console . log (" Server listening on port 3000 "); }); entry.browser.tsx " use client-entry "; import { startTransition , StrictMode } from " react "; import { hydrateRoot } from " react-dom/client "; import { unstable_createCallServer as createCallServer , unstable_getRSCStream as getRSCStream , unstable_RSCHydratedRouter as RSCHydratedRouter , type unstable_RSCPayload as RSCServerPayload , } from " react-router "; import { createFromReadableStream , createTemporaryReferenceSet , encodeReply , setServerCallback , } from " react-server-dom-parcel/client "; // Create and set the callServer function to support post-hydration server actions. setServerCallback ( createCallServer ({ createFromReadableStream , createTemporaryReferenceSet , encodeReply , }), ); // Get and decode the initial server payload. createFromReadableStream ( getRSCStream ()). then ( ( payload : RSCServerPayload ) => { startTransition ( async () => { const formState = payload . type === " render " ? await payload . formState : undefined ; hydrateRoot ( document , < StrictMode > < RSCHydratedRouter createFromReadableStream = { createFromReadableStream } payload = { payload } /> </ StrictMode >, { formState , }, ); }); }, ); Vite See the @vitejs/plugin-rsc docs for more information. You can also refer to our Vite RSC Data Mode template to see a working version. In addition to react , react-dom , and react-router , you'll need the following dependencies: npm i -D vite @vitejs/plugin-react @vitejs/plugin-rsc vite.config.ts To configure Vite, add the following to your vite.config.ts : import rsc from " @vitejs/plugin-rsc/plugin "; import react from " @vitejs/plugin-react "; import { defineConfig } from " vite "; export default defineConfig ({ plugins: [ react (), rsc ({ entries: { client: " src/entry.browser.tsx ", rsc: " src/entry.rsc.tsx ", ssr: " src/entry.ssr.tsx ", }, }), ], }); import type { unstable_RSCRouteConfig as RSCRouteConfig } from " react-router "; export function routes () { return [ { id: " root ", path: "", lazy : () => import (" ./root/route "), children: [ { id: " home ", index: true , lazy : () => import (" ./home/route "), }, { id: " about ", path: " about ", lazy : () => import (" ./about/route "), }, ], }, ] satisfies RSCRouteConfig ; } entry.ssr.tsx The following is a simplified example of a Vite SSR Server. import { createFromReadableStream } from " @vitejs/plugin-rsc/ssr "; import { renderToReadableStream as renderHTMLToReadableStream } from " react-dom/server.edge "; import { unstable_routeRSCServerRequest as routeRSCServerRequest , unstable_RSCStaticRouter as RSCStaticRouter , } from " react-router "; export async function generateHTML ( request : Request , fetchServer : ( request : Request ) => Promise < Response >, ) : Promise < Response > { return await routeRSCServerRequest ({ // The incoming request. request , // How to call the React Server. fetchServer , // Provide the React Server touchpoints. createFromReadableStream , // Render the router to HTML. async renderHTML ( getPayload ) { const payload = getPayload (); const bootstrapScriptContent = await import . meta . viteRsc . loadBootstrapScriptContent ( " index ", ); return await renderHTMLToReadableStream ( < RSCStaticRouter getPayload = { getPayload } />, { bootstrapScriptContent , formState: payload . formState , }, ); }, }); } entry.rsc.tsx The following is a simplified example of a Vite RSC Server. import { createTemporaryReferenceSet , decodeAction , decodeFormState , decodeReply , loadServerAction , renderToReadableStream , } from " @vitejs/plugin-rsc/rsc "; import { unstable_matchRSCServerRequest as matchRSCServerRequest } from " react-router "; import { routes } from " ./routes/config "; function fetchServer ( request : Request ) { return matchRSCServerRequest ({ // Provide the React Server touchpoints. createTemporaryReferenceSet , decodeAction , decodeFormState , decodeReply , loadServerAction , // The incoming request. request , // The app routes. routes: routes (), // Encode the match with the React Server implementation. generateResponse ( match ) { return new Response ( renderToReadableStream ( match . payload ), { status: match . statusCode , headers: match . headers , }, ); }, }); } export default async function handler ( request : Request ) { // Import the generateHTML function from the client environment const ssr = await import .meta. viteRsc . loadModule < typeof import (" ./entry.ssr ") > (" ssr ", " index "); return ssr . generateHTML ( request , fetchServer ); } entry.browser.tsx import { createFromReadableStream , createTemporaryReferenceSet , encodeReply , setServerCallback , } from " @vitejs/plugin-rsc/browser "; import { startTransition , StrictMode } from " react "; import { hydrateRoot } from " react-dom/client "; import { unstable_createCallServer as createCallServer , unstable_getRSCStream as getRSCStream , unstable_RSCHydratedRouter as RSCHydratedRouter , type unstable_RSCPayload as RSCServerPayload , } from " react-router "; // Create and set the callServer function to support post-hydration server actions. setServerCallback ( createCallServer ({ createFromReadableStream , createTemporaryReferenceSet , encodeReply , }), ); // Get and decode the initial server payload. createFromReadableStream < RSCServerPayload >( getRSCStream (), ). then (( payload ) => { startTransition ( async () => { const formState = payload . type === " render " ? await payload . formState : undefined ; hydrateRoot ( document , < StrictMode > < RSCHydratedRouter createFromReadableStream = { createFromReadableStream } payload = { payload } /> </ StrictMode >, { formState , }, ); }); }); Brand Assets ‚Ä¢ Docs and examples CC 4.0 Edit (confidence: 0.80)

## Metadata

- **Strategy**: Comprehensive
- **Depth**: 1
- **Sources**: 5
- **Diversity Score**: 1.00
- **Confidence**: High

## Findings

### Finding 1

Finding from Server Components - React: Server Components ‚Äì React React v 19.2 Search ‚åò Ctrl K Learn Reference Community Blog react@19.2 Overview Hooks useActionState useCallback useContext useDebugValue useDeferredValue useEffect useEffectEvent useId useImperativeHandle useInsertionEffect useLayoutEffect useMemo useOptimistic useReducer useRef useState useSyncExternalStore useTransition Components <Fragment> (<>) <Profiler> <StrictMode> <Suspense> <Activity> <ViewTransition> - This feature is available in the latest Canary version of React APIs act addTransitionType - This feature is available in the latest Canary version of React cache cacheSignal captureOwnerStack createContext lazy memo startTransition use experimental_taintObjectReference - This feature is available in the latest Experimental version of React experimental_taintUniqueValue - This feature is available in the latest Experimental version of React react-dom@19.2 Hooks useFormStatus Components Common (e.g. <div>) <form> <input> <option> <progress> <select> <textarea> <link> <meta> <script> <style> <title> APIs createPortal flushSync preconnect prefetchDNS preinit preinitModule preload preloadModule Client APIs createRoot hydrateRoot Server APIs renderToPipeableStream renderToReadableStream renderToStaticMarkup renderToString resume resumeToPipeableStream Static APIs prerender prerenderToNodeStream resumeAndPrerender resumeAndPrerenderToNodeStream React Compiler Configuration compilationMode gating logger panicThreshold target Directives "use memo" "use no memo" Compiling Libraries React DevTools React Performance tracks eslint-plugin-react-hooks Lints exhaustive-deps rules-of-hooks component-hook-factories config error-boundaries gating globals immutability incompatible-library preserve-manual-memoization purity refs set-state-in-effect set-state-in-render static-components unsupported-syntax use-memo Rules of React Overview Components and Hooks must be pure React calls Components and Hooks Rules of Hooks React Server Components Server Components Server Functions Directives 'use client' 'use server' Legacy APIs Legacy React APIs Children cloneElement Component createElement createRef forwardRef isValidElement PureComponent Is this page useful? API Reference Server Components Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server. This separate environment is the ‚Äúserver‚Äù in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server. Server Components without a Server Server Components with a Server Adding interactivity to Server Components Async components with Server Components Note How do I build support for Server Components? While React Server Components in React 19 are stable and will not break between minor versions, the underlying APIs used to implement a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x. To support React Server Components as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement React Server Components in the future. Server Components without a Server Server components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system. Without Server Components, it‚Äôs common to fetch static data on the client with an Effect: // bundle.js import marked from 'marked' ; // 35.9K (11.2K gzipped) import sanitizeHtml from 'sanitize-html' ; // 206K (63.3K gzipped) function Page ( { page } ) { const [ content , setContent ] = useState ( '' ) ; // NOTE: loads *after* first page render. useEffect ( ( ) => { fetch ( `/api/content/ ${ page } ` ) . then ( ( data ) => { setContent ( data . content ) ; } ) ; } , [ page ] ) ; return < div > { sanitizeHtml ( marked ( content ) ) } </ div > ; } // api.js app . get ( `/api/content/:page` , async ( req , res ) => { const page = req . params . page ; const content = await file . readFile ( ` ${ page } .md` ) ; res . send ( { content } ) ; } ) ; This pattern means users need to download and parse an additional 75K (gzipped) of libraries, and wait for a second request to fetch the data after the page loads, just to render static content that will not change for the lifetime of the page. With Server Components, you can render these components once at build time: import marked from 'marked' ; // Not included in bundle import sanitizeHtml from 'sanitize-html' ; // Not included in bundle async function Page ( { page } ) { // NOTE: loads *during* render, when the app is built. const content = await file . readFile ( ` ${ page } .md` ) ; return < div > { sanitizeHtml ( marked ( content ) ) } </ div > ; } The rendered output can then be server-side rendered (SSR) to HTML and uploaded to a CDN. When the app loads, the client will not see the original Page component, or the expensive libraries for rendering the markdown. The client will only see the rendered output: < div > < !-- html for markdown --> </ div > This means the content is visible during first page load, and the bundle does not include the expensive libraries needed to render the static content. Note You may notice that the Server Component above is an async function: async function Page ( { page } ) { //... } Async Components are a new feature of Server Components that allow you to await in render. See Async components with Server Components below. Server Components with a Server Server Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components. Without Server Components, it‚Äôs common to fetch dynamic data on the client in an Effect: // bundle.js function Note ( { id } ) { const [ note , setNote ] = useState ( '' ) ; // NOTE: loads *after* first render. useEffect ( ( ) => { fetch ( `/api/notes/ ${ id } ` ) . then ( data => { setNote ( data . note ) ; } ) ; } , [ id ] ) ; return ( < div > < Author id = { note . authorId } /> < p > { note } </ p > </ div > ) ; } function Author ( { id } ) { const [ author , setAuthor ] = useState ( '' ) ; // NOTE: loads *after* Note renders. // Causing an expensive client-server waterfall. useEffect ( ( ) => { fetch ( `/api/authors/ ${ id } ` ) . then ( data => { setAuthor ( data . author ) ; } ) ; } , [ id ] ) ; return < span > By: { author . name } </ span > ; } // api import db from './database' ; app . get ( `/api/notes/:id` , async ( req , res ) => { const note = await db . notes . get ( id ) ; res . send ( { note } ) ; } ) ; app . get ( `/api/authors/:id` , async ( req , res ) => { const author = await db . authors . get ( id ) ; res . send ( { author } ) ; } ) ; With Server Components, you can read the data and render it in the component: import db from './database' ; async function Note ( { id } ) { // NOTE: loads *during* render. const note = await db . notes . get ( id ) ; return ( < div > < Author id = { note . authorId } /> < p > { note } </ p > </ div > ) ; } async function Author ( { id } ) { // NOTE: loads *after* Note, // but is fast if data is co-located. const author = await db . authors . get ( id ) ; return < span > By: { author . name } </ span > ; } The bundler then combines the data, rendered Server Components and dynamic Client Components into a bundle. Optionally, that bundle can then be server-side rendered (SSR) to create the initial HTML for the page. When the page loads, the browser does not see the original Note and Author components; only the rendered output is sent to the client: < div > < span > By: The React Team </ span > < p > React 19 is... </ p > </ div > Server Components can be made dynamic by re-fetching them from a server, where they can access the data and render again. This new application architecture combines the simple ‚Äúrequest/response‚Äù mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds. Adding interactivity to Server Components Server Components are not sent to the browser, so they cannot use interactive APIs like useState . To add interactivity to Server Components, you can compose them with Client Component using the "use client" directive. Note There is no directive for Server Components. A common misunderstanding is that Server Components are denoted by "use server" , but there is no directive for Server Components. The "use server" directive is used for Server Functions. For more info, see the docs for Directives . In the following example, the Notes Server Component imports an Expandable Client Component that uses state to toggle its expanded state: // Server Component import Expandable from './Expandable' ; async function Notes ( ) { const notes = await db . notes . getAll ( ) ; return ( < div > { notes . map ( note => ( < Expandable key = { note . id } > < p note = { note } /> </ Expandable > ) ) } </ div > ) } // Client Component "use client" export default function Expandable ( { children } ) { const [ expanded , setExpanded ] = useState ( false ) ; return ( < div > < button onClick = { ( ) => setExpanded ( ! expanded ) } > Toggle </ button > { expanded && children } </ div > ) } This works by first rendering Notes as a Server Component, and then instructing the bundler to create a bundle for the Client Component Expandable . In the browser, the Client Components will see output of the Server Components passed as props: < head > < !-- the bundle for Client Components --> < script src = "bundle.js" /> </ head > < body > < div > < Expandable key = { 1 } > < p > this is the first note </ p > </ Expandable > < Expandable key = { 2 } > < p > this is the second note </ p > </ Expandable > < !--...--> </ div > </ body > Async components with Server Components Server Components introduce a new way to write Components using async/await. When you await in an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense. You can even create a promise on the server, and await it on the client: // Server Component import db from './database' ; async function Page ( { id } ) { // Will suspend the Server Component. const note = await db . notes . get ( id ) ; // NOTE: not awaited, will start here and await on the client. const commentsPromise = db . comments . get ( note . id ) ; return ( < div > { note } < Suspense fallback = { < p > Loading Comments... </ p > } > < Comments commentsPromise = { commentsPromise } /> </ Suspense > </ div > ) ; } // Client Component "use client" ; import { use } from 'react' ; function Comments ( { commentsPromise } ) { // NOTE: this will resume the promise from the server. // It will suspend until the data is available. const comments = use ( commentsPromise ) ; return comments . map ( comment => < p > { comment } </ p > ) ; } The note content is important data for the page to render, so we await it on the server. The comments are below the fold and lower-priority, so we start the promise on the server, and wait for it on the client with the use API. This will Suspend on the client, without blocking the note content from rendering. Since async components are not supported on the client, we await the promise with use . Next Server Functions Copyright ¬© Meta Platforms, Inc no uwu plz uwu? Logo by @sawaratsuki1004 Learn React Quick Start Installation Describing the UI Adding Interactivity Managing State Escape Hatches API Reference React APIs React DOM APIs Community Code of Conduct Meet the Team Docs Contributors Acknowledgements More Blog React Native Privacy Terms On this page Overview Server Components without a Server Server Components with a Server Adding interactivity to Server Components Async components with Server Components

**Confidence**: 0.80

### Finding 2

Finding from Server Components and Server Actions in React 19: A Revolution in React ...: Server Components and Server Actions in React 19: A Revolution in React Architecture | by Erick Zanetti | Medium Sitemap Open in app Sign up Sign in Medium Logo Write Search Sign up Sign in Server Components and Server Actions in React 19: A Revolution in React Architecture Erick Zanetti 5 min read ¬∑ Dec 21, 2024 -- 1 Listen Share Discover Server Components and Server Actions in React 19: boosting performance, security, and simplicity for modern, scalable apps. Server Components and Server Actions React 19 introduced impressive new features that promise to transform how we build applications, especially when it comes to server-side rendering and the interaction between client and server. Among these innovations are Server Components and Server Actions, which introduce more efficient paradigms for rendering and state management. In this article, we will dive deeply into these concepts, including examples that show how to apply them in real-world projects. What Are Server Components? Server Components are an extension of the idea of server-side rendering (SSR). Instead of rendering only the final HTML on the server, Server Components allow you to create components that exist only on the server. This means they can directly access databases, APIs, and other resources without sensitive code or data needing to be sent to the client. Benefits of Server Components Better Performance: Since Server Components avoid hydration, the client does not need to re-execute JavaScript to rebuild the application state. Enhanced Security: Sensitive code is not exposed to the client, reducing the risk of information leaks. Smaller Bundle Size: The client only receives the necessary HTML and scripts, reducing the bundle size. How React Distinguishes Client and Server Components React distinguishes between Client Components and Server Components based on specific rules and configurations: Using Directives Components intended for the client must include the directive 'use client' at the top of the file. This explicitly tells React that the component should run on the client. 'use client'; import { useState } from 'react'; export default function Counter() { const [count, setCount] = useState(0); return ( <button onClick={() => setCount(count + 1)}> Count: {count} </button> ); } If the 'use client' directive is not present, React assumes the component is a Server Component and renders it on the server by default. Context of Usage Server Components can import other Server Components or Client Components, but Client Components cannot import Server Components. // Server Component import ClientComponent from './ClientComponent'; export default function ServerComponent() { return ( <div> <h1>This is a Server Component</h1> <ClientComponent /> </div> ); } // Client Component 'use client'; export default function ClientComponent() { return <p>This is a Client Component</p>; } APIs and Hooks Used If a component uses browser-dependent hooks or APIs like useState , useEffect , or DOM manipulation, it must be explicitly marked as a Client Component using 'use client' . Components that access sensitive data or interact with the server environment are automatically treated as Server Components unless explicitly overridden. This clear distinction ensures optimal performance and security while simplifying the development workflow. Server Actions: Handling Data with Simplicity Server Actions allow you to manage state and interactions directly on the server without needing to create REST or GraphQL endpoints for every action. They integrate natively with Server Components and offer a declarative API for handling events and updates. Practical Example: A Contact Form Here is a more complex example that combines Server Components and Server Actions to implement a contact form with server-side validation and real-time feedback. // app/contact/page.server.jsx import { handleContactSubmission } from './actions'; export default function ContactPage() { return ( <ContactForm onSubmit={handleContactSubmission} /> ); } // app/contact/ContactForm.client.jsx 'use client'; import { useState } from 'react'; export default function ContactForm({ onSubmit }) { const [formData, setFormData] = useState({ name: '', email: '', message: '' }); const [isSubmitting, setIsSubmitting] = useState(false); const [error, setError] = useState(null); const [success, setSuccess] = useState(false); const handleChange = (e) => { const { name, value } = e.target; setFormData({ ...formData, [name]: value }); }; const handleSubmit = async (e) => { e.preventDefault(); setIsSubmitting(true); setError(null); try { const response = await onSubmit(formData); if (response.success) { setSuccess(true); } else { setError(response.error); } } catch (err) { setError('Unexpected error. Please try again later.'); } finally { setIsSubmitting(false); } }; if (success) { return <p>Thank you for reaching out! We will respond shortly.</p>; } return ( <form onSubmit={handleSubmit}> <label> Name: <input type="text" name="name" value={formData.name} onChange={handleChange} required /> </label> <label> Email: <input type="email" name="email" value={formData.email} onChange={handleChange} required /> </label> <label> Message: <textarea name="message" value={formData.message} onChange={handleChange} required /> </label> <button type="submit" disabled={isSubmitting}> {isSubmitting ? 'Sending...' : 'Send'} </button> {error && <p className="error">{error}</p>} </form> ); } // app/contact/actions.server.js export async function handleContactSubmission({ name, email, message }) { if (!name || !email || !message) { return { success: false, error: 'All fields are required.' }; } // Simulating a database call try { await saveToDatabase({ name, email, message }); return { success: true }; } catch (error) { return { success: false, error: 'Failed to save to the database.' }; } } async function saveToDatabase(data) { // Replace with your actual implementation console.log('Saving to database:', data); } In this example, the ContactForm component runs on the client, while the form processing logic is abstracted into a Server Action called handleContactSubmission . This separation ensures security and performance by preventing sensitive logic from being exposed on the client. Precautions and Limitations Complexity Management: Mixing Server Components and Client Components can add cognitive load to the project. Carefully plan the boundaries between client and server logic. Latency Concerns: Server Actions rely on network communication. Poorly optimized server infrastructure can lead to high latency. Server Load: Offloading more logic to the server can increase its load. Monitor resource usage to avoid bottlenecks. Browser Support: Ensure your application gracefully degrades for older browsers or environments that do not fully support modern JavaScript features. Debugging Challenges: Debugging issues that span client and server can be more complex, requiring robust logging and monitoring solutions. Best Practices for Working with Server Components and Server Actions Minimize Client-Side JavaScript: Use Server Components whenever possible to reduce the amount of JavaScript executed on the browser. Smart Abstractions: Organize your Server Actions into reusable modules. Avoid Overfetching: Only load the data necessary for each Server Component. Test Extensively: Simulate failure scenarios to ensure the resilience of your Server Actions. Conclusion Server Components and Server Actions in React 19 represent a significant step towards more efficient and secure applications. By combining the simplicity of React with the power of server-side rendering and state management, these tools become indispensable for developers aiming to create modern and scalable applications. Try out these features and see how they can transform your development workflow. Follow me on LinkedIn: https://www.linkedin.com/in/erickzanetti React React 19 Server Components Server Action -- -- 1 Written by Erick Zanetti 1.5K followers ¬∑ 5 following Full Stack developer with Node and React. Learning Go. Responses ( 1 ) See all responses Help Status About Careers Press Blog Privacy Rules Terms Text to speech

**Confidence**: 0.80

### Finding 3

Finding from React Server Components: React Server Components | React Router latest Branches latest ( 7.9.4 ) dev Versions 7.9.4 6.30.1 v4/5.x v3.x API Reference Search Light Dark System React Server Components Changelog Getting Started Picking a Mode Framework Mode Installation Routing Route Module Rendering Strategies Data Loading Actions Navigating Pending UI Testing Deploying Data Mode Installation Routing Route Object Data Loading Actions Navigating Pending UI Custom Framework Testing Declarative Mode Installation Routing Navigating URL Values Upgrading Future Flags Upgrading from v6 Upgrading from Remix Framework Adoption from Component Routes Framework Adoption from RouterProvider API Components Await Form Link Links Meta NavLink Navigate Outlet PrefetchPageLinks Route Routes Scripts ScrollRestoration Hooks useActionData useAsyncError useAsyncValue useBeforeUnload useBlocker useFetcher useFetchers useFormAction useHref useInRouterContext useLinkClickHandler useLoaderData useLocation useMatch useMatches useNavigate useNavigation useNavigationType useOutlet useOutletContext useParams usePrompt üß™ useResolvedPath useRevalidator useRouteError useRouteLoaderData useRoutes useSearchParams useSubmit useViewTransitionState Framework Conventions root.tsx routes.ts react-router.config.ts entry.client.tsx entry.server.tsx .client modules .server modules Framework Routers HydratedRouter ServerRouter Data Routers RouterProvider StaticRouterProvider createBrowserRouter createHashRouter createMemoryRouter createStaticHandler createStaticRouter Declarative Routers BrowserRouter HashRouter HistoryRouter üß™ MemoryRouter Router StaticRouter RSC (Unstable) RSCHydratedRouter üß™ RSCStaticRouter üß™ createCallServer üß™ getRSCStream üß™ matchRSCServerRequest üß™ routeRSCServerRequest üß™ Utils IsCookieFunction IsSessionFunction RouterContextProvider createContext createCookie createCookieSessionStorage createMemorySessionStorage createPath createRoutesFromElements createRoutesStub createSearchParams data generatePath href isCookie isRouteErrorResponse isSession matchPath matchRoutes parsePath redirect redirectDocument renderMatches replace resolvePath Other API @react-router/{adapter} @react-router/dev (CLI) @react-router/serve Tutorials Quick Start Address Book How-Tos Accessibility Client Data Error Boundaries Error Reporting Using Fetchers File Route Conventions File Uploads Form Validation HTTP Headers Middleware Navigation Blocking Pre-Rendering Presets React Server Components üß™ Resource Routes Route Module Type Safety Security Server Bundles Single Page App (SPA) Status Codes Streaming with Suspense Using handle View Transitions Explanations Backend For Frontend Automatic Code Splitting Network Concurrency Management Form vs. fetcher Hot Module Replacement Index Query Param Lazy Route Discovery Progressive Enhancement Race Conditions Sessions and Cookies State Management Type Safety Community API Development Strategy Contributing Changelog Getting Started Picking a Mode Framework Mode Installation Routing Route Module Rendering Strategies Data Loading Actions Navigating Pending UI Testing Deploying Data Mode Installation Routing Route Object Data Loading Actions Navigating Pending UI Custom Framework Testing Declarative Mode Installation Routing Navigating URL Values Upgrading Future Flags Upgrading from v6 Upgrading from Remix Framework Adoption from Component Routes Framework Adoption from RouterProvider API Components Await Form Link Links Meta NavLink Navigate Outlet PrefetchPageLinks Route Routes Scripts ScrollRestoration Hooks useActionData useAsyncError useAsyncValue useBeforeUnload useBlocker useFetcher useFetchers useFormAction useHref useInRouterContext useLinkClickHandler useLoaderData useLocation useMatch useMatches useNavigate useNavigation useNavigationType useOutlet useOutletContext useParams usePrompt üß™ useResolvedPath useRevalidator useRouteError useRouteLoaderData useRoutes useSearchParams useSubmit useViewTransitionState Framework Conventions root.tsx routes.ts react-router.config.ts entry.client.tsx entry.server.tsx .client modules .server modules Framework Routers HydratedRouter ServerRouter Data Routers RouterProvider StaticRouterProvider createBrowserRouter createHashRouter createMemoryRouter createStaticHandler createStaticRouter Declarative Routers BrowserRouter HashRouter HistoryRouter üß™ MemoryRouter Router StaticRouter RSC (Unstable) RSCHydratedRouter üß™ RSCStaticRouter üß™ createCallServer üß™ getRSCStream üß™ matchRSCServerRequest üß™ routeRSCServerRequest üß™ Utils IsCookieFunction IsSessionFunction RouterContextProvider createContext createCookie createCookieSessionStorage createMemorySessionStorage createPath createRoutesFromElements createRoutesStub createSearchParams data generatePath href isCookie isRouteErrorResponse isSession matchPath matchRoutes parsePath redirect redirectDocument renderMatches replace resolvePath Other API @react-router/{adapter} @react-router/dev (CLI) @react-router/serve Tutorials Quick Start Address Book How-Tos Accessibility Client Data Error Boundaries Error Reporting Using Fetchers File Route Conventions File Uploads Form Validation HTTP Headers Middleware Navigation Blocking Pre-Rendering Presets React Server Components üß™ Resource Routes Route Module Type Safety Security Server Bundles Single Page App (SPA) Status Codes Streaming with Suspense Using handle View Transitions Explanations Backend For Frontend Automatic Code Splitting Network Concurrency Management Form vs. fetcher Hot Module Replacement Index Query Param Lazy Route Discovery Progressive Enhancement Race Conditions Sessions and Cookies State Management Type Safety Community API Development Strategy Contributing Copy Page Copy Page Copy Page as Markdown Edit Page Edit this page on Github On this page Quick Start RSC Framework Mode Template RSC Data Mode Templates RSC Framework Mode New React Router RSC Vite Plugin Build Output React Elements From Loaders/Actions Server Component Routes .server / .client Modules MDX Route Support Unsupported Config Options RSC Data Mode Configuring Routes Server Component Routes Server Functions Client Properties Bundler Configuration Entry points Parcel Vite On this page Quick Start RSC Framework Mode Template RSC Data Mode Templates RSC Framework Mode New React Router RSC Vite Plugin Build Output React Elements From Loaders/Actions Server Component Routes .server / .client Modules MDX Route Support Unsupported Config Options RSC Data Mode Configuring Routes Server Component Routes Server Functions Client Properties Bundler Configuration Entry points Parcel Vite React Server Components Framework Data Declarative React Server Components support is experimental and subject to breaking changes. React Server Components (RSC) refers generally to an architecture and set of APIs provided by React since version 19. From the docs: Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server. - React "Server Components" docs React Router provides a set of APIs for integrating with RSC-compatible bundlers, allowing you to leverage Server Components and Server Functions in your React Router applications. If you're unfamiliar with these React features, we recommend reading the official Server Components documentation before using React Router's RSC APIs. RSC support is available in both Framework and Data Modes. For more information on the conceptual difference between these, see "Picking a Mode" . However, note that the APIs and features differ between RSC and non-RSC modes in ways that this guide will cover in more detail. Quick Start The quickest way to get started is with one of our templates. These templates come with React Router RSC APIs already configured, offering you out of the box features such as: Server Component Routes Server Side Rendering (SSR) Client Components (via "use client" directive) Server Functions (via "use server" directive) RSC Framework Mode Template The RSC Framework Mode template uses the unstable React Router RSC Vite plugin along with the experimental @vitejs/plugin-rsc plugin . npx create-react-router@latest --template remix-run/react-router-templates/unstable_rsc-framework-mode RSC Data Mode Templates When using RSC Data Mode, you can choose between the Vite and Parcel templates. The Vite RSC Data Mode template uses the experimental Vite @vitejs/plugin-rsc plugin. npx create-react-router@latest --template remix-run/react-router-templates/unstable_rsc-data-mode-vite The Parcel RSC Data Mode template uses the official React react-server-dom-parcel plugin. npx create-react-router@latest --template remix-run/react-router-templates/unstable_rsc-data-mode-parcel RSC Framework Mode Most APIs and features in RSC Framework Mode are the same as non-RSC Framework Mode, so this guide will focus on the differences. New React Router RSC Vite Plugin RSC Framework Mode uses a different Vite plugin than non-RSC Framework Mode, currently exported as unstable_reactRouterRSC . This new Vite plugin also has a peer dependency on the experimental @vitejs/plugin-rsc plugin. Note that the @vitejs/plugin-rsc plugin should be placed after the React Router RSC plugin in your Vite config. import { defineConfig } from " vite "; import { unstable_reactRouterRSC as reactRouterRSC } from " @react-router/dev/vite "; import rsc from " @vitejs/plugin-rsc "; export default defineConfig ({ plugins: [ reactRouterRSC (), rsc ()], }); Build Output The RSC Framework Mode server build file ( build/server/index.js ) now exports a default request handler function ( (request: Request) => Promise<Response> ) for document/data requests. If needed, you can convert this into a standard Node.js request listener for use with Node's built-in http.createServer function (or anything that supports it, e.g. Express ) by using the createRequestListener function from @remix-run/node-fetch-server . For example, in Express: import express from " express "; import requestHandler from " ./build/server/index.js "; import { createRequestListener } from " @remix-run/node-fetch-server "; const app = express (); app . use ( " /assets ", express . static (" build/client/assets ", { immutable: true , maxAge: " 1y ", }), ); app . use ( express . static (" build/client ")); app . use ( createRequestListener ( requestHandler )); app . listen ( 3000 ); React Elements From Loaders/Actions In RSC Framework Mode, loaders and actions can now return React elements along with other data. These elements will only ever be rendered on the server. import type { Route } from " ./+types/route "; export async function loader () { return { message: " Message from the server! ", element: < p >Element from the server!</ p >, }; } export default function Route ({ loaderData , } : Route . ComponentProps ) { return ( <> < h1 > { loaderData . message } </ h1 > { loaderData . element } </> ); } If you need to use client-only features (e.g. Hooks , event handlers) within React elements returned from loaders/actions, you'll need to extract components using these features into a client module : " use client "; export function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < button onClick = { () => setCount ( count + 1 ) } > Count: { count } </ button > ); } import type { Route } from " ./+types/route "; import { Counter } from " ./counter "; export async function loader () { return { message: " Message from the server! ", element : ( <> < p >Element from the server!</ p > < Counter /> </> ), }; } export default function Route ({ loaderData , } : Route . ComponentProps ) { return ( <> < h1 > { loaderData . message } </ h1 > { loaderData . element } </> ); } Server Component Routes If a route exports a ServerComponent instead of the typical default component export, this component along with other route components ( ErrorBoundary , HydrateFallback , Layout ) will be server components rather than the usual client components. import type { Route } from " ./+types/route "; import { Outlet } from " react-router "; import { getMessage } from " ./message "; export async function loader () { return { message: await getMessage (), }; } export function ServerComponent ({ loaderData , } : Route . ComponentProps ) { return ( <> < h1 >Server Component Route</ h1 > < p >Message from the server: { loaderData . message } </ p > < Outlet /> </> ); } If you need to use client-only features (e.g. Hooks , event handlers) within a server-first route, you'll need to extract components using these features into a client module : " use client "; export function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < button onClick = { () => setCount ( count + 1 ) } > Count: { count } </ button > ); } import { Counter } from " ./counter "; export function ServerComponent () { return ( <> < h1 >Counter</ h1 > < Counter /> </> ); } .server / .client Modules To avoid confusion with RSC's "use server" and "use client" directives, support for .server modules and .client modules is no longer built-in when using RSC Framework Mode. As an alternative solution that doesn't rely on file naming conventions, we recommend using the "server-only" and "client-only" imports provided by @vitejs/plugin-rsc . For example, to ensure a module is never accidentally included in the client build, simply import from "server-only" as a side effect within your server-only module. import " server-only "; // Rest of the module... Note that while there are official npm packages server-only and client-only created by the React team, they don't need to be installed. @vitejs/plugin-rsc internally handles these imports and provides build-time validation instead of runtime errors. If you'd like to quickly migrate existing code that relies on the .server and .client file naming conventions, we recommend using the vite-env-only plugin directly. For example, to ensure .server modules aren't accidentally included in the client build: import { defineConfig } from " vite "; import { denyImports } from " vite-env-only "; import { unstable_reactRouterRSC as reactRouterRSC } from " @react-router/dev/vite "; import rsc from " @vitejs/plugin-rsc "; export default defineConfig ({ plugins: [ denyImports ({ client: { files: [" **/.server/* ", " **/*.server.* "] }, }), reactRouterRSC (), rsc (), ], }); MDX Route Support MDX routes are supported in RSC Framework Mode when using @mdx-js/rollup v3.1.1+. Note that any components exported from an MDX route must also be valid in RSC environments, meaning that they cannot use client-only features like Hooks . Any components that need to use these features should be extracted into a client module . Unsupported Config Options For the initial unstable release, the following options from react-router.config.ts are not yet supported in RSC Framework Mode: buildEnd prerender presets routeDiscovery serverBundles ssr: false (SPA Mode) future.unstable_splitRouteModules future.unstable_subResourceIntegrity Custom build entry files are also not yet supported. RSC Data Mode The RSC Framework Mode APIs described above are built on top of lower-level RSC Data Mode APIs. RSC Data Mode is missing some of the features of RSC Framework Mode (e.g. routes.ts config and file system routing, HMR and Hot Data Revalidation), but is more flexible and allows you to integrate with your own bundler and server abstractions. Configuring Routes Routes are configured as an argument to matchRSCServerRequest . At a minimum, you need a path and component: function Root () { return < h1 >Hello world</ h1 >; } matchRSCServerRequest ({ // ...other options routes: [{ path: " / ", Component: Root }], }); While you can define components inline, we recommend using the lazy() option and defining Route Modules for both startup performance and code organization The Route Module API up until now has been a Framework Mode only feature. However, the lazy field of the RSC route config expects the same exports as the Route Module exports, unifying the APIs even further. import type { unstable_RSCRouteConfig as RSCRouteConfig } from " react-router "; export function routes () { return [ { id: " root ", path: "", lazy : () => import (" ./root/route "), children: [ { id: " home ", index: true , lazy : () => import (" ./home/route "), }, { id: " about ", path: " about ", lazy : () => import (" ./about/route "), }, ], }, ] satisfies RSCRouteConfig ; } Server Component Routes By default each route's default export renders a Server Component export default function Home () { return ( < main > < article > < h1 >Welcome to React Router RSC</ h1 > < p > You won't find me running any JavaScript in the browser! </ p > </ article > </ main > ); } A nice feature of Server Components is that you can fetch data directly from your component by making it asynchronous. export default async function Home () { let user = await getUserData (); return ( < main > < article > < h1 >Welcome to React Router RSC</ h1 > < p > You won't find me running any JavaScript in the browser! </ p > < p > Hello, { user ? user . name : " anonymous person " } ! </ p > </ article > </ main > ); } Server Components can also be returned from your loaders and actions. In general, if you are using RSC to build your application, loaders are primarily useful for things like setting status codes or returning a redirect . Using Server Components in loaders can be helpful for incremental adoption of RSC. Server Functions Server Functions are a React feature that allow you to call async functions executed on the server. They're defined with the "use server" directive. " use server "; export async function updateFavorite ( formData : FormData ) { let movieId = formData . get (" id "); let intent = formData . get (" intent "); if ( intent === " add ") { await addFavorite ( Number ( movieId )); } else { await removeFavorite ( Number ( movieId )); } } import { updateFavorite } from " ./action.ts "; export async function AddToFavoritesForm ({ movieId , } : { movieId : number ; }) { let isFav = await isFavorite ( movieId ); return ( < form action = { updateFavorite } > < input type = " hidden " name = " id " value = { movieId } /> < input type = " hidden " name = " intent " value = { isFav ? " remove " : " add " } /> < AddToFavoritesButton isFav = { isFav } /> </ form > ); } Note that after server functions are called, React Router will automatically revalidate the route and update the UI with the new server content. You don't have to mess around with any cache invalidation. Client Properties Routes are defined on the server at runtime, but we can still provide clientLoader , clientAction , and shouldRevalidate through the utilization of client references and "use client" . " use client "; export function clientAction () {} export function clientLoader () {} export function shouldRevalidate () {} We can then re-export these from our lazy loaded route module: export { clientAction , clientLoader , shouldRevalidate , } from " ./route.client "; export default function Root () { // ... } This is also the way we would make an entire route a Client Component. import { default as ClientRoot } from " ./route.client "; export { clientAction , clientLoader , shouldRevalidate , } from " ./route.client "; export default function Root () { // Adding a Server Component at the root is required by bundlers // if you're using css side-effects imports. return < ClientRoot />; } Bundler Configuration React Router provides several APIs that allow you to easily integrate with RSC-compatible bundlers, useful if you are using React Router Data Mode to make your own custom framework . The following steps show how to setup a React Router application to use Server Components (RSC) to server-render (SSR) pages and hydrate them for single-page app (SPA) navigations. You don't have to use SSR (or even client-side hydration) if you don't want to. You can also leverage the HTML generation for Static Site Generation (SSG) or Incremental Static Regeneration (ISR) if you prefer. This guide is meant merely to explain how to wire up all the different APIs for a typically RSC-based application. Entry points Besides our route definitions , we will need to configure the following: A server to handle the incoming request, fetch the RSC payload, and convert it into HTML A React server to generate RSC payloads A browser handler to hydrate the generated HTML and set the callServer function to support post-hydration server actions The following naming conventions have been chosen for familiarity and simplicity. Feel free to name and configure your entry points as you see fit. See the relevant bundler documentation below for specific code examples for each of the following entry points. These examples all use express and @remix-run/node-fetch-server for the server and request handling. Routes See Configuring Routes . Server You don't have to use SSR at all. You can choose to use RSC to "prerender" HTML for Static Site Generation (SSG) or something like Incremental Static Regeneration (ISR). entry.ssr.tsx is the entry point for the server. It is responsible for handling the request, calling the RSC server, and converting the RSC payload into HTML on document requests (server-side rendering). Relevant APIs: routeRSCServerRequest RSCStaticRouter RSC Server Even though you have a "React Server" and a server responsible for request handling/SSR, you don't actually need to have 2 separate servers. You can simply have 2 separate module graphs within the same server. This is important because React behaves differently when generating RSC payloads vs. when generating HTML to be hydrated on the client. entry.rsc.tsx is the entry point for the React Server. It is responsible for matching the request to a route and generating RSC payloads. Relevant APIs: matchRSCServerRequest Browser entry.browser.tsx is the entry point for the client. It is responsible for hydrating the generated HTML and setting the callServer function to support post-hydration server actions. Relevant APIs: createCallServer getRSCStream RSCHydratedRouter Parcel See the Parcel RSC docs for more information. You can also refer to our Parcel RSC Data Mode template to see a working version. In addition to react , react-dom , and react-router , you'll need the following dependencies: # install runtime dependencies npm i @parcel/runtime-rsc react-server-dom-parcel # install dev dependencies npm i -D parcel package.json To configure Parcel, add the following to your package.json : { " scripts ": { " build ": " parcel build --no-autoinstall ", " dev ": " cross-env NODE_ENV=development parcel --no-autoinstall --no-cache ", " start ": " cross-env NODE_ENV=production node dist/server/entry.rsc.js " }, " targets ": { " react-server ": { " context ": " react-server ", " source ": " src/entry.rsc.tsx ", " scopeHoist ": false , " includeNodeModules ": { " @remix-run/node-fetch-server ": false , " compression ": false , " express ": false } } } } routes/config.ts You must add "use server-entry" to the top of the file where you define your routes. Additionally, you need to import the client entry point, since it will use the "use client-entry" directive (see below). " use server-entry "; import type { unstable_RSCRouteConfig as RSCRouteConfig } from " react-router "; import " ../entry.browser "; // This needs to be a function so Parcel can add a `bootstrapScript` property. export function routes () { return [ { id: " root ", path: "", lazy : () => import (" ./root/route "), children: [ { id: " home ", index: true , lazy : () => import (" ./home/route "), }, { id: " about ", path: " about ", lazy : () => import (" ./about/route "), }, ], }, ] satisfies RSCRouteConfig ; } entry.ssr.tsx The following is a simplified example of a Parcel SSR Server. import { renderToReadableStream as renderHTMLToReadableStream } from " react-dom/server.edge "; import { unstable_routeRSCServerRequest as routeRSCServerRequest , unstable_RSCStaticRouter as RSCStaticRouter , } from " react-router "; import { createFromReadableStream } from " react-server-dom-parcel/client.edge "; export async function generateHTML ( request : Request , fetchServer : ( request : Request ) => Promise < Response >, bootstrapScriptContent : string | undefined , ) : Promise < Response > { return await routeRSCServerRequest ({ // The incoming request. request , // How to call the React Server. fetchServer , // Provide the React Server touchpoints. createFromReadableStream , // Render the router to HTML. async renderHTML ( getPayload ) { const payload = getPayload (); return await renderHTMLToReadableStream ( < RSCStaticRouter getPayload = { getPayload } />, { bootstrapScriptContent , formState: await payload . formState , }, ); }, }); } entry.rsc.tsx The following is a simplified example of a Parcel RSC Server. import { createRequestListener } from " @remix-run/node-fetch-server "; import express from " express "; import { unstable_matchRSCServerRequest as matchRSCServerRequest } from " react-router "; import { createTemporaryReferenceSet , decodeAction , decodeFormState , decodeReply , loadServerAction , renderToReadableStream , } from " react-server-dom-parcel/server.edge "; // Import the generateHTML function from the react-client environment import { generateHTML } from " ./entry.ssr " with { env : " react - client " }; import { routes } from " ./routes/config "; function fetchServer ( request : Request ) { return matchRSCServerRequest ({ // Provide the React Server touchpoints. createTemporaryReferenceSet , decodeAction , decodeFormState , decodeReply , loadServerAction , // The incoming request. request , // The app routes. routes: routes (), // Encode the match with the React Server implementation. generateResponse ( match ) { return new Response ( renderToReadableStream ( match . payload ), { status: match . statusCode , headers: match . headers , }, ); }, }); } const app = express (); // Serve static assets with compression and long cache lifetime. app . use ( " /client ", compression (), express . static (" dist/client ", { immutable: true , maxAge: " 1y ", }), ); // Hook up our application. app . use ( createRequestListener (( request ) => generateHTML ( request , fetchServer , ( routes as unknown as { bootstrapScript ?: string }) . bootstrapScript , ), ), ); app . listen ( 3000 , () => { console . log (" Server listening on port 3000 "); }); entry.browser.tsx " use client-entry "; import { startTransition , StrictMode } from " react "; import { hydrateRoot } from " react-dom/client "; import { unstable_createCallServer as createCallServer , unstable_getRSCStream as getRSCStream , unstable_RSCHydratedRouter as RSCHydratedRouter , type unstable_RSCPayload as RSCServerPayload , } from " react-router "; import { createFromReadableStream , createTemporaryReferenceSet , encodeReply , setServerCallback , } from " react-server-dom-parcel/client "; // Create and set the callServer function to support post-hydration server actions. setServerCallback ( createCallServer ({ createFromReadableStream , createTemporaryReferenceSet , encodeReply , }), ); // Get and decode the initial server payload. createFromReadableStream ( getRSCStream ()). then ( ( payload : RSCServerPayload ) => { startTransition ( async () => { const formState = payload . type === " render " ? await payload . formState : undefined ; hydrateRoot ( document , < StrictMode > < RSCHydratedRouter createFromReadableStream = { createFromReadableStream } payload = { payload } /> </ StrictMode >, { formState , }, ); }); }, ); Vite See the @vitejs/plugin-rsc docs for more information. You can also refer to our Vite RSC Data Mode template to see a working version. In addition to react , react-dom , and react-router , you'll need the following dependencies: npm i -D vite @vitejs/plugin-react @vitejs/plugin-rsc vite.config.ts To configure Vite, add the following to your vite.config.ts : import rsc from " @vitejs/plugin-rsc/plugin "; import react from " @vitejs/plugin-react "; import { defineConfig } from " vite "; export default defineConfig ({ plugins: [ react (), rsc ({ entries: { client: " src/entry.browser.tsx ", rsc: " src/entry.rsc.tsx ", ssr: " src/entry.ssr.tsx ", }, }), ], }); import type { unstable_RSCRouteConfig as RSCRouteConfig } from " react-router "; export function routes () { return [ { id: " root ", path: "", lazy : () => import (" ./root/route "), children: [ { id: " home ", index: true , lazy : () => import (" ./home/route "), }, { id: " about ", path: " about ", lazy : () => import (" ./about/route "), }, ], }, ] satisfies RSCRouteConfig ; } entry.ssr.tsx The following is a simplified example of a Vite SSR Server. import { createFromReadableStream } from " @vitejs/plugin-rsc/ssr "; import { renderToReadableStream as renderHTMLToReadableStream } from " react-dom/server.edge "; import { unstable_routeRSCServerRequest as routeRSCServerRequest , unstable_RSCStaticRouter as RSCStaticRouter , } from " react-router "; export async function generateHTML ( request : Request , fetchServer : ( request : Request ) => Promise < Response >, ) : Promise < Response > { return await routeRSCServerRequest ({ // The incoming request. request , // How to call the React Server. fetchServer , // Provide the React Server touchpoints. createFromReadableStream , // Render the router to HTML. async renderHTML ( getPayload ) { const payload = getPayload (); const bootstrapScriptContent = await import . meta . viteRsc . loadBootstrapScriptContent ( " index ", ); return await renderHTMLToReadableStream ( < RSCStaticRouter getPayload = { getPayload } />, { bootstrapScriptContent , formState: payload . formState , }, ); }, }); } entry.rsc.tsx The following is a simplified example of a Vite RSC Server. import { createTemporaryReferenceSet , decodeAction , decodeFormState , decodeReply , loadServerAction , renderToReadableStream , } from " @vitejs/plugin-rsc/rsc "; import { unstable_matchRSCServerRequest as matchRSCServerRequest } from " react-router "; import { routes } from " ./routes/config "; function fetchServer ( request : Request ) { return matchRSCServerRequest ({ // Provide the React Server touchpoints. createTemporaryReferenceSet , decodeAction , decodeFormState , decodeReply , loadServerAction , // The incoming request. request , // The app routes. routes: routes (), // Encode the match with the React Server implementation. generateResponse ( match ) { return new Response ( renderToReadableStream ( match . payload ), { status: match . statusCode , headers: match . headers , }, ); }, }); } export default async function handler ( request : Request ) { // Import the generateHTML function from the client environment const ssr = await import .meta. viteRsc . loadModule < typeof import (" ./entry.ssr ") > (" ssr ", " index "); return ssr . generateHTML ( request , fetchServer ); } entry.browser.tsx import { createFromReadableStream , createTemporaryReferenceSet , encodeReply , setServerCallback , } from " @vitejs/plugin-rsc/browser "; import { startTransition , StrictMode } from " react "; import { hydrateRoot } from " react-dom/client "; import { unstable_createCallServer as createCallServer , unstable_getRSCStream as getRSCStream , unstable_RSCHydratedRouter as RSCHydratedRouter , type unstable_RSCPayload as RSCServerPayload , } from " react-router "; // Create and set the callServer function to support post-hydration server actions. setServerCallback ( createCallServer ({ createFromReadableStream , createTemporaryReferenceSet , encodeReply , }), ); // Get and decode the initial server payload. createFromReadableStream < RSCServerPayload >( getRSCStream (), ). then (( payload ) => { startTransition ( async () => { const formState = payload . type === " render " ? await payload . formState : undefined ; hydrateRoot ( document , < StrictMode > < RSCHydratedRouter createFromReadableStream = { createFromReadableStream } payload = { payload } /> </ StrictMode >, { formState , }, ); }); }); Brand Assets ‚Ä¢ Docs and examples CC 4.0 Edit

**Confidence**: 0.80

### Finding 4

Finding from A Deep Dive into React Server Components: What Frontend Developers Need ...: A Deep Dive into React Server Components: What Frontend Developers Need to Know - DEV Community Forem Feed Follow new Subforems to improve your feed DEV Community Follow A space to discuss and keep up software development and manage your software career Gamers Forem Follow An inclusive community for gaming enthusiasts Future Follow News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more. Music Forem Follow From composing and gigging to gear, hot music takes, and everything in between. Vibe Coding Forem Follow Discussing AI software development, and showing off what we're building. Open Forem Follow A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here Popcorn Movies and TV Follow Movie and TV enthusiasm, criticism and everything in-between. DUMB DEV Community Follow Memes and software development shitposting Design Community Follow Web design, graphic design and everything in-between Golf Forem Follow A community of golfers and golfing enthusiasts Security Forem Follow Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike Scale Forem Follow For engineers building software at scale. We discuss architecture, cloud-native, and SRE‚Äîthe hard-won lessons you can't just Google Forem Core Follow Discussing the core forem open source software project ‚Äî features, bugs, performance, self-hosting. Crypto Forem Follow A collaborative community for all things Crypto‚Äîfrom Bitcoin to protocol development and DeFi to NFTs and market analysis. Parenting Follow A place for parents to the share the joys, challenges, and wisdom that come from raising kids. We're here for them and for each other. Maker Forem Follow A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more. Dropdown menu Dropdown menu Skip to content Navigation menu Search Powered by Algolia Search Log in Create account DEV Community Close Add reaction Like Unicorn Exploding Head Raised Hands Fire Jump to Comments Save Boost More... Moderate Copy link Copy link Copied to Clipboard Share to X Share to LinkedIn Share to Facebook Share to Mastodon Share Post via... Report Abuse Delia Posted on Oct 2, 2024 A Deep Dive into React Server Components: What Frontend Developers Need to Know # react # webdev # programming # javascript React Server Components (RSCs) are an exciting new feature in React that is revolutionising how developers build web applications. Introduced as part of React's plan to bridge the gap between server and client-side rendering, RSCs promise improved performance, cleaner architecture, and a more efficient developer experience. In this article, we‚Äôll take a deep dive into React Server Components, explain what they are, how they work, and why they matter to modern frontend development. Let‚Äôs break down the key concepts step by step. What Are React Server Components? React Server Components are a type of component that allows React to render parts of an application on the server, rather than entirely on the client side. They enable you to: Render components server-side without shipping extra JavaScript to the client. Fetch data directly from the server without relying on client-side fetching mechanisms. Send minimal updates to the client for a more optimized experience. In simpler terms, RSCs let you handle components in such a way that some parts of your app don‚Äôt require heavy client-side logic or JavaScript bundles. This means smaller downloads for users and better performance. Why React Server Components Matter There are several benefits to using React Server Components, especially in applications that demand high performance and scalability: 1. Reduced JavaScript Payload Traditional client-side rendering requires sending the entire JavaScript bundle to the client, which can slow down load times. RSCs allow components to be rendered on the server and send only the essential HTML and minimal client-side JavaScript. This can drastically reduce the amount of JavaScript that needs to be executed in the browser. 2. Improved Data Fetching With RSCs, data fetching happens server-side, which means you don‚Äôt need to wait for client-side JavaScript to load and make API requests. This can reduce the complexity of data management, improving user experience with faster time-to-first-byte (TTFB) and reducing the need for client-side loading states. 3. Better Performance in Low-Bandwidth Environments Since RSCs allow server-rendered components without shipping extra JavaScript to the client, they are perfect for low-bandwidth environments. Pages can load faster even on slower connections or older devices. 4. Simpler Code for Complex Applications By offloading complex business logic and data fetching to the server, RSCs can make your codebase more maintainable. You can handle complex server logic without duplicating it across client and server components. How React Server Components Work React Server Components operate in conjunction with the traditional client-side React model, but they differ in significant ways. Here‚Äôs a breakdown of how they work: 1. RSCs Are Rendered on the Server Unlike typical React components that are rendered on the client, RSCs are rendered on the server. They don‚Äôt execute any code on the client side, meaning they don‚Äôt contribute to the JavaScript bundle size. 2. Streaming HTML to the Client Once the RSC is rendered on the server, the resulting HTML is streamed to the client. Since there‚Äôs no need to hydrate the component with client-side JavaScript, this reduces the amount of work the browser has to do. This streaming happens incrementally, ensuring faster page rendering. 3. Data Fetching Happens Directly on the Server RSCs can fetch data directly from your server‚Äôs backend (such as databases or APIs) without the need for client-side fetching tools like useEffect or SWR . This simplifies data fetching logic and keeps sensitive data secure, as it stays on the server. 4. Mixing Server and Client Components React‚Äôs architecture allows you to mix server components with client-side components. For example, you could have a server component fetching data and rendering the structure of a page, while client-side components handle interactive elements like buttons, forms, or dynamic updates. Understanding the Limitations of React Server Components While RSCs are incredibly powerful, they do come with some limitations, which developers need to be aware of: 1. No Client-Side Interactivity RSCs don‚Äôt support client-side interactions like event handling ( onClick , onSubmit , etc.). If you need interactivity, you‚Äôll still need traditional React client components for those parts of your app. 2. Limited Browser APIs Because RSCs run on the server, they can‚Äôt access browser-specific APIs like localStorage , window , or document . This is by design, as RSCs focus on server-side rendering and data fetching. 3. Increased Complexity for Some Applications For smaller apps or projects where you don‚Äôt need complex server-side rendering, RSCs might introduce unnecessary complexity. You need to evaluate whether the benefits of RSCs outweigh the learning curve and setup for your particular use case. Building a Simple React Server Component Now, let‚Äôs look at an example of how to create a basic React Server Component. 1. Server Component Example // UserProfile.server.js export default async function UserProfile ({ userId }) { const user = await fetch ( `https://api.example.com/users/ ${ userId } ` ). then ( res => res . json ()); return ( < div > < h2 > { user . name } </ h2 > < p > Email: { user . email } </ p > </ div > ); } Enter fullscreen mode Exit fullscreen mode In this example: The UserProfile component is fetching user data directly from an API on the server. Since this component is rendered server-side, it fetches the data and returns the HTML directly, without needing client-side JavaScript to fetch or render it. 2. Mixing with Client Components // App.js import UserProfile from ' ./UserProfile.server ' ; import ClientButton from ' ./ClientButton.client ' ; export default function App () { return ( < div > < UserProfile userId = { 1 } /> < ClientButton /> </ div > ); } Enter fullscreen mode Exit fullscreen mode Here, we mix a Server Component ( UserProfile ) with a Client Component ( ClientButton ). The server component fetches data and renders static HTML, while the client component can handle interactivity, such as handling clicks or submitting forms. 3. Client Component Example // ClientButton.client.js import { useState } from ' react ' ; export default function ClientButton () { const [ count , setCount ] = useState ( 0 ); return ( < button onClick = { () => setCount ( count + 1 ) } > Clicked { count } times </ button > ); } Enter fullscreen mode Exit fullscreen mode The ClientButton component is a traditional React component that handles interactivity by using React hooks ( useState ). When to Use React Server Components Now that you understand how React Server Components work, you might be wondering when to use them. Here are some scenarios where RSCs shine: 1. Performance-Critical Applications For applications where performance is a key concern, like e-commerce sites, SaaS platforms, or content-heavy sites, RSCs can improve both load times and responsiveness. 2. Reducing JavaScript Payload If you‚Äôre looking to reduce the amount of JavaScript sent to the client, RSCs allow you to move more of your app‚Äôs logic and rendering to the server, resulting in smaller bundles and faster load times. 3. Secure Data Fetching When you need to fetch sensitive data (like user details or database queries), RSCs are ideal because the data fetching happens server-side, keeping sensitive information secure. Conclusion React Server Components represent a significant leap forward in how we can architect and optimize React applications. By allowing developers to offload rendering to the server while keeping the client-side interactive, they help reduce JavaScript payloads, improve performance, and simplify data fetching. However, RSCs are not a one-size-fits-all solution, and it‚Äôs important to weigh the pros and cons based on your specific app‚Äôs needs. For high-performance applications that require a lot of server-side logic, React Server Components offer a powerful new approach to building modern, efficient web apps. As React Server Components continue to evolve, they‚Äôre set to become a core tool for frontend developers. So, start experimenting with them, and see how they can fit into your development workflow! Top comments (0) Subscribe Personal Trusted User Create template Templates let you quickly answer FAQs or store snippets for re-use. Submit Preview Dismiss Code of Conduct ‚Ä¢ Report abuse Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink . Hide child comments as well Confirm For further actions, you may consider blocking this person and/or reporting abuse Delia Follow Joined Jan 19, 2023 More from Delia Exploring the Newest Features in JavaScript ES2024 # webdev # javascript # programming # beginners Top 10 JavaScript Frameworks to Learn in 2024 # webdev # javascript # beginners # programming The Magic of JavaScript Decorators: Enhancing Classes and Methods # webdev # javascript # programming # tutorial üíé DEV Diamond Sponsors Thank you to our Diamond Sponsors for supporting the DEV Community Google AI is the official AI Model and Platform Partner of DEV Neon is the official database partner of DEV Algolia is the official search partner of DEV DEV Community ‚Äî A space to discuss and keep up software development and manage your software career Home About Contact Code of Conduct Privacy Policy Terms of Use Built on Forem ‚Äî the open source software that powers DEV and other inclusive communities. Made with love and Ruby on Rails . DEV Community ¬© 2016 - 2025. We're a place where coders share, stay up-to-date and grow their careers. Log in Create account

**Confidence**: 0.80

### Finding 5

Finding from Making Sense of React Server Components - Josh W Comeau: Making Sense of React Server Components ‚Ä¢ Josh W. Comeau Josh W Comeau categories courses goodies About Making Sense of React Server Components Filed under React on in September 6th, 2023 . Sep 2023 . Last updated on in May 9th, 2025 . May 2025 . Table of Contents Introduction A quick primer on Server Side Rendering Bouncing back and forth Introduction to React Server Components Compatible Environments Specifying client components Boundaries Workarounds Peeking under the hood Advantages The full picture Introduction So, here's something that makes me feel old: React celebrated its 10th birthday this year! In the decade since React was first introduced to a bewildered dev community, it‚Äôs gone through several evolutions. The React team has not been shy when it comes to radical changes: if they discover a better solution to a problem, they'll run with it. A couple of months ago, the React team unveiled React Server Components, the latest paradigm shift. For the first time ever, React components can run exclusively on the server. There's been so much friggin‚Äô confusion about this online. Lots of folks have lots of questions around what this is, how it works, what the benefits are, and how it fits together with things like Server Side Rendering. I've been doing a lot of experimentation with React Server Components, and I've answered a lot of my own questions. I have to admit, I'm way more excited about this stuff than I expected to be. It's really cool! So, my goal today is to help demystify this stuff for you, to answer a lot of the questions you might have about React Server Components! Intended audience This tutorial is written primarily for developers who are already using React, and who are curious about React Server Components. You don't need to be a React expert, but it will likely be pretty confusing if you're just getting started with React. Link to this heading A quick primer on Server Side Rendering To put React Server Components in context, it's helpful to understand how Server Side Rendering (SSR) works. If you're already familiar with SSR, feel free to skip to the next heading! When I first started using React in 2015, most React setups used a ‚Äúclient-side‚Äù rendering strategy. The user would receive an HTML file that looked like this: Copy to clipboard <! DOCTYPE html > < html > < body > < div id = " root " ></ div > < script src = " /static/js/bundle.js " ></ script > </ body > </ html > That bundle.js script includes everything we need to mount and run the application, including React, other third-party dependencies, and all of the code we've written. Once the JS has been downloaded and parsed, React springs into action, conjuring all of the DOM nodes for our entire application, and housing it in that empty <div id="root"> . The problem with this approach is that it takes time to do all of that work. And while it's all happening, the user is staring at a blank white screen. This problem tends to get worse over time: every new feature we ship adds more kilobytes to our JavaScript bundle, prolonging the amount of time that the user has to sit and wait. * There are optimizations that can help here, like lazy-loading specific modules or splitting based on route, but as a general rule, JS bundles tend to grow and grow. Server Side Rendering was designed to improve this experience. Instead of sending an empty HTML file, the server will render our application to generate the actual HTML. The user receives a fully-formed HTML document. That HTML file will still include the <script> tag, since we still need React to run on the client, to handle any interactivity. But we configure React to work a little bit differently in-browser: instead of conjuring all of the DOM nodes from scratch, it instead adopts the existing HTML. This process is known as hydration. I like the way React core team member Dan Abramov explains this: Hydration is like watering the ‚Äúdry‚Äù HTML with the ‚Äúwater‚Äù of interactivity and event handlers. Once the JS bundle has been downloaded, React will quickly run through our entire application, building up a virtual sketch of the UI, and ‚Äúfitting‚Äù it to the real DOM, attaching event handlers, firing off any effects, and so on. And so, that's SSR in a nutshell. A server generates the initial HTML so that users don't have to stare at an empty white page while the JS bundles are downloaded and parsed. Client-side React then picks up where server-side React left off, adopting the DOM and sprinkling in the interactivity. An umbrella term When we talk about Server Side Rendering, we typically imagine a flow that looks like this: User visits myWebsite.com . A Node.js server receives the request, and immediately renders the React application, generating the HTML. That freshly-baked HTML is sent to the client. This is one possible way to implement Server Side Rendering, but it's not the only one. Another option is to generate the HTML when we build the application. Typically, React applications need to be compiled , transforming JSX into plain ol‚Äô JavaScript, and bundling all of our modules. What if, during that same process, we ‚Äúpre-rendered‚Äù all of the HTML for all of our different routes? This is commonly known as static site generation (SSG) . It's a sub-variant of Server Side Rendering. The way I see it, ‚ÄúServer Side Rendering‚Äù is an umbrella term that includes several different rendering strategies. They all have one thing in common: the initial render happens in a server runtime like Node.js, using the ReactDOMServer APIs. It doesn't actually matter when this happens, whether it's on-demand or at compile-time. Either way, it's Server Side Rendering. Link to this heading Bouncing back and forth Let's talk about data-fetching in React. Typically, we've had two separate applications that communicate over the network: A client-side React app A server-side REST API Using something like React Query or SWR or Apollo, the client would make a network request to the back-end, which would then grab the data from the database and send it back over the network. We can visualize this flow using a graph: 0 10 20 30 Server Client Render Shell Render Content Download JavaScript Database Query This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item. Response from server . Duration: 4 units of time. " Download JavaScript " on client . Duration: 7 units of time. " Render Shell " on client . Duration: 6 units of time. Request to server . Duration: 4 units of time. " Database Query " on server . Duration: 5 units of time. Response from server . Duration: 4 units of time. " Render Content " on client . Duration: 5 units of time. A note about these graphs This blog post includes several of these ‚Äúnetwork request graphs‚Äù. They're designed to visualize how data moves between client (browser) and server (back-end API), across several different rendering strategies. The numbers along the bottom represent an imaginary made-up time unit. They're not minutes or seconds. In reality, the numbers vary wildly, based on a ton of different factors. These graphs are meant to give you a high-level understanding of the concepts, they're not modeling any real data. This first graph shows the flow using a Client Side Rendering (CSR) strategy. It starts with the client receiving an HTML file. This file doesn't have any content, but it does have one or more <script> tags. Once the JS has been downloaded and parsed, our React app will boot up, creating a bunch of DOM nodes and populating the UI. At first, though, we don't have any of the actual data , so we can only render the shell (the header, the footer, the general layout) with a loading state. You've probably seen this sort of pattern a lot. For example, UberEats starts by rendering a shell while it fetches the data it needs to populate the actual restaurants: The user will see this loading state until the network request resolves and React re-renders, replacing the loading UI with the real content. Let's look at another way we could architect this. This next graph keeps the same general data-fetching pattern, but uses Server Side Rendering instead of Client Side Rendering: 0 10 20 30 Server Client Render Shell Render Content Hydrate Download JavaScript Database Query This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item. " Render Shell " on server . Duration: 3 units of time. Response from server . Duration: 4 units of time. " Download JavaScript " on client . Duration: 7 units of time. " Hydrate " on client . Duration: 3 units of time. Request to server . Duration: 4 units of time. " Database Query " on server . Duration: 5 units of time. Response from server . Duration: 4 units of time. " Render Content " on client . Duration: 5 units of time. In this new flow, we perform the first render on the server. This means that the user receives an HTML file that isn't totally empty. This is an improvement ‚Äî a shell is better than a blank white page ‚Äî but ultimately, it doesn't really move the needle in a significant way. The user isn't visiting our app to see a loading screen, they're visiting to see the content (restaurants, hotel listings, search results, messages, whatever). To really get a sense of the differences in user experience, let's add some web performance metrics to our graphs. Toggle between these two flows, and notice what happens to the flags: Client Side Rendering CSR SSR 0 10 20 30 Server Client Page Interactive Content Painted First Paint Render Shell Render Content Download JavaScript Database Query This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item. Response from server . Duration: 4 units of time. " Download JavaScript " on client . Duration: 7 units of time. " Render Shell " on client . Duration: 6 units of time. Request to server . Duration: 4 units of time. " Database Query " on server . Duration: 5 units of time. Response from server . Duration: 4 units of time. " Render Content " on client . Duration: 5 units of time. Each of these flags represents a commonly-used web performance metric. Here's the breakdown: First Paint ‚Äî The user is no longer staring at a blank white screen. The general layout has been rendered, but the content is still missing. This is sometimes called FCP (First Contentful Paint). Page Interactive ‚Äî React has been downloaded, and our application has been rendered/hydrated. Interactive elements are now fully responsive. This is sometimes called TTI (Time To Interactive). Content Paint ‚Äî The page now includes the stuff the user cares about. We've pulled the data from the database and rendered it in the UI. This is sometimes called LCP (Largest Contentful Paint). By doing the initial render on the server, we're able to get that initial ‚Äúshell‚Äù drawn more quickly. This can make the loading experience feel a bit faster, since it provides a sense of progress, that things are happening. And, in some situations, this will be a meaningful improvement. For example, maybe the user is only waiting for the header to load so that they can click a navigation link. But doesn't this flow feel a bit silly? When I look at the SSR graph, I can't help but notice that the request starts on the server. Instead of requiring a second round-trip network request, why don't we do the database work during that initial request? In other words, why not do something like this? 0 10 20 30 Server Client Page Interactive Content Painted First Paint Render App Hydrate Download JavaScript Database Query This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item. " Database Query " on server . Duration: 5 units of time. " Render App " on server . Duration: 6 units of time. Response from server . Duration: 4 units of time. " Download JavaScript " on client . Duration: 7 units of time. " Hydrate " on client . Duration: 3 units of time. Instead of bouncing back and forth between the client and server, we do our database query as part of the initial request, sending the fully-populated UI straight to the user. But hm, how exactly would we do this? In order for this to work, we'd need to be able to give React a chunk of code that it runs exclusively on the server, to do the database query. But that hasn't been an option with React‚Ä¶ even with Server Side Rendering, all of our components render on both the server and the client. The ecosystem has come up with lots of solutions to this problem. Meta-frameworks ? A ‚Äúmeta-framework‚Äù is a framework that builds on top of React, adding additional features like routing or data management. like Next.js and Gatsby have created their own way to run code exclusively on the server. For example, here's what this looked like using Next.js (using the legacy ‚ÄúPages‚Äù router): Copy to clipboard import db from ' imaginary-db ' ; // This code only runs on the server: export async function getServerSideProps () { const link = db . connect ( ' localhost ' , ' root ' , ' passw0rd ' ) ; const data = await db . query ( link , ' SELECT * FROM products ' ) ; return { props : { data }, }; } // This code runs on the server + on the client export default function Homepage ({ data }) { return ( <> < h1 > Trending Products </ h1 > { data . map ( ( item ) => ( < article key = { item . id } > < h2 > { item . title } </ h2 > < p > { item . description } </ p > </ article > )) } </> ) ; } Let's break this down: when the server receives a request, the getServerSideProps function is called. It returns a props object. Those props are then funneled into the component, which is rendered first on the server, and then hydrated on the client. The clever thing here is that getServerSideProps doesn't re-run on the client. In fact, this function isn't even included in our JavaScript bundles! This approach was super ahead of its time. Honestly, it's pretty friggin‚Äô great. But there are some downsides with this: This strategy only works at the route level, for components at the very top of the tree. We can't do this in any component. Each meta-framework came up with its own approach. Next.js has one approach, Gatsby has another, Remix has yet another. It hasn't been standardized. All of our React components will always hydrate on the client, even when there's no need for them to do so. For years, the React team has been quietly tinkering on this problem, trying to come up with an official way to solve this problem. Their solution is called React Server Components. Link to this heading Introduction to React Server Components At a high level, React Server Components is the name for a brand-new paradigm. In this new world, we can create components that run exclusively on the server . This allows us to do things like write database queries right inside our React components! Here's a quick example of a ‚ÄúServer Component‚Äù: Copy to clipboard import db from ' imaginary-db ' ; async function Homepage () { const link = db . connect ( ' localhost ' , ' root ' , ' passw0rd ' ) ; const data = await db . query ( link , ' SELECT * FROM products ' ) ; return ( <> < h1 > Trending Products </ h1 > { data . map ( ( item ) => ( < article key = { item . id } > < h2 > { item . title } </ h2 > < p > { item . description } </ p > </ article > )) } </> ) ; } export default Homepage ; As someone who has been using React for many years, this code looked absolutely wild to me at first. üòÖ ‚ÄúBut wait!‚Äù, my instincts screamed. ‚ÄúFunction components can't be asynchronous! And we're not allowed to have side effects directly in the render like that!‚Äù The key thing to understand is this: Server Components never re-render. They run once on the server to generate the UI. The rendered value is sent to the client and locked in place. As far as React is concerned, this output is immutable, and will never change. * At least, not until something happens at the router level, like navigating to a new page. This means that a big chunk of React's API is incompatible with Server Components. For example, we can't use state, because state can change, but Server Components can't re-render. And we can't use effects because effects only run after the render, on the client, and Server Components never make it to the client. It also means that we have a bit more flexibility when it comes to the rules. For example, in traditional React, we need to put side effects inside a useEffect callback or an event handler or something, so that they don't repeat on every render. But if the component only runs once , we don't have to worry about that! Server Components themselves are surprisingly straightforward, but the ‚ÄúReact Server Components‚Äù paradigm is significantly more complex. This is because we still have regular ol‚Äô components, and the way they fit together can be pretty confusing. In this new paradigm, the ‚Äútraditional‚Äù React components we're familiar with are called Client Components . I'll be honest, I don't love this name. üòÖ The name ‚ÄúClient Component‚Äù implies that these components only render on the client, but that's not actually true. Client Components render on both the client and the server. I know that all this terminology is pretty confusing, so here's how I'd summarize it: React Server Components is the name for this new paradigm. In this new paradigm, the ‚Äústandard‚Äù React components we know and love have been rebranded as Client Components . It's a new name for an old thing. This new paradigm introduces a new type of component, Server Components . These new components render exclusively on the server. Their code isn't included in the JS bundle, and so they never hydrate or re-render. React Server Components vs. Server Side Rendering Let's clear up another common bit of confusion: React Server Components is not a replacement for Server Side Rendering. You shouldn't think of React Server Components as ‚ÄúSSR version 2.0‚Äù. Instead, I like to think of it as two separate puzzle pieces that snap together perfectly, two flavors that complement each other. We still rely on Server Side Rendering to generate the initial HTML. React Server Components builds on top of that, allowing us to omit certain components from the client-side JavaScript bundle, ensuring they only run on the server. In fact, it's even possible to use React Server Components without Server Side Rendering, though in practice, you'll get better results if you use them together. The React team has built a minimal RSC demo (opens in new tab) without SSR, if you'd like to see an example. Link to this heading Compatible Environments So, typically, when a new React feature comes out, we can start using it in our existing projects by bumping our React dependency to the latest version. A quick npm install react@latest and we're off to the races. Unfortunately, React Server Components doesn't work like that. My understanding is that React Server Components needs to be tightly integrated with a bunch of stuff outside of React, things like the bundler, the server, and the router. As I write this, there's only one way to start using React Server Components, and that's with Next.js 13.4+, using their brand-new re-architected ‚ÄúApp Router‚Äù. Hopefully in the future, more React-based frameworks will start to incorporate React Server Components. It feels awkward that a core React feature is only available in one particular tool! The React docs has a ‚ÄúBleeding-edge frameworks‚Äù section (opens in new tab) where they list the frameworks that support React Server Components; I plan on checking this page from time to time, to see if any new options become available. Link to this heading Specifying client components In this new ‚ÄúReact Server Components‚Äù paradigm, all components are assumed to be Server Components by default. We have to ‚Äúopt in‚Äù for Client Components. We do this by specifying a brand-new directive : Copy to clipboard ' use client ' ; import React from ' react ' ; function Counter () { const [ count , setCount ] = React . useState ( 0 ) ; return ( < button onClick = { () => setCount ( count + 1 ) } > Current value: { count } </ button > ) ; } export default Counter ; That standalone string at the top, 'use client' , is how we signal to React that the component(s) in this file are Client Components, that they should be included in our JS bundles so that they can re-render on the client. This might seem like an incredibly odd way to specify the type of component we're creating, but there is a precedent for this sort of thing: the "use strict" (opens in new tab) directive that opts into ‚ÄúStrict Mode‚Äù in JavaScript. We don't specify the 'use server' directive in our Server Components; in the React Server Components paradigm, components are treated as Server Components by default. In fact, 'use server' is used for Server Actions, a totally different feature that is beyond the scope of this blog post. Which components should be Client Components? You might be wondering: how should I decide whether a given component should be a Server Component or a Client Component? As a general rule, if a component can be a Server Component, it should be a Server Component. Server Components tend to be simpler and easier to reason about. There's also a performance benefit: because Server Components don't run on the client, their code isn't included in our JavaScript bundles. One of the benefits of the React Server Components paradigm is that it has the potential to improve the Page Interactive (TTI) metric. That said, we also shouldn't make it our mission to eradicate as many Client Components as possible! We shouldn't try to optimize for the smallest # of Client Components. It's worth remembering that until now, every React component in every React app has been a Client Component. As you start working with React Server Components, you'll likely discover that this is pretty intuitive. Some of our components will need to run on the client, because they use state variables or effects. You can slap a 'use client' directive on those components. Otherwise, you can leave them as Server Components. Link to this heading Boundaries One of the first questions I had when I was getting familiar with React Server Components was this: what happens when the props change? For example, suppose we had a Server Component like this: Copy to clipboard function HitCounter ({ hits }) { return ( < div > Number of hits: { hits } </ div > ) ; } Let's suppose that in the initial Server Side Render, hits was equal to 0 . This component, then, will produce the following markup: Copy to clipboard < div > Number of hits: 0 </ div > But what happens if the value of hits changes? Suppose it's a state variable, and it changes from 0 to 1 . HitCounter would need to re-render, but it can't re-render, because it's a Server Component! The thing is, Server Components don't really make sense in isolation. We have to zoom out, to take a more holistic view, to consider the structure of our application. Let's say we have the following component tree: If all of these components are Server Components, then it all makes sense. None of the props will ever change, because none of the components will ever re-render. But let's suppose that Article component owns the hits state variable. In order to use state, we need to convert it to a Client Component: Do you see the issue here? When Article re-renders, any owned components will also re-render, including HitCounter and Discussion . If these are Server Components, though, they can't re-render. In order to prevent this impossible situation, the React team added a rule: Client Components can only import other Client Components. That 'use client' directive means that these instances of HitCounter and Discussion will need to become Client Components. One of the biggest ‚Äúah-ha‚Äù moments I had with React Server Components was the realization that this new paradigm is all about creating client boundaries . Here's what winds up happening, in practice: When we add the 'use client' directive to the Article component, we create a ‚Äúclient boundary‚Äù. All of the components within this boundary are implicitly converted to Client Components. Even though components like HitCounter don't have the 'use client' directive, they'll still hydrate/render on the client in this particular situation. * The HitCounter component itself might still be rendered as a Server Component in other situations, if it's imported somewhere else by a Server Component. This means we don't have to add 'use client' to every single file that needs to run on the client. In practice, we only need to add it when we're creating new client boundaries. Link to this heading Workarounds When I first learned that Client Components can't render Server Components, it felt pretty restrictive to me. What if I need to use state high up in the application? Does that mean everything needs to become a Client Component?? It turns out that in many cases, we can work around this limitation by restructuring our application so that the owner changes. This is a tricky thing to explain, so let's use an example: Copy to clipboard ' use client ' ; import { DARK_COLORS , LIGHT_COLORS } from ' @/constants.js ' ; import Header from ' ./Header ' ; import MainContent from ' ./MainContent ' ; function Homepage () { const [ colorTheme , setColorTheme ] = React . useState ( ' light ' ) ; const colorVariables = colorTheme === ' light ' ? LIGHT_COLORS : DARK_COLORS ; return ( < body style = { colorVariables } > < Header /> < MainContent /> </ body > ) ; } In this setup, we need to use React state to allow users to flip between dark mode / light mode. This needs to happen high up in the application tree, so that we can apply our CSS variable tokens to the <body> tag. In order to use state, we need to make Homepage a Client Component. And since this is the top of our application, it means that all of the other components ‚Äî Header and MainContent ‚Äî will implicitly become Client Components too. To fix this, let's pluck the color-management stuff into its own component, moved to its own file: Copy to clipboard // /components/ColorProvider.js ' use client ' ; import { DARK_COLORS , LIGHT_COLORS } from ' @/constants.js ' ; function ColorProvider ({ children }) { const [ colorTheme , setColorTheme ] = React . useState ( ' light ' ) ; const colorVariables = colorTheme === ' light ' ? LIGHT_COLORS : DARK_COLORS ; return ( < body style = { colorVariables } > { children } </ body > ) ; } Back in Homepage , we use this new component like so: Copy to clipboard // /components/Homepage.js import Header from ' ./Header ' ; import MainContent from ' ./MainContent ' ; import ColorProvider from ' ./ColorProvider ' ; function Homepage () { return ( < ColorProvider > < Header /> < MainContent /> </ ColorProvider > ) ; } We can remove the 'use client' directive from Homepage because it no longer uses state, or any other client-side React features. This means that Header and MainContent won't be implicitly converted to Client Components anymore! But wait a second. ColorProvider , a Client Component, is a parent to Header and MainContent . Either way, it's still higher in the tree, right? When it comes to client boundaries, though, the parent/child relationship doesn't matter. Homepage is the one importing and rendering Header and MainContent . This means that Homepage decides what the props are for these components. Remember, the problem we're trying to solve is that Server Components can't re-render, and so they can't be given new values for any of their props. With this new setup, Homepage decides what the props are for Header and MainContent , and since Homepage is a Server Component, there's no problem. This is brain-bending stuff. Even after years of React experience, I still find this very confusing üòÖ. It took a fair bit of practice to develop an intuition for this. To be more precise, the 'use client' directive works at the file / module level. Any modules imported in a Client Component file must be Client Components as well. When the bundler bundles up our code, it'll follow these imports, after all! Changing the color theme? In my example above, you might have noticed that there's no way to change the color theme. setColorTheme is never called. I wanted to keep things as minimal as possible, and so I left some stuff out. A full example would use React context to make the setter function available to any descendants. As long as the component that consumes the context is a Client Component, everything works great! Link to this heading Peeking under the hood Let's look at this at a bit of a lower level. When we use a Server Component, what does the output look like? What actually gets generated? Let's start with a super-simple React application: Copy to clipboard function Homepage () { return ( < p > Hello world! </ p > ) ; } In the React Server Components paradigm, all components are Server Components by default. Since we haven't explicitly marked this component as a Client Component (or rendered it within a client boundary), it'll only render on the server. When we visit this app in the browser, we'll receive an HTML document which looks something like this: Copy to clipboard <! DOCTYPE html > < html > < body > < p > Hello world! </ p > < script src = " /static/js/bundle.js " ></ script > < script > self . __next [ ' $Homepage-1 ' ] = { type : ' p ' , props : null , children : " Hello world! " , }; </ script > </ body > </ html > Some liberties taken To make it easier to understand, I've taken the liberty of restructuring things here. For example, the true JS generated in an RSC context uses stringified JSON arrays, as an optimization to reduce the file size of this HTML document. I've also stripped out all non-critical parts of the HTML (like the <head> ). We see that our HTML document includes the UI generated by our React application, the ‚ÄúHello world!‚Äù paragraph. This is thanks to Server Side Rendering, and isn't directly attributable to React Server Components. Below that, we have a <script> tag that loads up our JS bundle. This bundle includes the dependencies like React, as well as any Client Components used in our application. And since our Homepage component is a Server Component, the code for that component is not included in this bundle. Finally, we have a second <script> tag with some inline JS: Copy to clipboard self . __next [ ' $Homepage-1 ' ] = { type : ' p ' , props : null , children : " Hello world! " , }; This is the really interesting bit. Essentially, what we're doing here is telling React ‚ÄúHey, so I know you're missing the Homepage component code, but don't worry: here's what it rendered‚Äù. Typically, when React hydrates on the client, it speed-renders all of the components, building up a virtual representation of the application. It can't do that for Server Components, because the code isn't included in the JS bundle. And so, we send along the rendered value, the virtual representation that was generated by the server. When React loads on the client, it re-uses that description instead of re-generating it. This is what allows that ColorProvider example above to work. The output from Header and MainContent is passed into the ColorProvider component through the children prop. ColorProvider can re-render as much as it wants, but this data is static, locked in by the server. This does mean that while our JS bundles get smaller, the HTML file gets larger. Instead of having the component definition in a JS file, we have the component's returned value inlined in a <script> tag. On average, we'll still send less total data over the network, but it's worth remembering that Server Components aren't totally free. I should also note that the HTML file is broken into chunks and streamed, so the browser can still paint the UI quickly, without having to wait for all the cruft in the <script> tag. If you're curious to see true representations of how Server Components are serialized and sent over the network, check out the RSC Devtools (opens in new tab) by developer Alvar Lagerl√∂f. Server Components don't require a server Earlier in this post, I mentioned that Server Side Rendering is an ‚Äúumbrella term‚Äù for lots of different rendering strategies, including: Static: the HTML is generated when the application is built, during the deploy process. Dynamic: the HTML is generated ‚Äúon-demand‚Äù, when the page is requested by the user. React Server Components is compatible with either of these rendering strategies. When our Server Components are rendered in the Node.js runtime, the JavaScript objects they return will be created. That can happen either on-demand or during the build. This means that it's possible to use React Server Components without a server! We can generate a bunch of static HTML files and host them wherever we want. In fact, this is what happens by default in the Next.js App Router. Unless we really need things to happen ‚Äúon-demand‚Äù, all of this work happens ahead of time, during the build. No React at all? You might be wondering: if we don't include any Client Components in our application, do we actually need to download React at all? Can we use React Server Components to build a truly static no-JS website? The thing is, React Server Components is available exclusively within the Next.js framework, and that framework has a bunch of code that needs to run on the client, to manage things like routing. Counter-intuitively, though, this actually tends to produce a better user experience; Next's router, for example, will process link clicks faster than a typical <a> tag, since it doesn't have to load a whole new HTML document. A well-structured Next.js application will still work while the JS is downloading, but it'll be even faster/better once the JS loads. Link to this heading Advantages React Server Components is the first ‚Äúofficial‚Äù way to run server-exclusive code in React. As I mentioned earlier, though, this isn't really a new thing in the broader React ecosystem; we've been able to run server-exclusive code in Next.js since 2016! The big difference is that we've never before had a way to run server-exclusive code inside our components. The most obvious benefit is performance. Server Components don't get included in our JS bundles, which reduces the amount of JavaScript that needs to be downloaded, and the number of components that need to be hydrated: Legacy Next.js (pre-RSC) Before After 0 10 20 30 Server Client Page Interactive Content Painted First Paint Render App Hydrate Download JavaScript Database Query This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item. " Database Query " on server . Duration: 5 units of time. " Render App " on server . Duration: 6 units of time. Response from server . Duration: 4 units of time. " Download JavaScript " on client . Duration: 7 units of time. " Hydrate " on client . Duration: 3 units of time. This is maybe the least exciting thing to me, though. Honestly, most Next.js apps are already fast enough when it comes to ‚ÄúPage Interactive‚Äù timing. If you follow semantic HTML principles, most of your app should work even before React has hydrated. Links can be followed, forms can be submitted, accordions can be expanded and collapsed (using <details> and <summary> ). For most projects, it's fine if it takes a few seconds for React to hydrate. But here's something I find really cool: we no longer have to make the same compromises, in terms of features vs. bundle size! For example, most technical blogs require some sort of syntax highlighting library. On this blog, I use Prism. The code snippets look like this: Copy to clipboard function exampleJavaScriptFunction ( param ) { return " Hello world! " } A proper syntax-highlighting library, with support for all popular programming languages, would be several megabytes, far too large to stick in a JS bundle. As a result, we have to make compromises, trimming out languages and features that aren't mission-critical. But, suppose we do the syntax highlighting in a Server Component. In that case, none of the library code would actually be included in our JS bundles. As a result, we wouldn't have to make any compromises, we could use all of the bells and whistles. This is the big idea behind Bright (opens in new tab) , a modern syntax-highlighting package designed to work with React Server Components. This is the sort of thing that gets me excited about React Server Components. Things that would be too cost-prohibitive to include in a JS bundle can now run on the server for free, adding zero kilobytes to our bundles, and producing an even better user experience. It's not just about performance and UX either. After working with RSC for a while, I've come to really appreciate how easy-breezy Server Components are. We never have to worry about dependency arrays, stale closures, memoization, or any of the other complex stuff caused by things changing. Ultimately, it's still very early days. React Server Components only emerged from beta a couple of months ago! I'm really excited to see how things evolve over the next couple of years, as the community continues to innovate new solutions like Bright, taking advantage of this new paradigm. It's an exciting time to be a React developer! Link to this heading The full picture React Server Components is an exciting development, but it's actually only one part of the ‚ÄúModern React‚Äù puzzle. Things get really interesting when we combine React Server Components with Suspense and the new Streaming SSR architecture. It allows us to do wild stuff like this: 0 10 20 30 Server Client Page Interactive Content Painted First Paint Render Shell Hydrate Render Content Hydrate Download JS Database Query This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item. " Render Shell " on server . Duration: 3 units of time. Response from server . Duration: 3 units of time. " Database Query " on server . Duration: 8 units of time. " Render Content " on server . Duration: 3 units of time. Response from server . Duration: 4 units of time. " Download JS " on client . Duration: 5 units of time. " Hydrate " on client . Duration: 2 units of time. " Hydrate " on client . Duration: 2 units of time. It's beyond the scope of this tutorial, but you can learn more about this architecture on Github (opens in new tab) . It's also something we explore in depth in my brand-new course, The Joy of React (opens in new tab) . I'd love to tell you a little bit more about it, if that's alright! ‚ù§Ô∏è The Joy of React is a beginner-friendly interactive course, designed to help you build an intuition for how React works. We start at the very beginning (no prior React experience required), and work our way through some of the most notoriously-tricky aspects of React. This course has been my full-time focus for almost two years now, and it includes all of the most important stuff I've learned about React in over 10 years of experience. There's so much good stuff I'd love to tell you about. In addition to React itself, and all the bleeding-edge stuff we've alluded to in this blog post, you'll learn about my favourite parts of the React ecosystem. For example, you'll learn how to do next-level layout animations like this, using Framer Motion: You can learn more about the course here: The Joy of React (opens in new tab) React Server Components is a significant paradigm shift. Personally, I'm super keen to see how things develop over the next couple of years, as the ecosystem builds more tools like Bright that takes advantage of Server Components. I have the feeling that building in React is about to get even cooler. üòÑ Last updated on May 9th, 2025 # of hits Josh W Comeau Are you a human? If so, please ignore this checkbox Want to know when I publish new content? Enter your email to join my free newsletter: Email Submit Browse By Category CSS React Animation JavaScript Career SVG Next.js General Interactive Courses CSS for JavaScript Devs (opens in new tab) The Joy of React (opens in new tab) General About Josh About This Blog Contact Search Disable sounds Activate dark mode RSS Feed Josh's BlueSky profile Josh's Github profile Josh's LinkedIn profile ¬© 2018-present Joshua Comeau. All Rights Reserved. Terms of Use (opens in new tab) Privacy Policy (opens in new tab) Code of Conduct (opens in new tab)

**Confidence**: 0.80

## Sources

1. [Server Components - React](https://react.dev/reference/rsc/server-components) - Relevance: 0.80
   > Server Components React Server Components Server Components are for use in React Server Components . Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server . This separate environment is the " server " in React Server Components .

2. [Server Components and Server Actions in React 19: A Revolution in React ...](https://medium.com/@erickzanetti/server-components-and-server-actions-in-react-19-a-revolution-in-react-architecture-85c75b3531c6) - Relevance: 0.80
   > Discover Server Components and Server Actions in React 19: boosting performance, security, and simplicity for modern, scalable apps.

3. [React Server Components](https://reactrouter.com/how-to/react-server-components) - Relevance: 0.80
   > React Server Components Framework Data Declarative React Server Components support is experimental and subject to breaking changes. React Server Components (RSC) refers generally to an architecture and set of APIs provided by React since version 19. From the docs: Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your ...

4. [A Deep Dive into React Server Components: What Frontend Developers Need ...](https://dev.to/delia_code/a-deep-dive-into-react-server-components-what-frontend-developers-need-to-know-c6j) - Relevance: 0.80
   > React Server Components (RSCs) are an exciting new feature in React that is revolutionising how developers build web applications. Introduced as part of React's plan to bridge the gap between server and client-side rendering, RSCs promise improved performance, cleaner architecture , and a more efficient developer experience. In this article, we'll take a deep dive into React Server Components ...

5. [Making Sense of React Server Components - Josh W Comeau](https://www.joshwcomeau.com/react/server-components/) - Relevance: 0.80
   > This year, the React team unveiled something they've been quietly researching for years: an official way to run React components exclusively on the server . This is a significant paradigm shift, and it's caused a whole lot of confusion in the React community. In this tutorial, we'll explore this new world, and build an intuition for how it works, and how we can take advantage of it.

