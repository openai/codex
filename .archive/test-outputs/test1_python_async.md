# Python async programming

## Summary

Research Summary for "Python async programming" (comprehensive strategy):

Found 3 relevant findings.

Key findings:
- Finding from Getting Started With Async Features in Python: Getting Started With Async Features in Python ‚Äì Real Python Start Here Learn Python Python Tutorials ‚Üí In-depth articles and video courses Learning Paths ‚Üí Guided study plans for accelerated learning Quizzes & Exercises ‚Üí Check your learning progress Browse Topics ‚Üí Focus on a specific area or skill level Community Chat ‚Üí Learn with other Pythonistas Office Hours ‚Üí Live Q&A calls with Python experts Podcast ‚Üí Hear what‚Äôs new in the world of Python Books ‚Üí Round out your knowledge and learn offline Reference ‚Üí Concise definitions for common Python terms Code Mentor ‚Üí Beta Personalized code assistance & learning tools Unlock All Content ‚Üí More Learner Stories Python Newsletter Python Job Board Meet the Team Become a Tutorial Writer Become a Video Instructor Search / Join Sign‚ÄëIn ‚Äî FREE Email Series ‚Äî üêç Python Tricks üíå Get Python Tricks ¬ª üîí No spam. Unsubscribe any time. Browse Topics Guided Learning Paths Basics Intermediate Advanced ai api best-practices career community databases data-science data-structures data-viz devops django docker editors flask front-end gamedev gui machine-learning news numpy projects python testing tools web-dev web-scraping Table of Contents Understanding Asynchronous Programming Building a Synchronous Web Server Thinking Differently About Programming Programming Parents: Not as Easy as It Looks! Thought Experiment #1: The Synchronous Parent Thought Experiment #2: The Polling Parent Thought Experiment #3: The Threading Parent Using Python Async Features in Practice Synchronous Programming Simple Cooperative Concurrency Cooperative Concurrency With Blocking Calls Cooperative Concurrency With Non-Blocking Calls Synchronous (Blocking) HTTP Calls Asynchronous (Non-Blocking) HTTP Calls Conclusion Mark as Completed Share Getting Started With Async Features in Python by Doug Farrell Reading time estimate 37m intermediate python Mark as Completed Share Table of Contents Understanding Asynchronous Programming Building a Synchronous Web Server Thinking Differently About Programming Programming Parents: Not as Easy as It Looks! Thought Experiment #1: The Synchronous Parent Thought Experiment #2: The Polling Parent Thought Experiment #3: The Threading Parent Using Python Async Features in Practice Synchronous Programming Simple Cooperative Concurrency Cooperative Concurrency With Blocking Calls Cooperative Concurrency With Non-Blocking Calls Synchronous (Blocking) HTTP Calls Asynchronous (Non-Blocking) HTTP Calls Conclusion Remove ads Have you heard of asynchronous programming in Python? Are you curious to know more about Python async features and how you can use them in your work? Perhaps you‚Äôve even tried to write threaded programs and run into some issues. If you‚Äôre looking to understand how to use Python async features, then you‚Äôve come to the right place. In this article, you‚Äôll learn: What a synchronous program is What an asynchronous program is Why you might want to write an asynchronous program How to use Python async features All of the example code in this article have been tested with Python 3.7.2. You can grab a copy to follow along by clicking the link below: Download Code: Click here to download the code you‚Äôll use to learn about async features in Python in this tutorial. Take the Quiz: Test your knowledge with our interactive ‚ÄúGetting Started With Async Features in Python‚Äù quiz. You‚Äôll receive a score upon completion to help you track your learning progress: Interactive Quiz Getting Started With Async Features in Python In this quiz, you'll test your understanding of asynchronous programming in Python. You'll revisit the concepts of synchronous and asynchronous programs, and why you might want to write an asynchronous program. You'll also test your knowledge on how to use Python async features. Understanding Asynchronous Programming A synchronous program is executed one step at a time. Even with conditional branching, loops and function calls, you can still think about the code in terms of taking one execution step at a time. When each step is complete, the program moves on to the next one. Here are two examples of programs that work this way: Batch processing programs are often created as synchronous programs. You get some input, process it, and create some output. Steps follow one after the other until the program reaches the desired output. The program only needs to pay attention to the steps and their order. Command-line programs are small, quick processes that run in a terminal. These scripts are used to create something, transform one thing into something else, generate a report, or perhaps list out some data. This can be expressed as a series of program steps that are executed sequentially until the program is done. An asynchronous program behaves differently. It still takes one execution step at a time. The difference is that the system may not wait for an execution step to be completed before moving on to the next one. This means that the program will move on to future execution steps even though a previous step hasn‚Äôt yet finished and is still running elsewhere. This also means that the program knows what to do when a previous step does finish running. Why would you want to write a program in this manner? The rest of this article will help you answer that question and give you the tools you need to elegantly solve interesting asynchronous problems. Remove ads Building a Synchronous Web Server A web server‚Äôs basic unit of work is, more or less, the same as batch processing. The server will get some input, process it, and create the output. Written as a synchronous program, this would create a working web server. It would also be an absolutely terrible web server. Why? In this case, one unit of work (input, process, output) is not the only purpose. The real purpose is to handle hundreds or even thousands of units of work as quickly as possible. This can happen over long periods of time, and several work units may even arrive all at once. Can a synchronous web server be made better? Sure, you could optimize the execution steps so that all the work coming in is handled as quickly as possible. Unfortunately, there are limitations to this approach. The result could be a web server that doesn‚Äôt respond fast enough, can‚Äôt handle enough work, or even one that times out when work gets stacked up. Note: There are other limitations you might see if you tried to optimize the above approach. These include network speed, file IO speed, database query speed, and the speed of other connected services, to name a few. What these all have in common is that they are all IO functions. All of these items are orders of magnitude slower than the CPU‚Äôs processing speed. In a synchronous program, if an execution step starts a database query, then the CPU is essentially idle until the database query is returned. For batch-oriented programs, this isn‚Äôt a priority most of the time. Processing the results of that IO operation is the goal. Often, this can take longer than the IO operation itself. Any optimization efforts would be focused on the processing work, not the IO. Asynchronous programming techniques allow your programs to take advantage of relatively slow IO processes by freeing the CPU to do other work. Thinking Differently About Programming When you start trying to understand asynchronous programming, you might see a lot of discussion about the importance of blocking, or writing non-blocking code . (Personally, I struggled to get a good grasp of these concepts from the people I asked and the documentation I read.) What is non-blocking code? What‚Äôs blocking code, for that matter? Would the answers to these questions help you write a better web server? If so, how could you do it? Let‚Äôs find out! Writing asynchronous programs requires that you think differently about programming. While this new way of thinking can be hard to wrap your head around, it‚Äôs also an interesting exercise. That‚Äôs because the real world is almost entirely asynchronous, and so is how you interact with it. Imagine this: you‚Äôre a parent trying to do several things at once. You have to balance the checkbook, do the laundry, and keep an eye on the kids. Somehow, you‚Äôre able to do all of these things at the same time without even thinking about it! Let‚Äôs break it down: Balancing the checkbook is a synchronous task. One step follows another until it‚Äôs done. You‚Äôre doing all the work yourself. However, you can break away from the checkbook to do laundry. You unload the dryer, move clothes from the washer to the dryer, and start another load in the washer. Working with the washer and dryer is a synchronous task, but the bulk of the work happens after the washer and dryer are started. Once you‚Äôve got them going, you can walk away and get back to the checkbook task. At this point, the washer and dryer tasks have become asynchronous . The washer and dryer will run independently until the buzzer goes off (notifying you that the task needs attention). Watching your kids is another asynchronous task. Once they are set up and playing, they can do so independently for the most part. This changes when someone needs attention, like when someone gets hungry or hurt. When one of your kids yells in alarm, you react. The kids are a long-running task with high priority. Watching them supersedes any other tasks you might be doing, like the checkbook or laundry. These examples can help to illustrate the concepts of blocking and non-blocking code. Let‚Äôs think about this in programming terms. In this example, you‚Äôre like the CPU. While you‚Äôre moving the laundry around, you (the CPU) are busy and blocked from doing other work, like balancing the checkbook. But that‚Äôs okay because the task is relatively quick. On the other hand, starting the washer and dryer does not block you from performing other tasks. It‚Äôs an asynchronous function because you don‚Äôt have to wait for it to finish. Once it‚Äôs started, you can go back to something else. This is called a context switch: the context of what you‚Äôre doing has changed, and the machine‚Äôs buzzer will notify you sometime in the future when the laundry task is complete. As a human, this is how you work all the time. You naturally juggle multiple things at once, often without thinking about it. As a developer, the trick is how to translate this kind of behavior into code that does the same kind of thing. Programming Parents: Not as Easy as It Looks! If you recognize yourself (or your parents) in the example above, then that‚Äôs great! You‚Äôve got a leg up in understanding asynchronous programming. Again, you‚Äôre able to switch contexts between competing tasks fairly easily, picking up some tasks and resuming others. Now you‚Äôre going to try and program this behavior into virtual parents! Thought Experiment #1: The Synchronous Parent How would you create a parent program to do the above tasks in a completely synchronous manner? Since watching the kids is a high-priority task, perhaps your program would do just that. The parent watches over the kids while waiting for something to happen that might need their attention. However, nothing else (like the checkbook or laundry) would get done in this scenario. Now, you can re-prioritize the tasks any way you want, but only one of them would happen at any given time. This is the result of a synchronous, step-by-step approach. Like the synchronous web server described above, this would work, but it might not be the best way to live. The parent wouldn‚Äôt be able to complete any other tasks until the kids fell asleep. All other tasks would happen afterward, well into the night. (A couple of weeks of this and many real parents might jump out the window!) Remove ads Thought Experiment #2: The Polling Parent If you used polling , then you could change things up so that multiple tasks are completed. In this approach, the parent would periodically break away from the current task and check to see if any other tasks need attention. Let‚Äôs make the polling interval something like fifteen minutes. Now, every fifteen minutes your parent checks to see if the washer, dryer or kids need any attention. If not, then the parent can go back to work on the checkbook. However, if any of those tasks do need attention, then the parent will take care of it before going back to the checkbook. This cycle continues on until the next timeout out of the polling loop. This approach works as well since multiple tasks are getting attention. However, there are a couple of problems: The parent may spend a lot of time checking on things that don‚Äôt need attention: The washer and dryer haven‚Äôt yet finished, and the kids don‚Äôt need any attention unless something unexpected happens. The parent may miss completed tasks that do need attention: For instance, if the washer finished its cycle at the beginning of the polling interval, then it wouldn‚Äôt get any attention for up to fifteen minutes! What‚Äôs more, watching the kids is supposedly the highest priority task. They couldn‚Äôt tolerate fifteen minutes with no attention when something might be going drastically wrong. You could address these issues by shortening the polling interval, but now your parent (the CPU) would be spending more time context switching between tasks. This is when you start to hit a point of diminishing returns. (Once again, a couple of weeks living like this and, well‚Ä¶ See the previous comment about windows and jumping.) Thought Experiment #3: The Threading Parent ‚ÄúIf I could only clone myself‚Ä¶‚Äù If you‚Äôre a parent, then you‚Äôve probably had similar thoughts! Since you‚Äôre programming virtual parents, you can essentially do this by using threading. This is a mechanism that allows multiple sections of one program to run at the same time. Each section of code that runs independently is known as a thread, and all threads share the same memory space. If you think of each task as a part of one program, then you can separate them and run them as threads. In other words, you can ‚Äúclone‚Äù the parent, creating one instance for each task: watching the kids, monitoring the washer, monitoring the dryer, and balancing the checkbook. All of these ‚Äúclones‚Äù are running independently. This sounds like a pretty nice solution, but there are some issues here as well. One is that you‚Äôll have to explicitly tell each parent instance what to do in your program. This can lead to some problems since all instances share everything in the program space. For example, say that Parent A is monitoring the dryer. Parent A sees that the clothes are dry, so they take control of the dryer and begin unloading the clothes. At the same time, Parent B sees that the washer is done, so they take control of the washer and begin removing clothes. However, Parent B also needs to take control of the dryer so they can put the wet clothes inside. This can‚Äôt happen, because Parent A currently has control of the dryer. After a short while, Parent A has finished unloading clothes. Now they want to take control of the washer and start moving clothes into the empty dryer. This can‚Äôt happen, either, because Parent B currently has control of the washer! These two parents are now deadlocked . Both have control of their own resource and want control of the other resource. They‚Äôll wait forever for the other parent instance to release control. As the programmer, you‚Äôd have to write code to work this situation out. Note: Threaded programs allow you to create multiple, parallel paths of execution that all share the same memory space. This is both an advantage and a disadvantage. Any memory shared between threads is subject to one or more threads trying to use the same shared memory at the same time. This can lead to data corruption, data read in an invalid state, and data that‚Äôs just messy in general. In threaded programming, the context switch happens under system control, not the programmer. The system controls when to switch contexts and when to give threads access to shared data, thereby changing the context of how the memory is being used. All of these kinds of problems are manageable in threaded code, but it‚Äôs difficult to get right, and hard to debug when it‚Äôs wrong. Here‚Äôs another issue that might arise from threading. Suppose that a child gets hurt and needs to be taken to urgent care. Parent C has been assigned the task of watching over the kids, so they take the child right away. At the urgent care, Parent C needs to write a fairly large check to cover the cost of seeing the doctor. Meanwhile, Parent D is at home working on the checkbook. They‚Äôre unaware of this large check being written, so they‚Äôre very surprised when the family checking account is suddenly overdrawn! Remember, these two parent instances are working within the same program. The family checking account is a shared resource, so you‚Äôd have to work out a way for the child-watching parent to inform the checkbook-balancing parent. Otherwise, you‚Äôd need to provide some kind of locking mechanism so that the checkbook resource can only be used by one parent at a time, with updates. Using Python Async Features in Practice Now you‚Äôre going to take some of the approaches outlined in the thought experiments above and turn them into functioning Python programs. All of the examples in this article have been tested with Python 3.7.2. The requirements.txt file indicates which modules you‚Äôll need to install to run all the examples. If you haven‚Äôt yet downloaded the file, you can do so now: Download Code: Click here to download the code you‚Äôll use to learn about async features in Python in this tutorial. You also might want to set up a Python virtual environment to run the code so you don‚Äôt interfere with your system Python. Remove ads Synchronous Programming This first example shows a somewhat contrived way of having a task retrieve work from a queue and process that work. A queue in Python is a nice FIFO (first in first out) data structure. It provides methods to put things in a queue and take them out again in the order they were inserted. In this case, the work is to get a number from the queue and have a loop count up to that number. It prints to the console when the loop begins, and again to output the total. This program demonstrates one way for multiple synchronous tasks to process the work in a queue. The program named example_1.py in the repository is listed in full below: Python 1 import queue 2 3 def task ( name , work_queue ): 4 if work_queue . empty (): 5 print ( f "Task { name } nothing to do" ) 6 else : 7 while not work_queue . empty (): 8 count = work_queue . get () 9 total = 0 10 print ( f "Task { name } running" ) 11 for x in range ( count ): 12 total += 1 13 print ( f "Task { name } total: { total } " ) 14 15 def main (): 16 """ 17 This is the main entry point for the program 18 """ 19 # Create the queue of work 20 work_queue = queue . Queue () 21 22 # Put some work in the queue 23 for work in [ 15 , 10 , 5 , 2 ]: 24 work_queue . put ( work ) 25 26 # Create some synchronous tasks 27 tasks = [( task , "One" , work_queue ), ( task , "Two" , work_queue )] 28 29 # Run the tasks 30 for t , n , q in tasks : 31 t ( n , q ) 32 33 if __name__ == "__main__" : 34 main () Let‚Äôs take a look at what each line does: Line 1 imports the queue module. This is where the program stores work to be done by the tasks. Lines 3 to 13 define task() . This function pulls work out of work_queue and processes the work until there isn‚Äôt any more to do. Line 15 defines main() to run the program tasks. Line 20 creates the work_queue . All tasks use this shared resource to retrieve work. Lines 23 to 24 put work in work_queue . In this case, it‚Äôs just a random count of values for the tasks to process. Line 27 creates a list of task tuples, with the parameter values those tasks will be passed. Lines 30 to 31 iterate over the list of task tuples, calling each one and passing the previously defined parameter values. Line 34 calls main() to run the program. The task in this program is just a function accepting a string and a queue as parameters. When executed, it looks for anything in the queue to process. If there is work to do, then it pulls values off the queue, starts a for loop to count up to that value, and outputs the total at the end. It continues getting work off the queue until there is nothing left and it exits. When this program is run, it produces the output you see below: Shell Task One running Task One total: 15 Task One running Task One total: 10 Task One running Task One total: 5 Task One running Task One total: 2 Task Two nothing to do This shows that Task One does all the work. The while loop that Task One hits within task() consumes all the work on the queue and processes it. When that loop exits, Task Two gets a chance to run. However, it finds that the queue is empty, so Task Two prints a statement that says it has nothing to do and then exits. There‚Äôs nothing in the code to allow both Task One and Task Two to switch contexts and work together. Simple Cooperative Concurrency The next version of the program allows the two tasks to work together. Adding a yield statement means the loop will yield control at the specified point while still maintaining its context. This way, the yielding task can be restarted later. The yield statement turns task() into a generator . A generator function is called just like any other function in Python, but when the yield statement is executed, control is returned to the caller of the function. This is essentially a context switch, as control moves from the generator function to the caller. The interesting part is that control can be given back to the generator function by calling next() on the generator. This is a context switch back to the generator function, which picks up execution with all function variables that were defined before the yield still intact. The while loop in main() takes advantage of this when it calls next(t) . This statement restarts the task at the point where it previously yielded. All of this means that you‚Äôre in control when the context switch happens: when the yield statement is executed in task() . This is a form of cooperative multitasking. The program is yielding control of its current context so that something else can run. In this case, it allows the while loop in main() to run two instances of task() as a generator function. Each instance consumes work from the same queue. This is sort of clever, but it‚Äôs also a lot of work to get the same results as the first program. The program example_2.py demonstrates this simple concurrency and is listed below: Python 1 import queue 2 3 def task ( name , queue ): 4 while not queue . empty (): 5 count = queue . get () 6 total = 0 7 print ( f "Task { name } running" ) 8 for x in range ( count ): 9 total += 1 10 yield 11 print ( f "Task { name } total: { total } " ) 12 13 def main (): 14 """ 15 This is the main entry point for the program 16 """ 17 # Create the queue of work 18 work_queue = queue . Queue () 19 20 # Put some work in the queue 21 for work in [ 15 , 10 , 5 , 2 ]: 22 work_queue . put ( work ) 23 24 # Create some tasks 25 tasks = [ task ( "One" , work_queue ), task ( "Two" , work_queue )] 26 27 # Run the tasks 28 done = False 29 while not done : 30 for t in tasks : 31 try : 32 next ( t ) 33 except StopIteration : 34 tasks . remove ( t ) 35 if len ( tasks ) == 0 : 36 done = True 37 38 if __name__ == "__main__" : 39 main () Here‚Äôs what‚Äôs happening in the code above: Lines 3 to 11 define task() as before, but the addition of yield on Line 10 turns the function into a generator. This where the context switch is made and control is handed back to the while loop in main() . Line 25 creates the task list, but in a slightly different manner than you saw in the previous example code. In this case, each task is called with its parameters as its entered in the tasks list variable. This is necessary to get the task() generator function running the first time. Lines 31 to 36 are the modifications to the while loop in main() that allow task() to run cooperatively. This is where control returns to each instance of task() when it yields, allowing the loop to continue and run another task. Line 32 gives control back to task() , and continues its execution after the point where yield was called. Line 36 sets the done variable. The while loop ends when all tasks have been completed and removed from tasks . This is the output produced when you run this program: Shell Task One running Task Two running Task Two total: 10 Task Two running Task One total: 15 Task One running Task Two total: 5 Task One total: 2 You can see that both Task One and Task Two are running and consuming work from the queue. This is what‚Äôs intended, as both tasks are processing work, and each is responsible for two items in the queue. This is interesting, but again, it takes quite a bit of work to achieve these results. The trick here is using the yield statement, which turns task() into a generator and performs a context switch. The program uses this context switch to give control to the while loop in main() , allowing two instances of a task to run cooperatively. Notice how Task Two outputs its total first. This might lead you to think that the tasks are running asynchronously. However, this is still a synchronous program. It‚Äôs structured so the two tasks can trade contexts back and forth. The reason why Task Two outputs its total first is that it‚Äôs only counting to 10, while Task One is counting to 15. Task Two simply arrives at its total first, so it gets to print its output to the console before Task One . Note: All of the example code that follows from this point use a module called codetiming to time and output how long sections of code took to execute. There is a great article here on RealPython that goes into depth about the codetiming module and how to use it. This module is part of the Python Package Index and is built by Geir Arne Hjelle , who is part of the Real Python team. Geir Arne has been a great help to me reviewing and suggesting things for this article. If you are writing code that needs to include timing functionality, Geir Arne‚Äôs codetiming module is well worth looking at. To make the codetiming module available for the examples that follow you‚Äôll need to install it. This can be done with pip with this command: pip install codetiming , or with this command: pip install -r requirements.txt . The requirements.txt file is part of the example code repository. Remove ads Cooperative Concurrency With Blocking Calls The next version of the program is the same as the last, except for the addition of a time.sleep(delay) in the body of your task loop. This adds a delay based on the value retrieved from the work queue to every iteration of the task loop. The delay simulates the effect of a blocking call occurring in your task. A blocking call is code that stops the CPU from doing anything else for some period of time. In the thought experiments above, if a parent wasn‚Äôt able to break away from balancing the checkbook until it was complete, that would be a blocking call. time.sleep(delay) does the same thing in this example, because the CPU can‚Äôt do anything else but wait for the delay to expire. Python 1 import time 2 import queue 3 from codetiming import Timer 4 5 def task ( name , queue ): 6 timer = Timer ( text = f "Task { name } elapsed time: {{ :.1f }} " ) 7 while not queue . empty (): 8 delay = queue . get () 9 print ( f "Task { name } running" ) 10 timer . start () 11 time . sleep ( delay ) 12 timer . stop () 13 yield 14 15 def main (): 16 """ 17 This is the main entry point for the program 18 """ 19 # Create the queue of work 20 work_queue = queue . Queue () 21 22 # Put some work in the queue 23 for work in [ 15 , 10 , 5 , 2 ]: 24 work_queue . put ( work ) 25 26 tasks = [ task ( "One" , work_queue ), task ( "Two" , work_queue )] 27 28 # Run the tasks 29 done = False 30 with Timer ( text = " \n Total elapsed time: {:.1f} " ): 31 while not done : 32 for t in tasks : 33 try : 34 next ( t ) 35 except StopIteration : 36 tasks . remove ( t ) 37 if len ( tasks ) == 0 : 38 done = True 39 40 if __name__ == "__main__" : 41 main () Here‚Äôs what‚Äôs different in the code above: Line 1 imports the time module to give the program access to time.sleep() . Line 3 imports the the Timer code from the codetiming module. Line 6 creates the Timer instance used to measure the time taken for each iteration of the task loop. Line 10 starts the timer instance Line 11 changes task() to include a time.sleep(delay) to mimic an IO delay. This replaces the for loop that did the counting in example_1.py . Line 12 stops the timer instance and outputs the elapsed time since timer.start() was called. Line 30 creates a Timer context manager that will output the elapsed time the entire while loop took to execute. When you run this program, you‚Äôll see the following output: Shell Task One running Task One elapsed time: 15.0 Task Two running Task Two elapsed time: 10.0 Task One running Task One elapsed time: 5.0 Task Two running Task Two elapsed time: 2.0 Total elapsed time: 32.0 As before, both Task One and Task Two are running, consuming work from the queue and processing it. However, even with the addition of the delay, you can see that cooperative concurrency hasn‚Äôt gotten you anything. The delay stops the processing of the entire program, and the CPU just waits for the IO delay to be over. This is exactly what‚Äôs meant by blocking code in Python async documentation. You‚Äôll notice that the time it takes to run the entire program is just the cumulative time of all the delays. Running tasks this way is not a win. Cooperative Concurrency With Non-Blocking Calls The next version of the program has been modified quite a bit. It makes use of Python async features using asyncio/await provided in Python 3. The time and queue modules have been replaced with the asyncio package. This gives your program access to asynchronous friendly (non-blocking) sleep and queue functionality. The change to task() defines it as asynchronous with the addition of the async prefix on line 4. This indicates to Python that the function will be asynchronous. The other big change is removing the time.sleep(delay) and yield statements, and replacing them with await asyncio.sleep(delay) . This creates a non-blocking delay that will perform a context switch back to the caller main() . The while loop inside main() no longer exists. Instead of task_array , there‚Äôs a call to await asyncio.gather(...) . This tells asyncio two things: Create two tasks based on task() and start running them. Wait for both of these to be completed before moving forward. The last line of the program asyncio.run(main()) runs main() . This creates what‚Äôs known as an event loop ). It‚Äôs this loop that will run main() , which in turn will run the two instances of task() . The event loop is at the heart of the Python async system. It runs all the code, including main() . When task code is executing, the CPU is busy doing work. When the await keyword is reached, a context switch occurs, and control passes back to the event loop. The event loop looks at all the tasks waiting for an event (in this case, an asyncio.sleep(delay) timeout) and passes control to a task with an event that‚Äôs ready. await asyncio.sleep(delay) is non-blocking in regards to the CPU. Instead of waiting for the delay to timeout, the CPU registers a sleep event on the event loop task queue and performs a context switch by passing control to the event loop. The event loop continuously looks for completed events and passes control back to the task waiting for that event. In this way, the CPU can stay busy if work is available, while the event loop monitors the events that will happen in the future. Note: An asynchronous program runs in a single thread of execution. The context switch from one section of code to another that would affect data is completely in your control. This means you can atomize and complete all shared memory data access before making a context switch. This simplifies the shared memory problem inherent in threaded code. The example_4.py code is listed below: Python 1 import asyncio 2 from codetiming import Timer 3 4 async def task ( name , work_queue ): 5 timer = Timer ( text = f "Task { name } elapsed time: {{ :.1f }} " ) 6 while not work_queue . empty (): 7 delay = await work_queue . get () 8 print ( f "Task { name } running" ) 9 timer . start () 10 await asyncio . sleep ( delay ) 11 timer . stop () 12 13 async def main (): 14 """ 15 This is the main entry point for the program 16 """ 17 # Create the queue of work 18 work_queue = asyncio . Queue () 19 20 # Put some work in the queue 21 for work in [ 15 , 10 , 5 , 2 ]: 22 await work_queue . put ( work ) 23 24 # Run the tasks 25 with Timer ( text = " \n Total elapsed time: {:.1f} " ): 26 await asyncio . gather ( 27 asyncio . create_task ( task ( "One" , work_queue )), 28 asyncio . create_task ( task ( "Two" , work_queue )), 29 ) 30 31 if __name__ == "__main__" : 32 asyncio . run ( main ()) Here‚Äôs what‚Äôs different between this program and example_3.py : Line 1 imports asyncio to gain access to Python async functionality. This replaces the time import. Line 2 imports the the Timer code from the codetiming module. Line 4 shows the addition of the async keyword in front of the task() definition. This informs the program that task can run asynchronously. Line 5 creates the Timer instance used to measure the time taken for each iteration of the task loop. Line 9 starts the timer instance Line 10 replaces time.sleep(delay) with the non-blocking asyncio.sleep(delay) , which also yields control (or switches contexts) back to the main event loop. Line 11 stops the timer instance and outputs the elapsed time since timer.start() was called. Line 18 creates the non-blocking asynchronous work_queue . Lines 21 to 22 put work into work_queue in an asynchronous manner using the await keyword. Line 25 creates a Timer context manager that will output the elapsed time the entire while loop took to execute. Lines 26 to 29 create the two tasks and gather them together, so the program will wait for both tasks to complete. Line 32 starts the program running asynchronously. It also starts the internal event loop. When you look at the output of this program, notice how both Task One and Task Two start at the same time, then wait at the mock IO call: Shell Task One running Task Two running Task Two total elapsed time: 10.0 Task Two running Task One total elapsed time: 15.0 Task One running Task Two total elapsed time: 5.0 Task One total elapsed time: 2.0 Total elapsed time: 17.0 This indicates that await asyncio.sleep(delay) is non-blocking, and that other work is being done. At the end of the program, you‚Äôll notice the total elapsed time is essentially half the time it took for example_3.py to run. That‚Äôs the advantage of a program that uses Python async features! Each task was able to run await asyncio.sleep(delay) at the same time. The total execution time of the program is now less than the sum of its parts. You‚Äôve broken away from the synchronous model! Remove ads Synchronous (Blocking) HTTP Calls The next version of the program is kind of a step forward as well as a step back. The program is doing some actual work with real IO by making HTTP requests to a list of URLs and getting the page contents. However, it‚Äôs doing so in a blocking (synchronous) manner. The program has been modified to import the wonderful requests module to make the actual HTTP requests. Also, the queue now contains a list of URLs, rather than numbers. In addition, task() no longer increments a counter. Instead, requests gets the contents of a URL retrieved from the queue, and prints how long it took to do so. The example_5.py code is listed below: Python 1 import queue 2 import requests 3 from codetiming import Timer 4 5 def task ( name , work_queue ): 6 timer = Timer ( text = f "Task { name } elapsed time: {{ :.1f }} " ) 7 with requests . Session () as session : 8 while not work_queue . empty (): 9 url = work_queue . get () 10 print ( f "Task { name } getting URL: { url } " ) 11 timer . start () 12 session . get ( url ) 13 timer . stop () 14 yield 15 16 def main (): 17 """ 18 This is the main entry point for the program 19 """ 20 # Create the queue of work 21 work_queue = queue . Queue () 22 23 # Put some work in the queue 24 for url in [ 25 "http://google.com" , 26 "http://yahoo.com" , 27 "http://linkedin.com" , 28 "http://apple.com" , 29 "http://microsoft.com" , 30 "http://facebook.com" , 31 "http://twitter.com" , 32 ]: 33 work_queue . put ( url ) 34 35 tasks = [ task ( "One" , work_queue ), task ( "Two" , work_queue )] 36 37 # Run the tasks 38 done = False 39 with Timer ( text = " \n Total elapsed time: {:.1f} " ): 40 while not done : 41 for t in tasks : 42 try : 43 next ( t ) 44 except StopIteration : 45 tasks . remove ( t ) 46 if len ( tasks ) == 0 : 47 done = True 48 49 if __name__ == "__main__" : 50 main () Here‚Äôs what‚Äôs happening in this program: Line 2 imports requests , which provides a convenient way to make HTTP calls. Line 3 imports the the Timer code from the codetiming module. Line 6 creates the Timer instance used to measure the time taken for each iteration of the task loop. Line 11 starts the timer instance Line 12 introduces a delay, similar to example_3.py . However, this time it calls session.get(url) , which returns the contents of the URL retrieved from work_queue . Line 13 stops the timer instance and outputs the elapsed time since timer.start() was called. Lines 23 to 32 put the list of URLs into work_queue . Line 39 creates a Timer context manager that will output the elapsed time the entire while loop took to execute. When you run this program, you‚Äôll see the following output: Shell Task One getting URL: http://google.com Task One total elapsed time: 0.3 Task Two getting URL: http://yahoo.com Task Two total elapsed time: 0.8 Task One getting URL: http://linkedin.com Task One total elapsed time: 0.4 Task Two getting URL: http://apple.com Task Two total elapsed time: 0.3 Task One getting URL: http://microsoft.com Task One total elapsed time: 0.5 Task Two getting URL: http://facebook.com Task Two total elapsed time: 0.5 Task One getting URL: http://twitter.com Task One total elapsed time: 0.4 Total elapsed time: 3.2 Just like in earlier versions of the program, yield turns task() into a generator. It also performs a context switch that lets the other task instance run. Each task gets a URL from the work queue, retrieves the contents of the page, and reports how long it took to get that content. As before, yield allows both your tasks to run cooperatively. However, since this program is running synchronously, each session.get() call blocks the CPU until the page is retrieved. Note the total time it took to run the entire program at the end. This will be meaningful for the next example. Asynchronous (Non-Blocking) HTTP Calls This version of the program modifies the previous one to use Python async features. It also imports the aiohttp module, which is a library to make HTTP requests in an asynchronous fashion using asyncio . The tasks here have been modified to remove the yield call since the code to make the HTTP GET call is no longer blocking. It also performs a context switch back to the event loop. The example_6.py program is listed below: Python 1 import asyncio 2 import aiohttp 3 from codetiming import Timer 4 5 async def task ( name , work_queue ): 6 timer = Timer ( text = f "Task { name } elapsed time: {{ :.1f }} " ) 7 async with aiohttp . ClientSession () as session : 8 while not work_queue . empty (): 9 url = await work_queue . get () 10 print ( f "Task { name } getting URL: { url } " ) 11 timer . start () 12 async with session . get ( url ) as response : 13 await response . text () 14 timer . stop () 15 16 async def main (): 17 """ 18 This is the main entry point for the program 19 """ 20 # Create the queue of work 21 work_queue = asyncio . Queue () 22 23 # Put some work in the queue 24 for url in [ 25 "http://google.com" , 26 "http://yahoo.com" , 27 "http://linkedin.com" , 28 "http://apple.com" , 29 "http://microsoft.com" , 30 "http://facebook.com" , 31 "http://twitter.com" , 32 ]: 33 await work_queue . put ( url ) 34 35 # Run the tasks 36 with Timer ( text = " \n Total elapsed time: {:.1f} " ): 37 await asyncio . gather ( 38 asyncio . create_task ( task ( "One" , work_queue )), 39 asyncio . create_task ( task ( "Two" , work_queue )), 40 ) 41 42 if __name__ == "__main__" : 43 asyncio . run ( main ()) Here‚Äôs what‚Äôs happening in this program: Line 2 imports the aiohttp library, which provides an asynchronous way to make HTTP calls. Line 3 imports the the Timer code from the codetiming module. Line 5 marks task() as an asynchronous function. Line 6 creates the Timer instance used to measure the time taken for each iteration of the task loop. Line 7 creates an aiohttp session context manager. Line 8 creates an aiohttp response context manager. It also makes an HTTP GET call to the URL taken from work_queue . Line 11 starts the timer instance Line 12 uses the session to get the text retrieved from the URL asynchronously. Line 13 stops the timer instance and outputs the elapsed time since timer.start() was called. Line 39 creates a Timer context manager that will output the elapsed time the entire while loop took to execute. When you run this program, you‚Äôll see the following output: Shell Task One getting URL: http://google.com Task Two getting URL: http://yahoo.com Task One total elapsed time: 0.3 Task One getting URL: http://linkedin.com Task One total elapsed time: 0.3 Task One getting URL: http://apple.com Task One total elapsed time: 0.3 Task One getting URL: http://microsoft.com Task Two total elapsed time: 0.9 Task Two getting URL: http://facebook.com Task Two total elapsed time: 0.4 Task Two getting URL: http://twitter.com Task One total elapsed time: 0.5 Task Two total elapsed time: 0.3 Total elapsed time: 1.7 Take a look at the total elapsed time, as well as the individual times to get the contents of each URL. You‚Äôll see that the duration is about half the cumulative time of all the HTTP GET calls. This is because the HTTP GET calls are running asynchronously. In other words, you‚Äôre effectively taking better advantage of the CPU by allowing it to make multiple requests at once. Because the CPU is so fast, this example could likely create as many tasks as there are URLs. In this case, the program‚Äôs run time would be that of the single slowest URL retrieval. Remove ads Conclusion This article has given you the tools you need to start making asynchronous programming techniques a part of your repertoire. Using Python async features gives you programmatic control of when context switches take place. This means that many of the tougher issues you might see in threaded programming are easier to deal with. Asynchronous programming is a powerful tool, but it isn‚Äôt useful for every kind of program. If you‚Äôre writing a program that calculates pi to the millionth decimal place, for instance, then asynchronous code won‚Äôt help you. That kind of program is CPU bound, without much IO. However, if you‚Äôre trying to implement a server or a program that performs IO (like file or network access), then using Python async features could make a huge difference. To sum it up, you‚Äôve learned: What synchronous programs are How asynchronous programs are different, but also powerful and manageable Why you might want to write asynchronous programs How to use the built-in async features in Python You can get the code for all of the example programs used in this tutorial: Download Code: Click here to download the code you‚Äôll use to learn about async features in Python in this tutorial. Now that you‚Äôre equipped with these powerful skills, you can take your programs to the next level! Take the Quiz: Test your knowledge with our interactive ‚ÄúGetting Started With Async Features in Python‚Äù quiz. You‚Äôll receive a score upon completion to help you track your learning progress: Interactive Quiz Getting Started With Async Features in Python In this quiz, you'll test your understanding of asynchronous programming in Python. You'll revisit the concepts of synchronous and asynchronous programs, and why you might want to write an asynchronous program. You'll also test your knowledge on how to use Python async features. Mark as Completed Share üêç Python Tricks üíå Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team. Send Me Python Tricks ¬ª About Doug Farrell Doug is a Python developer with more than 25 years of experience. He writes about Python on his personal website and works as a Senior Web Engineer with Shutterfly. ¬ª More about Doug Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are: Aldren Brad Geir Arne Jaya Joanna Master Real-World Python Skills With Unlimited Access to Real Python Join us and get access to thousands of tutorials, hands-on video courses, and a community of expert Pythonistas: Level Up Your Python Skills ¬ª Master Real-World Python Skills With Unlimited Access to Real Python Join us and get access to thousands of tutorials, hands-on video courses, and a community of expert Pythonistas: Level Up Your Python Skills ¬ª What Do You Think? Rate this article: LinkedIn Twitter Bluesky Facebook Email What‚Äôs your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know. Commenting Tips: The most useful comments are those written with the goal of learning from or helping out other students. Get tips for asking good questions and get answers to common questions in our support portal . Looking for a real-time conversation? Visit the Real Python Community Chat or join the next ‚ÄúOffice Hours‚Äù Live Q&A Session . Happy Pythoning! Keep Learning Related Topics: intermediate python Related Tutorials: Python's asyncio: A Hands-On Walkthrough Speed Up Your Python Program With Concurrency Asynchronous Iterators and Iterables in Python Using FastAPI to Build Python Web APIs Iterators and Iterables in Python: Run Efficient Iterations Keep reading Real Python by creating a free account or signing in: Continue ¬ª Already have an account? Sign-In Almost there! Complete this form and click the button below to gain instant access: √ó Async Features in Python (Code) Send Code ¬ª üîí No spam. We take your privacy seriously. Learn Python Start Here Learning Resources Code Mentor Python Reference Python Cheat Sheet Support Center Courses & Paths Learning Paths Quizzes & Exercises Browse Topics Workshops Books Community Podcast Newsletter Community Chat Office Hours Learner Stories Membership Plans & Pricing Team Plans For Business For Schools Reviews Company About Us Team Mission & Values Sponsorships Careers Press Kit Merch Privacy Policy ‚ãÖ Terms of Use ‚ãÖ Security ‚ãÖ Contact Happy Pythoning! ¬© 2012‚Äì2025 DevCademy Media Inc. DBA Real Python. All rights reserved. REALPYTHON‚Ñ¢ is a trademark of DevCademy Media Inc. Free Bonus: Python Cheat Sheet √ó Get a Python Cheat Sheet (PDF) and learn the basics of Python, like working with data types, dictionaries, lists, and Python functions: Send My Python Cheat Sheet ¬ª (confidence: 0.80)
- Finding from Python async - GeeksforGeeks: Python async - GeeksforGeeks Skip to content Tutorials Python Java DSA ML & Data Science Interview Corner Programming Languages Web Development CS Subjects DevOps Software and Tools School Learning Practice Coding Problems Courses DSA / Placements ML & Data Science Development Cloud / DevOps Programming Languages All Courses Tracks Languages Python C C++ Java Advanced Java SQL JavaScript Interview Preparation GfG 160 GfG 360 System Design Core Subjects Interview Questions Interview Puzzles Aptitude and Reasoning Data Science Python Data Analytics Complete Data Science Dev Skills Full-Stack Web Dev DevOps Software Testing CyberSecurity Tools Computer Fundamentals AI Tools MS Excel & Google Sheets MS Word & Google Docs Maths Maths For Computer Science Engineering Mathematics Python Tutorial Data Types Interview Questions Examples Quizzes DSA Python Data Science NumPy Pandas Practice Django Flask Projects Sign In ‚ñ≤ Open In App Python async Last Updated : 23 Jul, 2025 Comments Improve Suggest changes 4 Likes Like Report async keyword in Python is used to define asynchronous functions , which allow tasks to run without blocking the execution of other code. It is commonly used for handling tasks like network requests, database operations or file I/O, where waiting for one task to finish would normally slow down the entire program. Async relies on await because an async function does not execute asynchronously on its own, it needs await to actually pause and resume tasks. To use async in our code, we need to first import the asyncio library, to know about it in detail, refer to asyncio in Python . Let's consider an example. Python import asyncio async def func (): print ( "Hello!" ) await asyncio . sleep ( 2 ) # Pause for 2 second without blocking print ( "Geeks for Geeks" ) # asyncio . run ( func ()) Output Hello! Geeks for Geeks Explanation: "async" keyword before " def" keyword defines the function func as an asynchronous function. " await asyncio.sleep(2) " makes it wait for 2 second before continuing. that's why when the function is called using " asyncio.run(gree()) ", the second print statement gets executed after a delay of 2 seconds. Syntax: async def function_name(): await some_async_function() async def: defines an asynchronous function. await: pauses execution until the awaited function completes. Let's see some of the use cases of the async with examples. Running Multiple Tasks Simultaneously With the help of async , multiple tasks can run without waiting for one to finish before starting another. Python import asyncio async def task1 (): print ( "Task 1 started" ) await asyncio . sleep ( 3 ) print ( "Task 1 finished" ) async def task2 (): print ( "Task 2 started" ) await asyncio . sleep ( 1 ) print ( "Task 2 finished" ) async def main (): await asyncio . gather ( task1 (), task2 ()) # Runs both tasks together asyncio . run ( main ()) Output Task 1 started Task 2 started Task 2 finished Task 1 finished Explanation: in this code, task1() and task2() run at the same time becasue they are defined as async functions. task2() completes first because it waits for only 1 second, while task1() waits for 3 seconds. Using Async with HTTP Requests It is a very common practice to use async keyword with HTTP requests , if we fetch data from multiple URLs using a synchronous approach, each request blocks the execution until it completes. However, with async, we can send multiple requests simultaneously, making the program much faster. Here's an example: Python import aiohttp import asyncio async def func (): async with aiohttp . ClientSession () as session : async with session . get ( "https://example.com/" ) as res : data = await res . text () print ( data [: 100 ]) # Prints first 100 characters asyncio . run ( func ()) Output <!doctype html> <html> <head> <title>Example Domain</title> <meta charset="utf-8" /> <m Explanation: In this code we have defined an asynchronous function that performs an HTTP request using the async keyword, the breakdown of code is such: aiohttp library is used for making async HTTP requests. aiohttp.ClientSession(), creates HTTP session and making an asynchronous get request using session.get(). await keyword ensures that the request completes before proceeding to the next step. data[:100] ensure that only first 100 characters are printed. Note: Ensure that "aiohttp" library is installed on your system before running the code. If it's mot installed, you can add it by running "pip install aiohttp" command in the terminal Using Async with File I/O Python by default handles files one at a time, making the program wait until the task is done. But async can also be used for file operations. While writing and reading files, we can simulate async behavior using asyncio.sleep() to represent delays, similar to real-world scenarios where I/O operations take time. Here's an example: Python import asyncio import aiofiles import asyncio async def write (): async with aiofiles . open ( r "paste_your_file_path_here\file.txt" , "w" ) as f : await f . write ( "Hello from Geeks for Geeks!" ) async def read (): async with aiofiles . open ( r "paste_your_file_path_here\file.txt" , "r" ) as f : print ( await f . read ()) asyncio . run ( write ()) asyncio . run ( read ()) Output Hello from Geeks for Geeks! Explanation: write_file () writes data to " file.txt " if it already exists in the specified path. If the file doesn't exist, it automatically creates a new " file.txt " and writes data to it. read_file () opens "file.txt" in read mode and prints its content asynchronously. If the file doesn‚Äôt exist, it will raise a FileNotFoundError . asyncio.run(write()) runs first, making sure the file is created and written. Then, asyncio.run(read()) runs, reading and printing the content. To learn about file-handling in Python in detail, refer to- File Handling In Python Comment P prajjqv52 Follow 4 Improve P prajjqv52 Follow 4 Improve Article Tags : Python python-basics Explore Python Fundamentals Python Introduction 2 min read Input and Output in Python 4 min read Python Variables 5 min read Python Operators 4 min read Python Keywords 2 min read Python Data Types 8 min read Conditional Statements in Python 3 min read Loops in Python - For, While and Nested Loops 5 min read Python Functions 5 min read Recursion in Python 4 min read Python Lambda Functions 5 min read Python Data Structures Python String 5 min read Python Lists 4 min read Python Tuples 4 min read Python Dictionary 3 min read Python Sets 6 min read Python Arrays 7 min read List Comprehension in Python 4 min read Advanced Python Python OOP Concepts 11 min read Python Exception Handling 5 min read File Handling in Python 4 min read Python Database Tutorial 4 min read Python MongoDB Tutorial 2 min read Python MySQL 9 min read Python Packages 10 min read Python Modules 7 min read Python DSA Libraries 15 min read List of Python GUI Library and Packages 3 min read Data Science with Python NumPy Tutorial - Python Library 3 min read Pandas Tutorial 4 min read Matplotlib Tutorial 5 min read Python Seaborn Tutorial 15+ min read StatsModel Library- Tutorial 4 min read Learning Model Building in Scikit-learn 8 min read TensorFlow Tutorial 2 min read PyTorch Tutorial 6 min read Web Development with Python Flask Tutorial 8 min read Django Tutorial | Learn Django Framework 7 min read Django ORM - Inserting, Updating & Deleting Data 4 min read Templating With Jinja2 in Flask 6 min read Django Templates 7 min read Python | Build a REST API using Flask 3 min read How to Create a basic API using Django Rest Framework ? 4 min read Python Practice Python Quiz 1 min read Python Coding Practice 1 min read Python Interview Questions and Answers 15+ min read Like Corporate & Communications Address: A-143, 7th Floor, Sovereign Corporate Tower, Sector- 136, Noida, Uttar Pradesh (201305) Registered Address: K 061, Tower K, Gulshan Vivante Apartment, Sector 137, Noida, Gautam Buddh Nagar, Uttar Pradesh, 201305 Company About Us Legal Privacy Policy Contact Us Advertise with us GFG Corporate Solution Campus Training Program Explore POTD Job-A-Thon Blogs Nation Skill Up Tutorials Programming Languages DSA Web Technology AI, ML & Data Science DevOps CS Core Subjects Interview Preparation Software and Tools Courses IBM Certification DSA and Placements Web Development Programming Languages DevOps & Cloud GATE Trending Technologies Videos DSA Python Java C++ Web Development Data Science CS Subjects Preparation Corner Interview Corner Aptitude Puzzles GfG 160 System Design @GeeksforGeeks, Sanchhaya Education Private Limited , All rights reserved Improvement Suggest changes Suggest Changes Help us improve. Share your suggestions to enhance the article. Contribute your expertise and make a difference in the GeeksforGeeks portal. Create Improvement Enhance the article with your expertise. Contribute to the GeeksforGeeks community and help create better learning resources for all. Suggest Changes min 4 words, max Words Limit:1000 Thank You! Your suggestions are valuable to us. What kind of Experience do you want to share? Interview Experiences Admission Experiences Career Journeys Work Experiences Campus Experiences Competitive Exam Experiences (confidence: 0.80)
- Finding from asyncio ‚Äî Asynchronous I/O ‚Äî Python 3.14.0 documentation: asyncio ‚Äî Asynchronous I/O ‚Äî Python 3.14.0 documentation Theme Auto Light Dark Previous topic Networking and Interprocess Communication Next topic Runners This page Report a bug Show source Navigation index modules | next | previous | Python ¬ª 3.14.0 Documentation ¬ª The Python Standard Library ¬ª Networking and Interprocess Communication ¬ª asyncio ‚Äî Asynchronous I/O | Theme Auto Light Dark | asyncio ‚Äî Asynchronous I/O ¬∂ Hello World! import asyncio async def main (): print ( 'Hello ...' ) await asyncio . sleep ( 1 ) print ( '... World!' ) asyncio . run ( main ()) asyncio is a library to write concurrent code using the async/await syntax. asyncio is used as a foundation for multiple Python asynchronous frameworks that provide high-performance network and web-servers, database connection libraries, distributed task queues, etc. asyncio is often a perfect fit for IO-bound and high-level structured network code. See also A Conceptual Overview of asyncio Explanation of the fundamentals of asyncio. asyncio provides a set of high-level APIs to: run Python coroutines concurrently and have full control over their execution; perform network IO and IPC ; control subprocesses ; distribute tasks via queues ; synchronize concurrent code; Additionally, there are low-level APIs for library and framework developers to: create and manage event loops , which provide asynchronous APIs for networking , running subprocesses , handling OS signals , etc; implement efficient protocols using transports ; bridge callback-based libraries and code with async/await syntax. Availability : not WASI. This module does not work or is not available on WebAssembly. See WebAssembly platforms for more information. asyncio REPL You can experiment with an asyncio concurrent context in the REPL : $ python -m asyncio asyncio REPL ... Use "await" directly instead of "asyncio.run()". Type "help", "copyright", "credits" or "license" for more information. >>> import asyncio >>> await asyncio . sleep ( 10 , result = 'hello' ) 'hello' Raises an auditing event cpython.run_stdin with no arguments. Changed in version 3.12.5: (also 3.11.10, 3.10.15, 3.9.20, and 3.8.20) Emits audit events. Changed in version 3.13: Uses PyREPL if possible, in which case PYTHONSTARTUP is also executed. Emits audit events. Reference High-level APIs Runners Coroutines and Tasks Streams Synchronization Primitives Subprocesses Queues Exceptions Call Graph Introspection Low-level APIs Event Loop Futures Transports and Protocols Policies Platform Support Extending Guides and Tutorials High-level API Index Low-level API Index Developing with asyncio Note The source code for asyncio can be found in Lib/asyncio/ . Previous topic Networking and Interprocess Communication Next topic Runners This page Report a bug Show source ¬´ Navigation index modules | next | previous | Python ¬ª 3.14.0 Documentation ¬ª The Python Standard Library ¬ª Networking and Interprocess Communication ¬ª asyncio ‚Äî Asynchronous I/O | Theme Auto Light Dark | ¬© Copyright 2001 Python Software Foundation. This page is licensed under the Python Software Foundation License Version 2. Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License. See History and License for more information. The Python Software Foundation is a non-profit corporation. Please donate. Last updated on Oct 22, 2025 (06:06 UTC). Found a bug ? Created using Sphinx 8.2.3. (confidence: 0.80)

## Metadata

- **Strategy**: Comprehensive
- **Depth**: 1
- **Sources**: 3
- **Diversity Score**: 1.00
- **Confidence**: High

## Findings

### Finding 1

Finding from Getting Started With Async Features in Python: Getting Started With Async Features in Python ‚Äì Real Python Start Here Learn Python Python Tutorials ‚Üí In-depth articles and video courses Learning Paths ‚Üí Guided study plans for accelerated learning Quizzes & Exercises ‚Üí Check your learning progress Browse Topics ‚Üí Focus on a specific area or skill level Community Chat ‚Üí Learn with other Pythonistas Office Hours ‚Üí Live Q&A calls with Python experts Podcast ‚Üí Hear what‚Äôs new in the world of Python Books ‚Üí Round out your knowledge and learn offline Reference ‚Üí Concise definitions for common Python terms Code Mentor ‚Üí Beta Personalized code assistance & learning tools Unlock All Content ‚Üí More Learner Stories Python Newsletter Python Job Board Meet the Team Become a Tutorial Writer Become a Video Instructor Search / Join Sign‚ÄëIn ‚Äî FREE Email Series ‚Äî üêç Python Tricks üíå Get Python Tricks ¬ª üîí No spam. Unsubscribe any time. Browse Topics Guided Learning Paths Basics Intermediate Advanced ai api best-practices career community databases data-science data-structures data-viz devops django docker editors flask front-end gamedev gui machine-learning news numpy projects python testing tools web-dev web-scraping Table of Contents Understanding Asynchronous Programming Building a Synchronous Web Server Thinking Differently About Programming Programming Parents: Not as Easy as It Looks! Thought Experiment #1: The Synchronous Parent Thought Experiment #2: The Polling Parent Thought Experiment #3: The Threading Parent Using Python Async Features in Practice Synchronous Programming Simple Cooperative Concurrency Cooperative Concurrency With Blocking Calls Cooperative Concurrency With Non-Blocking Calls Synchronous (Blocking) HTTP Calls Asynchronous (Non-Blocking) HTTP Calls Conclusion Mark as Completed Share Getting Started With Async Features in Python by Doug Farrell Reading time estimate 37m intermediate python Mark as Completed Share Table of Contents Understanding Asynchronous Programming Building a Synchronous Web Server Thinking Differently About Programming Programming Parents: Not as Easy as It Looks! Thought Experiment #1: The Synchronous Parent Thought Experiment #2: The Polling Parent Thought Experiment #3: The Threading Parent Using Python Async Features in Practice Synchronous Programming Simple Cooperative Concurrency Cooperative Concurrency With Blocking Calls Cooperative Concurrency With Non-Blocking Calls Synchronous (Blocking) HTTP Calls Asynchronous (Non-Blocking) HTTP Calls Conclusion Remove ads Have you heard of asynchronous programming in Python? Are you curious to know more about Python async features and how you can use them in your work? Perhaps you‚Äôve even tried to write threaded programs and run into some issues. If you‚Äôre looking to understand how to use Python async features, then you‚Äôve come to the right place. In this article, you‚Äôll learn: What a synchronous program is What an asynchronous program is Why you might want to write an asynchronous program How to use Python async features All of the example code in this article have been tested with Python 3.7.2. You can grab a copy to follow along by clicking the link below: Download Code: Click here to download the code you‚Äôll use to learn about async features in Python in this tutorial. Take the Quiz: Test your knowledge with our interactive ‚ÄúGetting Started With Async Features in Python‚Äù quiz. You‚Äôll receive a score upon completion to help you track your learning progress: Interactive Quiz Getting Started With Async Features in Python In this quiz, you'll test your understanding of asynchronous programming in Python. You'll revisit the concepts of synchronous and asynchronous programs, and why you might want to write an asynchronous program. You'll also test your knowledge on how to use Python async features. Understanding Asynchronous Programming A synchronous program is executed one step at a time. Even with conditional branching, loops and function calls, you can still think about the code in terms of taking one execution step at a time. When each step is complete, the program moves on to the next one. Here are two examples of programs that work this way: Batch processing programs are often created as synchronous programs. You get some input, process it, and create some output. Steps follow one after the other until the program reaches the desired output. The program only needs to pay attention to the steps and their order. Command-line programs are small, quick processes that run in a terminal. These scripts are used to create something, transform one thing into something else, generate a report, or perhaps list out some data. This can be expressed as a series of program steps that are executed sequentially until the program is done. An asynchronous program behaves differently. It still takes one execution step at a time. The difference is that the system may not wait for an execution step to be completed before moving on to the next one. This means that the program will move on to future execution steps even though a previous step hasn‚Äôt yet finished and is still running elsewhere. This also means that the program knows what to do when a previous step does finish running. Why would you want to write a program in this manner? The rest of this article will help you answer that question and give you the tools you need to elegantly solve interesting asynchronous problems. Remove ads Building a Synchronous Web Server A web server‚Äôs basic unit of work is, more or less, the same as batch processing. The server will get some input, process it, and create the output. Written as a synchronous program, this would create a working web server. It would also be an absolutely terrible web server. Why? In this case, one unit of work (input, process, output) is not the only purpose. The real purpose is to handle hundreds or even thousands of units of work as quickly as possible. This can happen over long periods of time, and several work units may even arrive all at once. Can a synchronous web server be made better? Sure, you could optimize the execution steps so that all the work coming in is handled as quickly as possible. Unfortunately, there are limitations to this approach. The result could be a web server that doesn‚Äôt respond fast enough, can‚Äôt handle enough work, or even one that times out when work gets stacked up. Note: There are other limitations you might see if you tried to optimize the above approach. These include network speed, file IO speed, database query speed, and the speed of other connected services, to name a few. What these all have in common is that they are all IO functions. All of these items are orders of magnitude slower than the CPU‚Äôs processing speed. In a synchronous program, if an execution step starts a database query, then the CPU is essentially idle until the database query is returned. For batch-oriented programs, this isn‚Äôt a priority most of the time. Processing the results of that IO operation is the goal. Often, this can take longer than the IO operation itself. Any optimization efforts would be focused on the processing work, not the IO. Asynchronous programming techniques allow your programs to take advantage of relatively slow IO processes by freeing the CPU to do other work. Thinking Differently About Programming When you start trying to understand asynchronous programming, you might see a lot of discussion about the importance of blocking, or writing non-blocking code . (Personally, I struggled to get a good grasp of these concepts from the people I asked and the documentation I read.) What is non-blocking code? What‚Äôs blocking code, for that matter? Would the answers to these questions help you write a better web server? If so, how could you do it? Let‚Äôs find out! Writing asynchronous programs requires that you think differently about programming. While this new way of thinking can be hard to wrap your head around, it‚Äôs also an interesting exercise. That‚Äôs because the real world is almost entirely asynchronous, and so is how you interact with it. Imagine this: you‚Äôre a parent trying to do several things at once. You have to balance the checkbook, do the laundry, and keep an eye on the kids. Somehow, you‚Äôre able to do all of these things at the same time without even thinking about it! Let‚Äôs break it down: Balancing the checkbook is a synchronous task. One step follows another until it‚Äôs done. You‚Äôre doing all the work yourself. However, you can break away from the checkbook to do laundry. You unload the dryer, move clothes from the washer to the dryer, and start another load in the washer. Working with the washer and dryer is a synchronous task, but the bulk of the work happens after the washer and dryer are started. Once you‚Äôve got them going, you can walk away and get back to the checkbook task. At this point, the washer and dryer tasks have become asynchronous . The washer and dryer will run independently until the buzzer goes off (notifying you that the task needs attention). Watching your kids is another asynchronous task. Once they are set up and playing, they can do so independently for the most part. This changes when someone needs attention, like when someone gets hungry or hurt. When one of your kids yells in alarm, you react. The kids are a long-running task with high priority. Watching them supersedes any other tasks you might be doing, like the checkbook or laundry. These examples can help to illustrate the concepts of blocking and non-blocking code. Let‚Äôs think about this in programming terms. In this example, you‚Äôre like the CPU. While you‚Äôre moving the laundry around, you (the CPU) are busy and blocked from doing other work, like balancing the checkbook. But that‚Äôs okay because the task is relatively quick. On the other hand, starting the washer and dryer does not block you from performing other tasks. It‚Äôs an asynchronous function because you don‚Äôt have to wait for it to finish. Once it‚Äôs started, you can go back to something else. This is called a context switch: the context of what you‚Äôre doing has changed, and the machine‚Äôs buzzer will notify you sometime in the future when the laundry task is complete. As a human, this is how you work all the time. You naturally juggle multiple things at once, often without thinking about it. As a developer, the trick is how to translate this kind of behavior into code that does the same kind of thing. Programming Parents: Not as Easy as It Looks! If you recognize yourself (or your parents) in the example above, then that‚Äôs great! You‚Äôve got a leg up in understanding asynchronous programming. Again, you‚Äôre able to switch contexts between competing tasks fairly easily, picking up some tasks and resuming others. Now you‚Äôre going to try and program this behavior into virtual parents! Thought Experiment #1: The Synchronous Parent How would you create a parent program to do the above tasks in a completely synchronous manner? Since watching the kids is a high-priority task, perhaps your program would do just that. The parent watches over the kids while waiting for something to happen that might need their attention. However, nothing else (like the checkbook or laundry) would get done in this scenario. Now, you can re-prioritize the tasks any way you want, but only one of them would happen at any given time. This is the result of a synchronous, step-by-step approach. Like the synchronous web server described above, this would work, but it might not be the best way to live. The parent wouldn‚Äôt be able to complete any other tasks until the kids fell asleep. All other tasks would happen afterward, well into the night. (A couple of weeks of this and many real parents might jump out the window!) Remove ads Thought Experiment #2: The Polling Parent If you used polling , then you could change things up so that multiple tasks are completed. In this approach, the parent would periodically break away from the current task and check to see if any other tasks need attention. Let‚Äôs make the polling interval something like fifteen minutes. Now, every fifteen minutes your parent checks to see if the washer, dryer or kids need any attention. If not, then the parent can go back to work on the checkbook. However, if any of those tasks do need attention, then the parent will take care of it before going back to the checkbook. This cycle continues on until the next timeout out of the polling loop. This approach works as well since multiple tasks are getting attention. However, there are a couple of problems: The parent may spend a lot of time checking on things that don‚Äôt need attention: The washer and dryer haven‚Äôt yet finished, and the kids don‚Äôt need any attention unless something unexpected happens. The parent may miss completed tasks that do need attention: For instance, if the washer finished its cycle at the beginning of the polling interval, then it wouldn‚Äôt get any attention for up to fifteen minutes! What‚Äôs more, watching the kids is supposedly the highest priority task. They couldn‚Äôt tolerate fifteen minutes with no attention when something might be going drastically wrong. You could address these issues by shortening the polling interval, but now your parent (the CPU) would be spending more time context switching between tasks. This is when you start to hit a point of diminishing returns. (Once again, a couple of weeks living like this and, well‚Ä¶ See the previous comment about windows and jumping.) Thought Experiment #3: The Threading Parent ‚ÄúIf I could only clone myself‚Ä¶‚Äù If you‚Äôre a parent, then you‚Äôve probably had similar thoughts! Since you‚Äôre programming virtual parents, you can essentially do this by using threading. This is a mechanism that allows multiple sections of one program to run at the same time. Each section of code that runs independently is known as a thread, and all threads share the same memory space. If you think of each task as a part of one program, then you can separate them and run them as threads. In other words, you can ‚Äúclone‚Äù the parent, creating one instance for each task: watching the kids, monitoring the washer, monitoring the dryer, and balancing the checkbook. All of these ‚Äúclones‚Äù are running independently. This sounds like a pretty nice solution, but there are some issues here as well. One is that you‚Äôll have to explicitly tell each parent instance what to do in your program. This can lead to some problems since all instances share everything in the program space. For example, say that Parent A is monitoring the dryer. Parent A sees that the clothes are dry, so they take control of the dryer and begin unloading the clothes. At the same time, Parent B sees that the washer is done, so they take control of the washer and begin removing clothes. However, Parent B also needs to take control of the dryer so they can put the wet clothes inside. This can‚Äôt happen, because Parent A currently has control of the dryer. After a short while, Parent A has finished unloading clothes. Now they want to take control of the washer and start moving clothes into the empty dryer. This can‚Äôt happen, either, because Parent B currently has control of the washer! These two parents are now deadlocked . Both have control of their own resource and want control of the other resource. They‚Äôll wait forever for the other parent instance to release control. As the programmer, you‚Äôd have to write code to work this situation out. Note: Threaded programs allow you to create multiple, parallel paths of execution that all share the same memory space. This is both an advantage and a disadvantage. Any memory shared between threads is subject to one or more threads trying to use the same shared memory at the same time. This can lead to data corruption, data read in an invalid state, and data that‚Äôs just messy in general. In threaded programming, the context switch happens under system control, not the programmer. The system controls when to switch contexts and when to give threads access to shared data, thereby changing the context of how the memory is being used. All of these kinds of problems are manageable in threaded code, but it‚Äôs difficult to get right, and hard to debug when it‚Äôs wrong. Here‚Äôs another issue that might arise from threading. Suppose that a child gets hurt and needs to be taken to urgent care. Parent C has been assigned the task of watching over the kids, so they take the child right away. At the urgent care, Parent C needs to write a fairly large check to cover the cost of seeing the doctor. Meanwhile, Parent D is at home working on the checkbook. They‚Äôre unaware of this large check being written, so they‚Äôre very surprised when the family checking account is suddenly overdrawn! Remember, these two parent instances are working within the same program. The family checking account is a shared resource, so you‚Äôd have to work out a way for the child-watching parent to inform the checkbook-balancing parent. Otherwise, you‚Äôd need to provide some kind of locking mechanism so that the checkbook resource can only be used by one parent at a time, with updates. Using Python Async Features in Practice Now you‚Äôre going to take some of the approaches outlined in the thought experiments above and turn them into functioning Python programs. All of the examples in this article have been tested with Python 3.7.2. The requirements.txt file indicates which modules you‚Äôll need to install to run all the examples. If you haven‚Äôt yet downloaded the file, you can do so now: Download Code: Click here to download the code you‚Äôll use to learn about async features in Python in this tutorial. You also might want to set up a Python virtual environment to run the code so you don‚Äôt interfere with your system Python. Remove ads Synchronous Programming This first example shows a somewhat contrived way of having a task retrieve work from a queue and process that work. A queue in Python is a nice FIFO (first in first out) data structure. It provides methods to put things in a queue and take them out again in the order they were inserted. In this case, the work is to get a number from the queue and have a loop count up to that number. It prints to the console when the loop begins, and again to output the total. This program demonstrates one way for multiple synchronous tasks to process the work in a queue. The program named example_1.py in the repository is listed in full below: Python 1 import queue 2 3 def task ( name , work_queue ): 4 if work_queue . empty (): 5 print ( f "Task { name } nothing to do" ) 6 else : 7 while not work_queue . empty (): 8 count = work_queue . get () 9 total = 0 10 print ( f "Task { name } running" ) 11 for x in range ( count ): 12 total += 1 13 print ( f "Task { name } total: { total } " ) 14 15 def main (): 16 """ 17 This is the main entry point for the program 18 """ 19 # Create the queue of work 20 work_queue = queue . Queue () 21 22 # Put some work in the queue 23 for work in [ 15 , 10 , 5 , 2 ]: 24 work_queue . put ( work ) 25 26 # Create some synchronous tasks 27 tasks = [( task , "One" , work_queue ), ( task , "Two" , work_queue )] 28 29 # Run the tasks 30 for t , n , q in tasks : 31 t ( n , q ) 32 33 if __name__ == "__main__" : 34 main () Let‚Äôs take a look at what each line does: Line 1 imports the queue module. This is where the program stores work to be done by the tasks. Lines 3 to 13 define task() . This function pulls work out of work_queue and processes the work until there isn‚Äôt any more to do. Line 15 defines main() to run the program tasks. Line 20 creates the work_queue . All tasks use this shared resource to retrieve work. Lines 23 to 24 put work in work_queue . In this case, it‚Äôs just a random count of values for the tasks to process. Line 27 creates a list of task tuples, with the parameter values those tasks will be passed. Lines 30 to 31 iterate over the list of task tuples, calling each one and passing the previously defined parameter values. Line 34 calls main() to run the program. The task in this program is just a function accepting a string and a queue as parameters. When executed, it looks for anything in the queue to process. If there is work to do, then it pulls values off the queue, starts a for loop to count up to that value, and outputs the total at the end. It continues getting work off the queue until there is nothing left and it exits. When this program is run, it produces the output you see below: Shell Task One running Task One total: 15 Task One running Task One total: 10 Task One running Task One total: 5 Task One running Task One total: 2 Task Two nothing to do This shows that Task One does all the work. The while loop that Task One hits within task() consumes all the work on the queue and processes it. When that loop exits, Task Two gets a chance to run. However, it finds that the queue is empty, so Task Two prints a statement that says it has nothing to do and then exits. There‚Äôs nothing in the code to allow both Task One and Task Two to switch contexts and work together. Simple Cooperative Concurrency The next version of the program allows the two tasks to work together. Adding a yield statement means the loop will yield control at the specified point while still maintaining its context. This way, the yielding task can be restarted later. The yield statement turns task() into a generator . A generator function is called just like any other function in Python, but when the yield statement is executed, control is returned to the caller of the function. This is essentially a context switch, as control moves from the generator function to the caller. The interesting part is that control can be given back to the generator function by calling next() on the generator. This is a context switch back to the generator function, which picks up execution with all function variables that were defined before the yield still intact. The while loop in main() takes advantage of this when it calls next(t) . This statement restarts the task at the point where it previously yielded. All of this means that you‚Äôre in control when the context switch happens: when the yield statement is executed in task() . This is a form of cooperative multitasking. The program is yielding control of its current context so that something else can run. In this case, it allows the while loop in main() to run two instances of task() as a generator function. Each instance consumes work from the same queue. This is sort of clever, but it‚Äôs also a lot of work to get the same results as the first program. The program example_2.py demonstrates this simple concurrency and is listed below: Python 1 import queue 2 3 def task ( name , queue ): 4 while not queue . empty (): 5 count = queue . get () 6 total = 0 7 print ( f "Task { name } running" ) 8 for x in range ( count ): 9 total += 1 10 yield 11 print ( f "Task { name } total: { total } " ) 12 13 def main (): 14 """ 15 This is the main entry point for the program 16 """ 17 # Create the queue of work 18 work_queue = queue . Queue () 19 20 # Put some work in the queue 21 for work in [ 15 , 10 , 5 , 2 ]: 22 work_queue . put ( work ) 23 24 # Create some tasks 25 tasks = [ task ( "One" , work_queue ), task ( "Two" , work_queue )] 26 27 # Run the tasks 28 done = False 29 while not done : 30 for t in tasks : 31 try : 32 next ( t ) 33 except StopIteration : 34 tasks . remove ( t ) 35 if len ( tasks ) == 0 : 36 done = True 37 38 if __name__ == "__main__" : 39 main () Here‚Äôs what‚Äôs happening in the code above: Lines 3 to 11 define task() as before, but the addition of yield on Line 10 turns the function into a generator. This where the context switch is made and control is handed back to the while loop in main() . Line 25 creates the task list, but in a slightly different manner than you saw in the previous example code. In this case, each task is called with its parameters as its entered in the tasks list variable. This is necessary to get the task() generator function running the first time. Lines 31 to 36 are the modifications to the while loop in main() that allow task() to run cooperatively. This is where control returns to each instance of task() when it yields, allowing the loop to continue and run another task. Line 32 gives control back to task() , and continues its execution after the point where yield was called. Line 36 sets the done variable. The while loop ends when all tasks have been completed and removed from tasks . This is the output produced when you run this program: Shell Task One running Task Two running Task Two total: 10 Task Two running Task One total: 15 Task One running Task Two total: 5 Task One total: 2 You can see that both Task One and Task Two are running and consuming work from the queue. This is what‚Äôs intended, as both tasks are processing work, and each is responsible for two items in the queue. This is interesting, but again, it takes quite a bit of work to achieve these results. The trick here is using the yield statement, which turns task() into a generator and performs a context switch. The program uses this context switch to give control to the while loop in main() , allowing two instances of a task to run cooperatively. Notice how Task Two outputs its total first. This might lead you to think that the tasks are running asynchronously. However, this is still a synchronous program. It‚Äôs structured so the two tasks can trade contexts back and forth. The reason why Task Two outputs its total first is that it‚Äôs only counting to 10, while Task One is counting to 15. Task Two simply arrives at its total first, so it gets to print its output to the console before Task One . Note: All of the example code that follows from this point use a module called codetiming to time and output how long sections of code took to execute. There is a great article here on RealPython that goes into depth about the codetiming module and how to use it. This module is part of the Python Package Index and is built by Geir Arne Hjelle , who is part of the Real Python team. Geir Arne has been a great help to me reviewing and suggesting things for this article. If you are writing code that needs to include timing functionality, Geir Arne‚Äôs codetiming module is well worth looking at. To make the codetiming module available for the examples that follow you‚Äôll need to install it. This can be done with pip with this command: pip install codetiming , or with this command: pip install -r requirements.txt . The requirements.txt file is part of the example code repository. Remove ads Cooperative Concurrency With Blocking Calls The next version of the program is the same as the last, except for the addition of a time.sleep(delay) in the body of your task loop. This adds a delay based on the value retrieved from the work queue to every iteration of the task loop. The delay simulates the effect of a blocking call occurring in your task. A blocking call is code that stops the CPU from doing anything else for some period of time. In the thought experiments above, if a parent wasn‚Äôt able to break away from balancing the checkbook until it was complete, that would be a blocking call. time.sleep(delay) does the same thing in this example, because the CPU can‚Äôt do anything else but wait for the delay to expire. Python 1 import time 2 import queue 3 from codetiming import Timer 4 5 def task ( name , queue ): 6 timer = Timer ( text = f "Task { name } elapsed time: {{ :.1f }} " ) 7 while not queue . empty (): 8 delay = queue . get () 9 print ( f "Task { name } running" ) 10 timer . start () 11 time . sleep ( delay ) 12 timer . stop () 13 yield 14 15 def main (): 16 """ 17 This is the main entry point for the program 18 """ 19 # Create the queue of work 20 work_queue = queue . Queue () 21 22 # Put some work in the queue 23 for work in [ 15 , 10 , 5 , 2 ]: 24 work_queue . put ( work ) 25 26 tasks = [ task ( "One" , work_queue ), task ( "Two" , work_queue )] 27 28 # Run the tasks 29 done = False 30 with Timer ( text = " \n Total elapsed time: {:.1f} " ): 31 while not done : 32 for t in tasks : 33 try : 34 next ( t ) 35 except StopIteration : 36 tasks . remove ( t ) 37 if len ( tasks ) == 0 : 38 done = True 39 40 if __name__ == "__main__" : 41 main () Here‚Äôs what‚Äôs different in the code above: Line 1 imports the time module to give the program access to time.sleep() . Line 3 imports the the Timer code from the codetiming module. Line 6 creates the Timer instance used to measure the time taken for each iteration of the task loop. Line 10 starts the timer instance Line 11 changes task() to include a time.sleep(delay) to mimic an IO delay. This replaces the for loop that did the counting in example_1.py . Line 12 stops the timer instance and outputs the elapsed time since timer.start() was called. Line 30 creates a Timer context manager that will output the elapsed time the entire while loop took to execute. When you run this program, you‚Äôll see the following output: Shell Task One running Task One elapsed time: 15.0 Task Two running Task Two elapsed time: 10.0 Task One running Task One elapsed time: 5.0 Task Two running Task Two elapsed time: 2.0 Total elapsed time: 32.0 As before, both Task One and Task Two are running, consuming work from the queue and processing it. However, even with the addition of the delay, you can see that cooperative concurrency hasn‚Äôt gotten you anything. The delay stops the processing of the entire program, and the CPU just waits for the IO delay to be over. This is exactly what‚Äôs meant by blocking code in Python async documentation. You‚Äôll notice that the time it takes to run the entire program is just the cumulative time of all the delays. Running tasks this way is not a win. Cooperative Concurrency With Non-Blocking Calls The next version of the program has been modified quite a bit. It makes use of Python async features using asyncio/await provided in Python 3. The time and queue modules have been replaced with the asyncio package. This gives your program access to asynchronous friendly (non-blocking) sleep and queue functionality. The change to task() defines it as asynchronous with the addition of the async prefix on line 4. This indicates to Python that the function will be asynchronous. The other big change is removing the time.sleep(delay) and yield statements, and replacing them with await asyncio.sleep(delay) . This creates a non-blocking delay that will perform a context switch back to the caller main() . The while loop inside main() no longer exists. Instead of task_array , there‚Äôs a call to await asyncio.gather(...) . This tells asyncio two things: Create two tasks based on task() and start running them. Wait for both of these to be completed before moving forward. The last line of the program asyncio.run(main()) runs main() . This creates what‚Äôs known as an event loop ). It‚Äôs this loop that will run main() , which in turn will run the two instances of task() . The event loop is at the heart of the Python async system. It runs all the code, including main() . When task code is executing, the CPU is busy doing work. When the await keyword is reached, a context switch occurs, and control passes back to the event loop. The event loop looks at all the tasks waiting for an event (in this case, an asyncio.sleep(delay) timeout) and passes control to a task with an event that‚Äôs ready. await asyncio.sleep(delay) is non-blocking in regards to the CPU. Instead of waiting for the delay to timeout, the CPU registers a sleep event on the event loop task queue and performs a context switch by passing control to the event loop. The event loop continuously looks for completed events and passes control back to the task waiting for that event. In this way, the CPU can stay busy if work is available, while the event loop monitors the events that will happen in the future. Note: An asynchronous program runs in a single thread of execution. The context switch from one section of code to another that would affect data is completely in your control. This means you can atomize and complete all shared memory data access before making a context switch. This simplifies the shared memory problem inherent in threaded code. The example_4.py code is listed below: Python 1 import asyncio 2 from codetiming import Timer 3 4 async def task ( name , work_queue ): 5 timer = Timer ( text = f "Task { name } elapsed time: {{ :.1f }} " ) 6 while not work_queue . empty (): 7 delay = await work_queue . get () 8 print ( f "Task { name } running" ) 9 timer . start () 10 await asyncio . sleep ( delay ) 11 timer . stop () 12 13 async def main (): 14 """ 15 This is the main entry point for the program 16 """ 17 # Create the queue of work 18 work_queue = asyncio . Queue () 19 20 # Put some work in the queue 21 for work in [ 15 , 10 , 5 , 2 ]: 22 await work_queue . put ( work ) 23 24 # Run the tasks 25 with Timer ( text = " \n Total elapsed time: {:.1f} " ): 26 await asyncio . gather ( 27 asyncio . create_task ( task ( "One" , work_queue )), 28 asyncio . create_task ( task ( "Two" , work_queue )), 29 ) 30 31 if __name__ == "__main__" : 32 asyncio . run ( main ()) Here‚Äôs what‚Äôs different between this program and example_3.py : Line 1 imports asyncio to gain access to Python async functionality. This replaces the time import. Line 2 imports the the Timer code from the codetiming module. Line 4 shows the addition of the async keyword in front of the task() definition. This informs the program that task can run asynchronously. Line 5 creates the Timer instance used to measure the time taken for each iteration of the task loop. Line 9 starts the timer instance Line 10 replaces time.sleep(delay) with the non-blocking asyncio.sleep(delay) , which also yields control (or switches contexts) back to the main event loop. Line 11 stops the timer instance and outputs the elapsed time since timer.start() was called. Line 18 creates the non-blocking asynchronous work_queue . Lines 21 to 22 put work into work_queue in an asynchronous manner using the await keyword. Line 25 creates a Timer context manager that will output the elapsed time the entire while loop took to execute. Lines 26 to 29 create the two tasks and gather them together, so the program will wait for both tasks to complete. Line 32 starts the program running asynchronously. It also starts the internal event loop. When you look at the output of this program, notice how both Task One and Task Two start at the same time, then wait at the mock IO call: Shell Task One running Task Two running Task Two total elapsed time: 10.0 Task Two running Task One total elapsed time: 15.0 Task One running Task Two total elapsed time: 5.0 Task One total elapsed time: 2.0 Total elapsed time: 17.0 This indicates that await asyncio.sleep(delay) is non-blocking, and that other work is being done. At the end of the program, you‚Äôll notice the total elapsed time is essentially half the time it took for example_3.py to run. That‚Äôs the advantage of a program that uses Python async features! Each task was able to run await asyncio.sleep(delay) at the same time. The total execution time of the program is now less than the sum of its parts. You‚Äôve broken away from the synchronous model! Remove ads Synchronous (Blocking) HTTP Calls The next version of the program is kind of a step forward as well as a step back. The program is doing some actual work with real IO by making HTTP requests to a list of URLs and getting the page contents. However, it‚Äôs doing so in a blocking (synchronous) manner. The program has been modified to import the wonderful requests module to make the actual HTTP requests. Also, the queue now contains a list of URLs, rather than numbers. In addition, task() no longer increments a counter. Instead, requests gets the contents of a URL retrieved from the queue, and prints how long it took to do so. The example_5.py code is listed below: Python 1 import queue 2 import requests 3 from codetiming import Timer 4 5 def task ( name , work_queue ): 6 timer = Timer ( text = f "Task { name } elapsed time: {{ :.1f }} " ) 7 with requests . Session () as session : 8 while not work_queue . empty (): 9 url = work_queue . get () 10 print ( f "Task { name } getting URL: { url } " ) 11 timer . start () 12 session . get ( url ) 13 timer . stop () 14 yield 15 16 def main (): 17 """ 18 This is the main entry point for the program 19 """ 20 # Create the queue of work 21 work_queue = queue . Queue () 22 23 # Put some work in the queue 24 for url in [ 25 "http://google.com" , 26 "http://yahoo.com" , 27 "http://linkedin.com" , 28 "http://apple.com" , 29 "http://microsoft.com" , 30 "http://facebook.com" , 31 "http://twitter.com" , 32 ]: 33 work_queue . put ( url ) 34 35 tasks = [ task ( "One" , work_queue ), task ( "Two" , work_queue )] 36 37 # Run the tasks 38 done = False 39 with Timer ( text = " \n Total elapsed time: {:.1f} " ): 40 while not done : 41 for t in tasks : 42 try : 43 next ( t ) 44 except StopIteration : 45 tasks . remove ( t ) 46 if len ( tasks ) == 0 : 47 done = True 48 49 if __name__ == "__main__" : 50 main () Here‚Äôs what‚Äôs happening in this program: Line 2 imports requests , which provides a convenient way to make HTTP calls. Line 3 imports the the Timer code from the codetiming module. Line 6 creates the Timer instance used to measure the time taken for each iteration of the task loop. Line 11 starts the timer instance Line 12 introduces a delay, similar to example_3.py . However, this time it calls session.get(url) , which returns the contents of the URL retrieved from work_queue . Line 13 stops the timer instance and outputs the elapsed time since timer.start() was called. Lines 23 to 32 put the list of URLs into work_queue . Line 39 creates a Timer context manager that will output the elapsed time the entire while loop took to execute. When you run this program, you‚Äôll see the following output: Shell Task One getting URL: http://google.com Task One total elapsed time: 0.3 Task Two getting URL: http://yahoo.com Task Two total elapsed time: 0.8 Task One getting URL: http://linkedin.com Task One total elapsed time: 0.4 Task Two getting URL: http://apple.com Task Two total elapsed time: 0.3 Task One getting URL: http://microsoft.com Task One total elapsed time: 0.5 Task Two getting URL: http://facebook.com Task Two total elapsed time: 0.5 Task One getting URL: http://twitter.com Task One total elapsed time: 0.4 Total elapsed time: 3.2 Just like in earlier versions of the program, yield turns task() into a generator. It also performs a context switch that lets the other task instance run. Each task gets a URL from the work queue, retrieves the contents of the page, and reports how long it took to get that content. As before, yield allows both your tasks to run cooperatively. However, since this program is running synchronously, each session.get() call blocks the CPU until the page is retrieved. Note the total time it took to run the entire program at the end. This will be meaningful for the next example. Asynchronous (Non-Blocking) HTTP Calls This version of the program modifies the previous one to use Python async features. It also imports the aiohttp module, which is a library to make HTTP requests in an asynchronous fashion using asyncio . The tasks here have been modified to remove the yield call since the code to make the HTTP GET call is no longer blocking. It also performs a context switch back to the event loop. The example_6.py program is listed below: Python 1 import asyncio 2 import aiohttp 3 from codetiming import Timer 4 5 async def task ( name , work_queue ): 6 timer = Timer ( text = f "Task { name } elapsed time: {{ :.1f }} " ) 7 async with aiohttp . ClientSession () as session : 8 while not work_queue . empty (): 9 url = await work_queue . get () 10 print ( f "Task { name } getting URL: { url } " ) 11 timer . start () 12 async with session . get ( url ) as response : 13 await response . text () 14 timer . stop () 15 16 async def main (): 17 """ 18 This is the main entry point for the program 19 """ 20 # Create the queue of work 21 work_queue = asyncio . Queue () 22 23 # Put some work in the queue 24 for url in [ 25 "http://google.com" , 26 "http://yahoo.com" , 27 "http://linkedin.com" , 28 "http://apple.com" , 29 "http://microsoft.com" , 30 "http://facebook.com" , 31 "http://twitter.com" , 32 ]: 33 await work_queue . put ( url ) 34 35 # Run the tasks 36 with Timer ( text = " \n Total elapsed time: {:.1f} " ): 37 await asyncio . gather ( 38 asyncio . create_task ( task ( "One" , work_queue )), 39 asyncio . create_task ( task ( "Two" , work_queue )), 40 ) 41 42 if __name__ == "__main__" : 43 asyncio . run ( main ()) Here‚Äôs what‚Äôs happening in this program: Line 2 imports the aiohttp library, which provides an asynchronous way to make HTTP calls. Line 3 imports the the Timer code from the codetiming module. Line 5 marks task() as an asynchronous function. Line 6 creates the Timer instance used to measure the time taken for each iteration of the task loop. Line 7 creates an aiohttp session context manager. Line 8 creates an aiohttp response context manager. It also makes an HTTP GET call to the URL taken from work_queue . Line 11 starts the timer instance Line 12 uses the session to get the text retrieved from the URL asynchronously. Line 13 stops the timer instance and outputs the elapsed time since timer.start() was called. Line 39 creates a Timer context manager that will output the elapsed time the entire while loop took to execute. When you run this program, you‚Äôll see the following output: Shell Task One getting URL: http://google.com Task Two getting URL: http://yahoo.com Task One total elapsed time: 0.3 Task One getting URL: http://linkedin.com Task One total elapsed time: 0.3 Task One getting URL: http://apple.com Task One total elapsed time: 0.3 Task One getting URL: http://microsoft.com Task Two total elapsed time: 0.9 Task Two getting URL: http://facebook.com Task Two total elapsed time: 0.4 Task Two getting URL: http://twitter.com Task One total elapsed time: 0.5 Task Two total elapsed time: 0.3 Total elapsed time: 1.7 Take a look at the total elapsed time, as well as the individual times to get the contents of each URL. You‚Äôll see that the duration is about half the cumulative time of all the HTTP GET calls. This is because the HTTP GET calls are running asynchronously. In other words, you‚Äôre effectively taking better advantage of the CPU by allowing it to make multiple requests at once. Because the CPU is so fast, this example could likely create as many tasks as there are URLs. In this case, the program‚Äôs run time would be that of the single slowest URL retrieval. Remove ads Conclusion This article has given you the tools you need to start making asynchronous programming techniques a part of your repertoire. Using Python async features gives you programmatic control of when context switches take place. This means that many of the tougher issues you might see in threaded programming are easier to deal with. Asynchronous programming is a powerful tool, but it isn‚Äôt useful for every kind of program. If you‚Äôre writing a program that calculates pi to the millionth decimal place, for instance, then asynchronous code won‚Äôt help you. That kind of program is CPU bound, without much IO. However, if you‚Äôre trying to implement a server or a program that performs IO (like file or network access), then using Python async features could make a huge difference. To sum it up, you‚Äôve learned: What synchronous programs are How asynchronous programs are different, but also powerful and manageable Why you might want to write asynchronous programs How to use the built-in async features in Python You can get the code for all of the example programs used in this tutorial: Download Code: Click here to download the code you‚Äôll use to learn about async features in Python in this tutorial. Now that you‚Äôre equipped with these powerful skills, you can take your programs to the next level! Take the Quiz: Test your knowledge with our interactive ‚ÄúGetting Started With Async Features in Python‚Äù quiz. You‚Äôll receive a score upon completion to help you track your learning progress: Interactive Quiz Getting Started With Async Features in Python In this quiz, you'll test your understanding of asynchronous programming in Python. You'll revisit the concepts of synchronous and asynchronous programs, and why you might want to write an asynchronous program. You'll also test your knowledge on how to use Python async features. Mark as Completed Share üêç Python Tricks üíå Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team. Send Me Python Tricks ¬ª About Doug Farrell Doug is a Python developer with more than 25 years of experience. He writes about Python on his personal website and works as a Senior Web Engineer with Shutterfly. ¬ª More about Doug Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are: Aldren Brad Geir Arne Jaya Joanna Master Real-World Python Skills With Unlimited Access to Real Python Join us and get access to thousands of tutorials, hands-on video courses, and a community of expert Pythonistas: Level Up Your Python Skills ¬ª Master Real-World Python Skills With Unlimited Access to Real Python Join us and get access to thousands of tutorials, hands-on video courses, and a community of expert Pythonistas: Level Up Your Python Skills ¬ª What Do You Think? Rate this article: LinkedIn Twitter Bluesky Facebook Email What‚Äôs your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know. Commenting Tips: The most useful comments are those written with the goal of learning from or helping out other students. Get tips for asking good questions and get answers to common questions in our support portal . Looking for a real-time conversation? Visit the Real Python Community Chat or join the next ‚ÄúOffice Hours‚Äù Live Q&A Session . Happy Pythoning! Keep Learning Related Topics: intermediate python Related Tutorials: Python's asyncio: A Hands-On Walkthrough Speed Up Your Python Program With Concurrency Asynchronous Iterators and Iterables in Python Using FastAPI to Build Python Web APIs Iterators and Iterables in Python: Run Efficient Iterations Keep reading Real Python by creating a free account or signing in: Continue ¬ª Already have an account? Sign-In Almost there! Complete this form and click the button below to gain instant access: √ó Async Features in Python (Code) Send Code ¬ª üîí No spam. We take your privacy seriously. Learn Python Start Here Learning Resources Code Mentor Python Reference Python Cheat Sheet Support Center Courses & Paths Learning Paths Quizzes & Exercises Browse Topics Workshops Books Community Podcast Newsletter Community Chat Office Hours Learner Stories Membership Plans & Pricing Team Plans For Business For Schools Reviews Company About Us Team Mission & Values Sponsorships Careers Press Kit Merch Privacy Policy ‚ãÖ Terms of Use ‚ãÖ Security ‚ãÖ Contact Happy Pythoning! ¬© 2012‚Äì2025 DevCademy Media Inc. DBA Real Python. All rights reserved. REALPYTHON‚Ñ¢ is a trademark of DevCademy Media Inc. Free Bonus: Python Cheat Sheet √ó Get a Python Cheat Sheet (PDF) and learn the basics of Python, like working with data types, dictionaries, lists, and Python functions: Send My Python Cheat Sheet ¬ª

**Confidence**: 0.80

### Finding 2

Finding from Python async - GeeksforGeeks: Python async - GeeksforGeeks Skip to content Tutorials Python Java DSA ML & Data Science Interview Corner Programming Languages Web Development CS Subjects DevOps Software and Tools School Learning Practice Coding Problems Courses DSA / Placements ML & Data Science Development Cloud / DevOps Programming Languages All Courses Tracks Languages Python C C++ Java Advanced Java SQL JavaScript Interview Preparation GfG 160 GfG 360 System Design Core Subjects Interview Questions Interview Puzzles Aptitude and Reasoning Data Science Python Data Analytics Complete Data Science Dev Skills Full-Stack Web Dev DevOps Software Testing CyberSecurity Tools Computer Fundamentals AI Tools MS Excel & Google Sheets MS Word & Google Docs Maths Maths For Computer Science Engineering Mathematics Python Tutorial Data Types Interview Questions Examples Quizzes DSA Python Data Science NumPy Pandas Practice Django Flask Projects Sign In ‚ñ≤ Open In App Python async Last Updated : 23 Jul, 2025 Comments Improve Suggest changes 4 Likes Like Report async keyword in Python is used to define asynchronous functions , which allow tasks to run without blocking the execution of other code. It is commonly used for handling tasks like network requests, database operations or file I/O, where waiting for one task to finish would normally slow down the entire program. Async relies on await because an async function does not execute asynchronously on its own, it needs await to actually pause and resume tasks. To use async in our code, we need to first import the asyncio library, to know about it in detail, refer to asyncio in Python . Let's consider an example. Python import asyncio async def func (): print ( "Hello!" ) await asyncio . sleep ( 2 ) # Pause for 2 second without blocking print ( "Geeks for Geeks" ) # asyncio . run ( func ()) Output Hello! Geeks for Geeks Explanation: "async" keyword before " def" keyword defines the function func as an asynchronous function. " await asyncio.sleep(2) " makes it wait for 2 second before continuing. that's why when the function is called using " asyncio.run(gree()) ", the second print statement gets executed after a delay of 2 seconds. Syntax: async def function_name(): await some_async_function() async def: defines an asynchronous function. await: pauses execution until the awaited function completes. Let's see some of the use cases of the async with examples. Running Multiple Tasks Simultaneously With the help of async , multiple tasks can run without waiting for one to finish before starting another. Python import asyncio async def task1 (): print ( "Task 1 started" ) await asyncio . sleep ( 3 ) print ( "Task 1 finished" ) async def task2 (): print ( "Task 2 started" ) await asyncio . sleep ( 1 ) print ( "Task 2 finished" ) async def main (): await asyncio . gather ( task1 (), task2 ()) # Runs both tasks together asyncio . run ( main ()) Output Task 1 started Task 2 started Task 2 finished Task 1 finished Explanation: in this code, task1() and task2() run at the same time becasue they are defined as async functions. task2() completes first because it waits for only 1 second, while task1() waits for 3 seconds. Using Async with HTTP Requests It is a very common practice to use async keyword with HTTP requests , if we fetch data from multiple URLs using a synchronous approach, each request blocks the execution until it completes. However, with async, we can send multiple requests simultaneously, making the program much faster. Here's an example: Python import aiohttp import asyncio async def func (): async with aiohttp . ClientSession () as session : async with session . get ( "https://example.com/" ) as res : data = await res . text () print ( data [: 100 ]) # Prints first 100 characters asyncio . run ( func ()) Output <!doctype html> <html> <head> <title>Example Domain</title> <meta charset="utf-8" /> <m Explanation: In this code we have defined an asynchronous function that performs an HTTP request using the async keyword, the breakdown of code is such: aiohttp library is used for making async HTTP requests. aiohttp.ClientSession(), creates HTTP session and making an asynchronous get request using session.get(). await keyword ensures that the request completes before proceeding to the next step. data[:100] ensure that only first 100 characters are printed. Note: Ensure that "aiohttp" library is installed on your system before running the code. If it's mot installed, you can add it by running "pip install aiohttp" command in the terminal Using Async with File I/O Python by default handles files one at a time, making the program wait until the task is done. But async can also be used for file operations. While writing and reading files, we can simulate async behavior using asyncio.sleep() to represent delays, similar to real-world scenarios where I/O operations take time. Here's an example: Python import asyncio import aiofiles import asyncio async def write (): async with aiofiles . open ( r "paste_your_file_path_here\file.txt" , "w" ) as f : await f . write ( "Hello from Geeks for Geeks!" ) async def read (): async with aiofiles . open ( r "paste_your_file_path_here\file.txt" , "r" ) as f : print ( await f . read ()) asyncio . run ( write ()) asyncio . run ( read ()) Output Hello from Geeks for Geeks! Explanation: write_file () writes data to " file.txt " if it already exists in the specified path. If the file doesn't exist, it automatically creates a new " file.txt " and writes data to it. read_file () opens "file.txt" in read mode and prints its content asynchronously. If the file doesn‚Äôt exist, it will raise a FileNotFoundError . asyncio.run(write()) runs first, making sure the file is created and written. Then, asyncio.run(read()) runs, reading and printing the content. To learn about file-handling in Python in detail, refer to- File Handling In Python Comment P prajjqv52 Follow 4 Improve P prajjqv52 Follow 4 Improve Article Tags : Python python-basics Explore Python Fundamentals Python Introduction 2 min read Input and Output in Python 4 min read Python Variables 5 min read Python Operators 4 min read Python Keywords 2 min read Python Data Types 8 min read Conditional Statements in Python 3 min read Loops in Python - For, While and Nested Loops 5 min read Python Functions 5 min read Recursion in Python 4 min read Python Lambda Functions 5 min read Python Data Structures Python String 5 min read Python Lists 4 min read Python Tuples 4 min read Python Dictionary 3 min read Python Sets 6 min read Python Arrays 7 min read List Comprehension in Python 4 min read Advanced Python Python OOP Concepts 11 min read Python Exception Handling 5 min read File Handling in Python 4 min read Python Database Tutorial 4 min read Python MongoDB Tutorial 2 min read Python MySQL 9 min read Python Packages 10 min read Python Modules 7 min read Python DSA Libraries 15 min read List of Python GUI Library and Packages 3 min read Data Science with Python NumPy Tutorial - Python Library 3 min read Pandas Tutorial 4 min read Matplotlib Tutorial 5 min read Python Seaborn Tutorial 15+ min read StatsModel Library- Tutorial 4 min read Learning Model Building in Scikit-learn 8 min read TensorFlow Tutorial 2 min read PyTorch Tutorial 6 min read Web Development with Python Flask Tutorial 8 min read Django Tutorial | Learn Django Framework 7 min read Django ORM - Inserting, Updating & Deleting Data 4 min read Templating With Jinja2 in Flask 6 min read Django Templates 7 min read Python | Build a REST API using Flask 3 min read How to Create a basic API using Django Rest Framework ? 4 min read Python Practice Python Quiz 1 min read Python Coding Practice 1 min read Python Interview Questions and Answers 15+ min read Like Corporate & Communications Address: A-143, 7th Floor, Sovereign Corporate Tower, Sector- 136, Noida, Uttar Pradesh (201305) Registered Address: K 061, Tower K, Gulshan Vivante Apartment, Sector 137, Noida, Gautam Buddh Nagar, Uttar Pradesh, 201305 Company About Us Legal Privacy Policy Contact Us Advertise with us GFG Corporate Solution Campus Training Program Explore POTD Job-A-Thon Blogs Nation Skill Up Tutorials Programming Languages DSA Web Technology AI, ML & Data Science DevOps CS Core Subjects Interview Preparation Software and Tools Courses IBM Certification DSA and Placements Web Development Programming Languages DevOps & Cloud GATE Trending Technologies Videos DSA Python Java C++ Web Development Data Science CS Subjects Preparation Corner Interview Corner Aptitude Puzzles GfG 160 System Design @GeeksforGeeks, Sanchhaya Education Private Limited , All rights reserved Improvement Suggest changes Suggest Changes Help us improve. Share your suggestions to enhance the article. Contribute your expertise and make a difference in the GeeksforGeeks portal. Create Improvement Enhance the article with your expertise. Contribute to the GeeksforGeeks community and help create better learning resources for all. Suggest Changes min 4 words, max Words Limit:1000 Thank You! Your suggestions are valuable to us. What kind of Experience do you want to share? Interview Experiences Admission Experiences Career Journeys Work Experiences Campus Experiences Competitive Exam Experiences

**Confidence**: 0.80

### Finding 3

Finding from asyncio ‚Äî Asynchronous I/O ‚Äî Python 3.14.0 documentation: asyncio ‚Äî Asynchronous I/O ‚Äî Python 3.14.0 documentation Theme Auto Light Dark Previous topic Networking and Interprocess Communication Next topic Runners This page Report a bug Show source Navigation index modules | next | previous | Python ¬ª 3.14.0 Documentation ¬ª The Python Standard Library ¬ª Networking and Interprocess Communication ¬ª asyncio ‚Äî Asynchronous I/O | Theme Auto Light Dark | asyncio ‚Äî Asynchronous I/O ¬∂ Hello World! import asyncio async def main (): print ( 'Hello ...' ) await asyncio . sleep ( 1 ) print ( '... World!' ) asyncio . run ( main ()) asyncio is a library to write concurrent code using the async/await syntax. asyncio is used as a foundation for multiple Python asynchronous frameworks that provide high-performance network and web-servers, database connection libraries, distributed task queues, etc. asyncio is often a perfect fit for IO-bound and high-level structured network code. See also A Conceptual Overview of asyncio Explanation of the fundamentals of asyncio. asyncio provides a set of high-level APIs to: run Python coroutines concurrently and have full control over their execution; perform network IO and IPC ; control subprocesses ; distribute tasks via queues ; synchronize concurrent code; Additionally, there are low-level APIs for library and framework developers to: create and manage event loops , which provide asynchronous APIs for networking , running subprocesses , handling OS signals , etc; implement efficient protocols using transports ; bridge callback-based libraries and code with async/await syntax. Availability : not WASI. This module does not work or is not available on WebAssembly. See WebAssembly platforms for more information. asyncio REPL You can experiment with an asyncio concurrent context in the REPL : $ python -m asyncio asyncio REPL ... Use "await" directly instead of "asyncio.run()". Type "help", "copyright", "credits" or "license" for more information. >>> import asyncio >>> await asyncio . sleep ( 10 , result = 'hello' ) 'hello' Raises an auditing event cpython.run_stdin with no arguments. Changed in version 3.12.5: (also 3.11.10, 3.10.15, 3.9.20, and 3.8.20) Emits audit events. Changed in version 3.13: Uses PyREPL if possible, in which case PYTHONSTARTUP is also executed. Emits audit events. Reference High-level APIs Runners Coroutines and Tasks Streams Synchronization Primitives Subprocesses Queues Exceptions Call Graph Introspection Low-level APIs Event Loop Futures Transports and Protocols Policies Platform Support Extending Guides and Tutorials High-level API Index Low-level API Index Developing with asyncio Note The source code for asyncio can be found in Lib/asyncio/ . Previous topic Networking and Interprocess Communication Next topic Runners This page Report a bug Show source ¬´ Navigation index modules | next | previous | Python ¬ª 3.14.0 Documentation ¬ª The Python Standard Library ¬ª Networking and Interprocess Communication ¬ª asyncio ‚Äî Asynchronous I/O | Theme Auto Light Dark | ¬© Copyright 2001 Python Software Foundation. This page is licensed under the Python Software Foundation License Version 2. Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License. See History and License for more information. The Python Software Foundation is a non-profit corporation. Please donate. Last updated on Oct 22, 2025 (06:06 UTC). Found a bug ? Created using Sphinx 8.2.3.

**Confidence**: 0.80

## Sources

1. [Getting Started With Async Features in Python](https://realpython.com/python-async-features/) - Relevance: 0.80
   > Learn how to use Python async features to write asynchronous programs that can handle multiple IO operations at once. Explore the difference between synchronous and asynchronous programming , and see how to use cooperative concurrency, blocking and non-blocking calls, and HTTP calls.

2. [Python async - GeeksforGeeks](https://www.geeksforgeeks.org/python/python-async/) - Relevance: 0.80
   > Python async enables asynchronous programming in Python , allowing efficient execution of tasks like I/O operations and concurrency for improved performance.

3. [asyncio ‚Äî Asynchronous I/O ‚Äî Python 3.14.0 documentation](https://docs.python.org/3/library/asyncio.html) - Relevance: 0.80
   > Hello World!: asyncio is a library to write concurrent code using the async /await syntax. asyncio is used as a foundation for multiple Python asynchronous frameworks that provide high-performance n...

