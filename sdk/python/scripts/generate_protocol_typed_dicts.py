#!/usr/bin/env python3
from __future__ import annotations

import json
from pathlib import Path


ROOT = Path(__file__).resolve().parents[3]
SCHEMA_DIR = ROOT / "codex-rs" / "app-server-protocol" / "schema" / "json" / "v2"
OUT = ROOT / "sdk" / "python" / "src" / "codex_app_server" / "protocol_types.py"


def load(name: str) -> dict:
    return json.loads((SCHEMA_DIR / f"{name}.json").read_text())


def object_props(schema: dict, node: dict) -> tuple[dict, set[str]]:
    if "$ref" in node:
        ref = node["$ref"]
        if ref.startswith("#/definitions/"):
            key = ref.split("/")[-1]
            return object_props(schema, schema["definitions"][key])
        raise ValueError(f"unsupported ref: {ref}")
    props = node.get("properties", {})
    req = set(node.get("required", []))
    return props, req


def field_type(v: dict) -> str:
    if "$ref" in v:
        ref = v["$ref"]
        if ref.endswith("Thread"):
            return "ThreadObject"
        if ref.endswith("Turn"):
            return "TurnObject"
        return "dict[str, Any]"
    t = v.get("type")
    if t == "string":
        return "str"
    if t == "integer":
        return "int"
    if t == "boolean":
        return "bool"
    if t == "array":
        return "list[dict[str, Any]]"
    if isinstance(t, list) and "null" in t and "string" in t:
        return "str | None"
    return "dict[str, Any]"


def render_typed_dict(name: str, props: dict, req: set[str]) -> str:
    lines = [f"class {name}(TypedDict):"]
    if not props:
        lines.append("    pass")
        return "\n".join(lines)
    for k, v in props.items():
        t = field_type(v)
        if k in req:
            lines.append(f"    {k}: {t}")
        else:
            lines.append(f"    {k}: NotRequired[{t}]")
    return "\n".join(lines)


def main() -> None:
    tsr = load("ThreadStartResponse")
    trr = load("ThreadResumeResponse")
    tlr = load("ThreadListResponse")
    trd = load("ThreadReadResponse")
    turs = load("TurnStartResponse")

    thread_props, thread_req = object_props(tsr, tsr["definitions"].get("Thread", {}))
    turn_props, turn_req = object_props(turs, turs["definitions"].get("Turn", {}))

    root_props = {
        "ThreadStartResponse": object_props(tsr, tsr),
        "ThreadResumeResponse": object_props(trr, trr),
        "ThreadListResponse": object_props(tlr, tlr),
        "ThreadReadResponse": object_props(trd, trd),
        "TurnStartResponse": object_props(turs, turs),
    }

    parts = [
        "from __future__ import annotations",
        "",
        "from typing import Any, NotRequired, TypedDict",
        "",
        "# Generated by scripts/generate_protocol_typed_dicts.py",
        "",
        render_typed_dict("ThreadObject", thread_props, thread_req),
        "",
        render_typed_dict("TurnObject", turn_props, turn_req),
        "",
    ]

    for name, (props, req) in root_props.items():
        parts.append(render_typed_dict(name, props, req))
        parts.append("")

    # Notification params shape used heavily by the SDK helper code.
    parts.append("class TurnCompletedNotificationParams(TypedDict):")
    parts.append("    threadId: str")
    parts.append("    turn: TurnObject")
    parts.append("")

    OUT.write_text("\n".join(parts))
    print(f"wrote {OUT}")


if __name__ == "__main__":
    main()
