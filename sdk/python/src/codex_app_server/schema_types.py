# Auto-generated by scripts/generate_types_from_schema.py
# DO NOT EDIT MANUALLY.

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, TypedDict

class ThreadDict(TypedDict, total=False):
    cliVersion: str
    createdAt: int
    cwd: str
    gitInfo: Any | None
    id: str
    modelProvider: str
    path: str | None
    preview: str
    source: Any
    turns: list[Turn]
    updatedAt: int

@dataclass(slots=True, kw_only=True)
class Thread:
    cliVersion: str
    createdAt: int
    cwd: str
    gitInfo: Any | None = None
    id: str
    modelProvider: str
    path: str | None = None
    preview: str
    source: Any
    turns: list[Turn] = None
    updatedAt: int

    @classmethod
    def from_dict(cls, payload: dict[str, Any]) -> "Thread":
        payload = payload or {}
        return cls(
            cliVersion=str(payload.get("cliVersion", None) or ""),
            createdAt=int(payload.get("createdAt", None) or 0),
            cwd=str(payload.get("cwd", None) or ""),
            gitInfo=payload.get("gitInfo"),
            id=str(payload.get("id", None) or ""),
            modelProvider=str(payload.get("modelProvider", None) or ""),
            path=None if payload.get("path") is None else str(payload.get("path")),
            preview=str(payload.get("preview", None) or ""),
            source=payload.get("source", None),
            turns=list(payload.get("turns", []) or []),
            updatedAt=int(payload.get("updatedAt", None) or 0),
        )


class TurnDict(TypedDict, total=False):
    error: Any | None
    id: str
    items: list[Any]
    status: str

@dataclass(slots=True, kw_only=True)
class Turn:
    error: Any | None = None
    id: str
    items: list[Any] = None
    status: str

    @classmethod
    def from_dict(cls, payload: dict[str, Any]) -> "Turn":
        payload = payload or {}
        return cls(
            error=payload.get("error"),
            id=str(payload.get("id", None) or ""),
            items=list(payload.get("items", []) or []),
            status=str(payload.get("status", None) or ""),
        )


class ThreadStartResponseDict(TypedDict, total=False):
    approvalPolicy: str
    cwd: str
    model: str
    modelProvider: str
    reasoningEffort: str | None
    sandbox: Any
    thread: Thread

@dataclass(slots=True, kw_only=True)
class ThreadStartResponse:
    approvalPolicy: str
    cwd: str
    model: str
    modelProvider: str
    reasoningEffort: str | None = None
    sandbox: Any
    thread: Thread

    @classmethod
    def from_dict(cls, payload: dict[str, Any]) -> "ThreadStartResponse":
        payload = payload or {}
        return cls(
            approvalPolicy=str(payload.get("approvalPolicy", None) or ""),
            cwd=str(payload.get("cwd", None) or ""),
            model=str(payload.get("model", None) or ""),
            modelProvider=str(payload.get("modelProvider", None) or ""),
            reasoningEffort=None if payload.get("reasoningEffort") is None else str(payload.get("reasoningEffort")),
            sandbox=payload.get("sandbox", None),
            thread=Thread.from_dict(payload.get("thread") or {}),
        )


class TurnStartResponseDict(TypedDict, total=False):
    turn: Turn

@dataclass(slots=True, kw_only=True)
class TurnStartResponse:
    turn: Turn

    @classmethod
    def from_dict(cls, payload: dict[str, Any]) -> "TurnStartResponse":
        payload = payload or {}
        return cls(
            turn=Turn.from_dict(payload.get("turn") or {}),
        )


class ThreadListResponseDict(TypedDict, total=False):
    data: list[Thread]
    nextCursor: str | None

@dataclass(slots=True, kw_only=True)
class ThreadListResponse:
    data: list[Thread] = None
    nextCursor: str | None = None

    @classmethod
    def from_dict(cls, payload: dict[str, Any]) -> "ThreadListResponse":
        payload = payload or {}
        return cls(
            data=[Thread.from_dict(item or {}) for item in (payload.get("data") or [])],
            nextCursor=None if payload.get("nextCursor") is None else str(payload.get("nextCursor")),
        )


class TurnCompletedNotificationPayloadDict(TypedDict, total=False):
    threadId: str
    turn: Turn

@dataclass(slots=True, kw_only=True)
class TurnCompletedNotificationPayload:
    threadId: str
    turn: Turn

    @classmethod
    def from_dict(cls, payload: dict[str, Any]) -> "TurnCompletedNotificationPayload":
        payload = payload or {}
        return cls(
            threadId=str(payload.get("threadId", None) or ""),
            turn=Turn.from_dict(payload.get("turn") or {}),
        )


__all__ = [
    "Thread",
    "Turn",
    "ThreadStartResponse",
    "TurnStartResponse",
    "ThreadListResponse",
    "TurnCompletedNotificationPayload",
    "ThreadDict",
    "TurnDict",
    "ThreadStartResponseDict",
    "TurnStartResponseDict",
    "ThreadListResponseDict",
    "TurnCompletedNotificationPayloadDict",
]
