# 📋 要件定義書に基づく実装計画

**作成日時**: 2025-10-11 18:30 JST  
**参照文書**: REQ-SPEC-001  
**Status**: ✅ **実装計画確定**

---

## 📊 現状分析

### 実装済み機能（✅）

#### サブエージェント機構
- **FR-SA-001**: エージェント定義（YAML） ✅
- **FR-SA-002**: delegate コマンド ✅（シミュレーション）
- **FR-SA-004**: エージェント種類（7種） ✅（定義のみ）

#### Deep Research機能
- **FR-DR-001**: research コマンド ✅
- **FR-DR-002**: Web検索統合 ✅（DuckDuckGo完了）
- **FR-DR-003**: 多段階探索 ✅
- **FR-DR-004**: 矛盾検出 ✅
- **FR-DR-005**: 引用管理 ✅
- **FR-DR-006**: レポート生成 ✅

---

### 未実装機能（🚧）

#### 🔴 Critical優先度
1. **FR-SA-003**: Agent Runtime
2. **FR-SA-005**: 権限管理

#### 🟡 High優先度
3. **FR-SA-006**: トークンバジェット管理
4. **FR-CM-001**: 対話モード統合
5. **FR-CM-002**: MCPツール統合
6. **FR-CM-003**: ログ・監査

---

## 🎯 実装計画

### Phase 1: Agent Runtime基盤（2週間）

**目標**: FR-SA-003 Agent Runtime 実装

#### タスク1-1: データ構造定義（2日）

**ファイル**: `codex-rs/core/src/agent_runtime.rs`

```rust
use anyhow::Result;
use std::collections::HashMap;
use tokio::time::{timeout, Duration};

/// エージェント実行環境
pub struct AgentRuntime {
    pub agent_def: AgentDefinition,
    pub budget: TokenBudget,
    pub permissions: PermissionSet,
    pub executor: TaskExecutor,
}

impl AgentRuntime {
    /// 新しいAgentRuntimeを作成
    pub fn new(
        agent_def: AgentDefinition,
        budget: TokenBudget,
        permissions: PermissionSet,
        executor: TaskExecutor,
    ) -> Result<Self> {
        Ok(Self {
            agent_def,
            budget,
            permissions,
            executor,
        })
    }

    /// タスクを実行
    pub async fn execute_task(
        &mut self,
        goal: &str,
        inputs: &HashMap<String, String>,
    ) -> Result<AgentExecutionResult> {
        // 1. バジェットチェック
        if !self.budget.check_available(1000) {
            return Err(anyhow::anyhow!("Insufficient token budget"));
        }

        // 2. 実行時間制限付きでタスク実行
        let deadline = Duration::from_secs(
            self.agent_def.timeout_seconds.unwrap_or(300) as u64
        );
        
        let start = std::time::Instant::now();
        
        let result = timeout(deadline, self.executor.execute(goal, inputs))
            .await
            .map_err(|_| anyhow::anyhow!("Task execution timeout"))?;

        let duration = start.elapsed();

        // 3. 結果処理
        match result {
            Ok(output) => {
                self.budget.consume(output.tokens_used)?;
                
                Ok(AgentExecutionResult {
                    status: AgentExecutionStatus::Success,
                    tokens_used: output.tokens_used,
                    duration_secs: duration.as_secs_f64(),
                    artifacts: output.artifacts,
                    message: Some(output.message),
                    error: None,
                })
            }
            Err(e) => {
                Ok(AgentExecutionResult {
                    status: AgentExecutionStatus::Failed,
                    tokens_used: 0,
                    duration_secs: duration.as_secs_f64(),
                    artifacts: vec![],
                    message: None,
                    error: Some(e.to_string()),
                })
            }
        }
    }
}
```

**受入基準**:
- [ ] AgentRuntime構造体定義
- [ ] new()メソッド実装
- [ ] execute_task()メソッド実装
- [ ] 単体テスト3件以上

---

#### タスク1-2: TaskExecutor実装（3日）

**ファイル**: `codex-rs/core/src/task_executor.rs`

```rust
use anyhow::Result;
use std::collections::HashMap;

/// タスク実行結果
pub struct TaskOutput {
    pub tokens_used: usize,
    pub artifacts: Vec<String>,
    pub message: String,
}

/// タスク実行エンジン
pub struct TaskExecutor {
    // MCPクライアント、LLMクライアントなど
}

impl TaskExecutor {
    pub fn new() -> Self {
        Self {}
    }

    /// タスク実行
    pub async fn execute(
        &self,
        goal: &str,
        inputs: &HashMap<String, String>,
    ) -> Result<TaskOutput> {
        // TODO: 実際のタスク実行ロジック
        // - LLM呼び出し
        // - MCPツール使用
        // - 結果集約
        
        Ok(TaskOutput {
            tokens_used: 1000,
            artifacts: vec!["output.md".to_string()],
            message: format!("Task completed: {}", goal),
        })
    }
}
```

**受入基準**:
- [ ] TaskExecutor構造体定義
- [ ] execute()メソッド実装
- [ ] MCPツール統合
- [ ] 単体テスト5件以上

---

#### タスク1-3: delegate コマンド統合（2日）

**ファイル**: `codex-rs/cli/src/delegate_cmd.rs`

```rust
pub async fn run_delegate_command(
    agent: String,
    goal: Option<String>,
    scope: Option<PathBuf>,
    budget: Option<usize>,
    deadline: Option<u64>,
    out: Option<PathBuf>,
) -> Result<()> {
    println!("🤖 Delegating to sub-agent '{}'...", agent);

    // 1. エージェント定義読み込み
    let agent_def = load_agent_definition(&agent)?;
    
    // 2. AgentRuntime初期化
    let budget = TokenBudget::new(budget.unwrap_or(agent_def.max_tokens));
    let permissions = PermissionSet::from_agent_def(&agent_def)?;
    let executor = TaskExecutor::new();
    
    let mut runtime = AgentRuntime::new(
        agent_def,
        budget,
        permissions,
        executor,
    )?;

    // 3. タスク実行
    let mut inputs = HashMap::new();
    if let Some(scope_path) = scope {
        inputs.insert("scope".to_string(), scope_path.display().to_string());
    }

    let goal_str = goal.unwrap_or_else(|| "Perform delegated task".to_string());
    let result = runtime.execute_task(&goal_str, &inputs).await?;

    // 4. 結果表示
    println!("\n✅ Agent '{}' completed!", agent);
    println!("   Status: {:?}", result.status);
    println!("   Tokens used: {}", result.tokens_used);
    println!("   Duration: {:.2}s", result.duration_secs);

    // 5. 結果保存
    if let Some(out_path) = out {
        let report = serde_json::to_string_pretty(&result)?;
        std::fs::write(&out_path, report)?;
        println!("\n💾 Result saved to: {}", out_path.display());
    }

    Ok(())
}
```

**受入基準**:
- [ ] AgentRuntime統合
- [ ] 実際のタスク実行
- [ ] 結果表示・保存
- [ ] E2Eテスト成功

---

### Phase 2: 権限管理システム（1週間）

**目標**: FR-SA-005 権限管理 実装

#### タスク2-1: PermissionSet実装（3日）

**ファイル**: `codex-rs/core/src/permissions.rs`

```rust
use anyhow::Result;
use std::path::{Path, PathBuf};

/// 権限セット
#[derive(Debug, Clone)]
pub struct PermissionSet {
    pub file_read: FilePermission,
    pub file_write: FilePermission,
    pub shell: ShellPermission,
    pub network: NetworkPermission,
    pub mcp_tools: Vec<String>,
}

impl PermissionSet {
    /// エージェント定義から権限セット作成
    pub fn from_agent_def(agent_def: &AgentDefinition) -> Result<Self> {
        Ok(Self {
            file_read: FilePermission::from_yaml(&agent_def.permissions.file_read)?,
            file_write: FilePermission::from_yaml(&agent_def.permissions.file_write)?,
            shell: ShellPermission::from_yaml(agent_def.permissions.shell)?,
            network: NetworkPermission::from_yaml(agent_def.permissions.network)?,
            mcp_tools: agent_def.tools.clone().unwrap_or_default(),
        })
    }

    /// ファイル読み取り権限チェック
    pub fn check_file_read(&self, path: &Path) -> Result<()> {
        self.file_read.check(path)
    }

    /// ファイル書き込み権限チェック
    pub fn check_file_write(&self, path: &Path) -> Result<()> {
        self.file_write.check(path)
    }

    /// シェルコマンド実行権限チェック
    pub fn check_shell_command(&self, command: &str) -> Result<()> {
        self.shell.check(command)
    }

    /// ネットワークアクセス権限チェック
    pub fn check_network_access(&self, url: &str) -> Result<()> {
        self.network.check(url)
    }
}

/// ファイル権限
#[derive(Debug, Clone)]
pub enum FilePermission {
    None,
    ReadOnly(Vec<PathBuf>),
    ReadWrite(Vec<PathBuf>),
    Restricted(Vec<PathBuf>),
}

impl FilePermission {
    pub fn check(&self, path: &Path) -> Result<()> {
        match self {
            FilePermission::None => {
                Err(anyhow::anyhow!("File access denied"))
            }
            FilePermission::ReadOnly(allowed) => {
                if allowed.iter().any(|p| path.starts_with(p)) {
                    Ok(())
                } else {
                    Err(anyhow::anyhow!(
                        "Path not in allowed list: {}",
                        path.display()
                    ))
                }
            }
            FilePermission::ReadWrite(allowed) => {
                if allowed.iter().any(|p| path.starts_with(p)) {
                    Ok(())
                } else {
                    Err(anyhow::anyhow!(
                        "Path not in allowed list: {}",
                        path.display()
                    ))
                }
            }
            FilePermission::Restricted(restricted) => {
                if restricted.iter().any(|p| path.starts_with(p)) {
                    Err(anyhow::anyhow!(
                        "Path is restricted: {}",
                        path.display()
                    ))
                } else {
                    Ok(())
                }
            }
        }
    }
}
```

**受入基準**:
- [ ] PermissionSet構造体定義
- [ ] 各権限チェックメソッド実装
- [ ] YAML読み込み機能
- [ ] 単体テスト10件以上

---

#### タスク2-2: 監査ログ（2日）

**ファイル**: `codex-rs/core/src/audit_log.rs`

```rust
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct AuditLogEntry {
    pub timestamp: DateTime<Utc>,
    pub agent: String,
    pub action: AuditAction,
    pub result: AuditResult,
    pub details: serde_json::Value,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum AuditAction {
    FileRead(String),
    FileWrite(String),
    ShellCommand(String),
    NetworkAccess(String),
    AgentExecution,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum AuditResult {
    Allowed,
    Denied,
    Error(String),
}

impl AuditLogEntry {
    pub fn log(&self) {
        let json = serde_json::to_string(self).unwrap();
        eprintln!("[AUDIT] {}", json);
        // TODO: ファイルにも保存
    }
}
```

**受入基準**:
- [ ] 監査ログ記録
- [ ] JSON形式出力
- [ ] ファイル保存
- [ ] ログローテーション

---

### Phase 3: トークンバジェット管理（3日）

**目標**: FR-SA-006 トークンバジェット管理 実装

**ファイル**: `codex-rs/core/src/token_budget.rs`

```rust
use anyhow::Result;

/// トークンバジェット
#[derive(Debug, Clone)]
pub struct TokenBudget {
    pub total: usize,
    pub used: usize,
    pub reserved: usize,
}

impl TokenBudget {
    pub fn new(total: usize) -> Self {
        Self {
            total,
            used: 0,
            reserved: 0,
        }
    }

    /// 利用可能か確認
    pub fn check_available(&self, required: usize) -> bool {
        self.remaining() >= required
    }

    /// トークン消費
    pub fn consume(&mut self, amount: usize) -> Result<()> {
        if !self.check_available(amount) {
            return Err(anyhow::anyhow!(
                "Insufficient token budget: required={}, remaining={}",
                amount,
                self.remaining()
            ));
        }
        self.used += amount;
        Ok(())
    }

    /// トークン予約解放
    pub fn release(&mut self, amount: usize) {
        self.reserved = self.reserved.saturating_sub(amount);
    }

    /// 残量
    pub fn remaining(&self) -> usize {
        self.total.saturating_sub(self.used + self.reserved)
    }

    /// 使用率（%）
    pub fn usage_rate(&self) -> f64 {
        (self.used as f64 / self.total as f64) * 100.0
    }
}
```

**受入基準**:
- [ ] TokenBudget構造体定義
- [ ] 各メソッド実装
- [ ] 単体テスト8件以上
- [ ] オーバーフローテスト

---

### Phase 4: 対話モード統合（1週間）

**目標**: FR-CM-001 対話モード統合

**実装内容**:
```rust
// codex-rs/core/src/interactive_mode.rs

// @code-reviewer エイリアス処理
if input.starts_with("@code-reviewer ") {
    let scope = input.strip_prefix("@code-reviewer ").unwrap();
    return run_delegate_command(
        "code-reviewer".to_string(),
        None,
        Some(PathBuf::from(scope)),
        None,
        None,
        None,
    ).await;
}

// @researcher エイリアス処理
if input.starts_with("@researcher ") {
    let query = input.strip_prefix("@researcher ").unwrap();
    return run_research_command(
        query.to_string(),
        1,
        3,
        ResearchStrategy::Comprehensive,
        None,
        None,
    ).await;
}
```

---

## 📅 実装スケジュール

| Phase | 期間 | タスク | 担当 |
|-------|------|--------|------|
| **Phase 1** | Week 1-2 | Agent Runtime基盤 | Development Team |
| **Phase 2** | Week 3 | 権限管理システム | Development Team |
| **Phase 3** | Week 4 前半 | トークンバジェット管理 | Development Team |
| **Phase 4** | Week 4 後半 | 対話モード統合 | Development Team |

---

## ✅ 完了条件

### Phase 1完了条件
- [ ] AgentRuntime実装・テスト完了
- [ ] TaskExecutor実装・テスト完了
- [ ] delegate コマンド実動作
- [ ] `cargo test -p codex-core` 成功

### Phase 2完了条件
- [ ] PermissionSet実装・テスト完了
- [ ] 監査ログ実装完了
- [ ] 権限チェック動作確認
- [ ] セキュリティテスト完了

### Phase 3完了条件
- [ ] TokenBudget実装・テスト完了
- [ ] バジェット管理動作確認
- [ ] オーバーフロー対策確認

### Phase 4完了条件
- [ ] 対話モード統合完了
- [ ] @エイリアス動作確認
- [ ] E2Eテスト完了

---

## 🎯 次のアクション

### 今すぐ（今日）

```bash
# Phase 1開始
1. ディレクトリ作成
mkdir -p codex-rs/core/src

2. ファイル作成
touch codex-rs/core/src/agent_runtime.rs
touch codex-rs/core/src/task_executor.rs
touch codex-rs/core/src/permissions.rs
touch codex-rs/core/src/token_budget.rs
touch codex-rs/core/src/audit_log.rs

3. Cargo.toml更新
# codex-rs/core/Cargo.toml に依存関係追加
```

### 明日

```bash
# AgentRuntime実装開始
1. agent_runtime.rs 実装
2. 単体テスト作成
3. cargo test実行
```

---

## 💡 実装のポイント

### 1. エラーハンドリング

```rust
// ✅ Good
pub fn execute(&self) -> Result<Output> {
    self.check_permissions()?;
    self.check_budget()?;
    // ...
}

// ❌ Bad
pub fn execute(&self) -> Output {
    self.check_permissions().unwrap();  // panic可能性
    // ...
}
```

### 2. 非同期処理

```rust
// ✅ Good
pub async fn execute_task(&mut self, ...) -> Result<Output> {
    let result = timeout(deadline, async {
        // ...
    }).await?;
}
```

### 3. テスト

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_agent_runtime_execute() {
        let runtime = AgentRuntime::new(...).unwrap();
        let result = runtime.execute_task("test", &inputs).await;
        assert!(result.is_ok());
    }
}
```

---

## 🎊 完了宣言

**この実装計画に従えば、4週間で  
サブエージェント機構が完全に動作するで！** 💪

---

**作成日時**: 2025-10-11 18:30 JST  
**参照文書**: REQ-SPEC-001  
**Status**: ✅ **実装計画確定**

---

**END OF IMPLEMENTATION PLAN**

