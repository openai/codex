# å¤šè¨€èª/reviewã‚³ãƒãƒ³ãƒ‰å®Ÿè£…ä¾‹

**ä½œæˆæ—¥æ™‚**: 2025-11-02  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v0.56.0+  
**å®Ÿè£…è€…**: Cursor Agent (Claude Sonnet 4.5)  
**ç›®çš„**: AGENTS.mdã®è¨€èªè¨­å®šã‚’/reviewã‚³ãƒãƒ³ãƒ‰ã«çµ±åˆ

---

## ğŸ“‹ å®Ÿè£…æ¦‚è¦

AGENTS.mdãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨€èªè¨­å®šï¼ˆ`language: ja`ç­‰ï¼‰ã‚’èª­ã¿å–ã£ã¦ã€`/review`ã‚³ãƒãƒ³ãƒ‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’æŒ‡å®šè¨€èªã§è¿”ã™ã‚ˆã†ã«ã™ã‚‹å®Ÿè£…ã‚„ã§ï¼

---

## ğŸ¯ å®Ÿè£…ã‚¹ãƒ†ãƒƒãƒ—

### Step 1: AGENTS.mdè¨€èªè¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼è¿½åŠ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/src/project_doc.rs`

```rust
/// AGENTS.mdã‹ã‚‰è¨€èªè¨­å®šã‚’æŠ½å‡ºã™ã‚‹
pub fn extract_language_setting(content: &str) -> Option<String> {
    // ãƒ‘ã‚¿ãƒ¼ãƒ³: "- language: ja" ã¾ãŸã¯ "language: en"
    let patterns = [
        regex::Regex::new(r"(?m)^-?\s*language:\s*(\w+)").ok()?,
        regex::Regex::new(r"(?m)^language:\s*(\w+)").ok()?,
    ];
    
    for pattern in &patterns {
        if let Some(captures) = pattern.captures(content) {
            if let Some(lang) = captures.get(1) {
                return Some(lang.as_str().to_lowercase());
            }
        }
    }
    
    None
}

/// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‹ã‚‰è¨€èªè¨­å®šã‚’å–å¾—
pub async fn get_language_setting(config: &Config) -> Option<String> {
    let project_docs = read_project_docs(config).await.ok()??;
    extract_language_setting(&project_docs)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_language_setting() {
        // ãƒ‘ã‚¿ãƒ¼ãƒ³1: ãƒªã‚¹ãƒˆå½¢å¼
        let content1 = r#"
# Project Settings
- language: ja
- review_depth: detailed
"#;
        assert_eq!(extract_language_setting(content1), Some("ja".to_string()));

        // ãƒ‘ã‚¿ãƒ¼ãƒ³2: ã‚­ãƒ¼ãƒãƒªãƒ¥ãƒ¼å½¢å¼
        let content2 = r#"
## Configuration
language: en
focus: security
"#;
        assert_eq!(extract_language_setting(content2), Some("en".to_string()));

        // ãƒ‘ã‚¿ãƒ¼ãƒ³3: è¨€èªè¨­å®šãªã—
        let content3 = r#"
# Project
This is a project.
"#;
        assert_eq!(extract_language_setting(content3), None);
    }
}
```

---

### Step 2: ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨è¨€èªè¨­å®šæ§‹é€ ä½“

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/src/code_review/types.rs`

```rust
use serde::{Deserialize, Serialize};

/// ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨­å®š
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReviewConfig {
    /// ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨€èªï¼ˆISO 639-1ã‚³ãƒ¼ãƒ‰: ja, en, zh, etc.ï¼‰
    pub language: String,
    /// ãƒ¬ãƒ“ãƒ¥ãƒ¼æ·±åº¦
    pub depth: ReviewDepth,
    /// ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¨ãƒªã‚¢
    pub focus_areas: Vec<FocusArea>,
}

impl Default for ReviewConfig {
    fn default() -> Self {
        Self {
            language: "en".to_string(),  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯è‹±èª
            depth: ReviewDepth::Standard,
            focus_areas: vec![
                FocusArea::Security,
                FocusArea::Performance,
                FocusArea::BestPractices,
            ],
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReviewDepth {
    Quick,
    Standard,
    Detailed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FocusArea {
    Security,
    Performance,
    BestPractices,
    ErrorHandling,
    Testing,
    Documentation,
}

/// è¨€èªåˆ¥ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
pub struct ReviewPromptTemplate {
    language: String,
}

impl ReviewPromptTemplate {
    pub fn new(language: &str) -> Self {
        Self {
            language: language.to_lowercase(),
        }
    }

    /// ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
    pub fn system_prompt(&self) -> String {
        match self.language.as_str() {
            "ja" => r#"
ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã§ã™ã€‚
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ã€æ”¹å–„ç‚¹ã‚’æŒ‡æ‘˜ã—ã¦ãã ã•ã„ã€‚

ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦³ç‚¹ï¼š
1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®å•é¡Œ
2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®å•é¡Œ
3. ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‹ã‚‰ã®é€¸è„±
4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ä¸å‚™
5. ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§

ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼š
- å•é¡Œç‚¹ã¯å…·ä½“çš„ã«æŒ‡æ‘˜ã—ã¦ãã ã•ã„
- æ”¹å–„ææ¡ˆã‚’å¿…ãšå«ã‚ã¦ãã ã•ã„
- è‰¯ã„ç‚¹ã‚‚å¿˜ã‚Œãšã«è©•ä¾¡ã—ã¦ãã ã•ã„
"#.to_string(),
            "en" => r#"
You are an experienced code reviewer.
Please review the following code and point out improvements.

Review aspects:
1. Security issues
2. Performance issues
3. Deviations from best practices
4. Error handling deficiencies
5. Code readability

Format:
- Point out issues specifically
- Always include improvement suggestions
- Don't forget to appreciate good points
"#.to_string(),
            "zh" => r#"
æ‚¨æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œçš„ä»£ç å®¡æŸ¥å‘˜ã€‚
è¯·å®¡æŸ¥ä»¥ä¸‹ä»£ç å¹¶æŒ‡å‡ºæ”¹è¿›ä¹‹å¤„ã€‚

å®¡æŸ¥æ–¹é¢ï¼š
1. å®‰å…¨é—®é¢˜
2. æ€§èƒ½é—®é¢˜
3. åç¦»æœ€ä½³å®è·µ
4. é”™è¯¯å¤„ç†ä¸è¶³
5. ä»£ç å¯è¯»æ€§

æ ¼å¼ï¼š
- å…·ä½“æŒ‡å‡ºé—®é¢˜
- å§‹ç»ˆåŒ…æ‹¬æ”¹è¿›å»ºè®®
- ä¸è¦å¿˜è®°èµèµä¼˜ç‚¹
"#.to_string(),
            _ => self.system_prompt_fallback(),
        }
    }

    fn system_prompt_fallback(&self) -> String {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: è‹±èª
        r#"
You are an experienced code reviewer.
Please review the following code and point out improvements.
"#.to_string()
    }

    /// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
    pub fn user_prompt(&self, code: &str, file_path: Option<&str>) -> String {
        let file_info = file_path
            .map(|p| match self.language.as_str() {
                "ja" => format!("ãƒ•ã‚¡ã‚¤ãƒ«: {}", p),
                "zh" => format!("æ–‡ä»¶: {}", p),
                _ => format!("File: {}", p),
            })
            .unwrap_or_default();

        match self.language.as_str() {
            "ja" => format!(
                "{}\n\n```\n{}\n```\n\nä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ãã ã•ã„ã€‚",
                file_info, code
            ),
            "zh" => format!(
                "{}\n\n```\n{}\n```\n\nè¯·å®¡æŸ¥ä¸Šè¿°ä»£ç ã€‚",
                file_info, code
            ),
            _ => format!(
                "{}\n\n```\n{}\n```\n\nPlease review the above code.",
                file_info, code
            ),
        }
    }
}
```

---

### Step 3: ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½æ‹¡å¼µ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/src/code_review/mod.rs`

```rust
use crate::config::Config;
use crate::project_doc::get_language_setting;
use anyhow::Result;

pub mod language_detector;
pub mod types;

use types::{ReviewConfig, ReviewPromptTemplate};

/// ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å®Ÿè¡Œ
pub async fn review_code(
    config: &Config,
    code: &str,
    file_path: Option<&str>,
) -> Result<String> {
    // AGENTS.mdã‹ã‚‰è¨€èªè¨­å®šã‚’å–å¾—
    let language = get_language_setting(config)
        .await
        .unwrap_or_else(|| "en".to_string());

    tracing::info!("Code review language: {}", language);

    // ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨­å®šã‚’ä½œæˆ
    let review_config = ReviewConfig {
        language: language.clone(),
        ..Default::default()
    };

    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”Ÿæˆ
    let template = ReviewPromptTemplate::new(&language);
    let system_prompt = template.system_prompt();
    let user_prompt = template.user_prompt(code, file_path);

    // LLMã«ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä¾é ¼
    let response = call_llm_for_review(
        config,
        &system_prompt,
        &user_prompt,
    ).await?;

    Ok(format_review_response(&response, &language))
}

/// LLMã«ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä¾é ¼ï¼ˆä»®å®Ÿè£…ï¼‰
async fn call_llm_for_review(
    config: &Config,
    system_prompt: &str,
    user_prompt: &str,
) -> Result<String> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€config.modelã‚’ä½¿ã£ã¦LLM APIã‚’å‘¼ã³å‡ºã™
    // ã“ã“ã§ã¯ç°¡ç•¥åŒ–ã®ãŸã‚ãƒ€ãƒŸãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
    
    tracing::debug!("System prompt: {}", system_prompt);
    tracing::debug!("User prompt: {}", user_prompt);
    
    // TODO: å®Ÿéš›ã®LLM APIå‘¼ã³å‡ºã—
    Ok("ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœãŒã“ã“ã«å…¥ã‚Šã¾ã™".to_string())
}

/// ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
fn format_review_response(response: &str, language: &str) -> String {
    let header = match language {
        "ja" => "ğŸ” ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ",
        "zh" => "ğŸ” ä»£ç å®¡æŸ¥ç»“æœ",
        _ => "ğŸ” Code Review Results",
    };

    format!("{}\n\n{}", header, response)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_review_prompt_template_japanese() {
        let template = ReviewPromptTemplate::new("ja");
        let prompt = template.system_prompt();
        assert!(prompt.contains("ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼"));
        assert!(prompt.contains("ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£"));
    }

    #[test]
    fn test_review_prompt_template_english() {
        let template = ReviewPromptTemplate::new("en");
        let prompt = template.system_prompt();
        assert!(prompt.contains("code reviewer"));
        assert!(prompt.contains("Security"));
    }

    #[test]
    fn test_user_prompt_with_file_path() {
        let template = ReviewPromptTemplate::new("ja");
        let code = "fn main() { println!(\"Hello\"); }";
        let prompt = template.user_prompt(code, Some("src/main.rs"));
        assert!(prompt.contains("ãƒ•ã‚¡ã‚¤ãƒ«: src/main.rs"));
        assert!(prompt.contains(code));
    }
}
```

---

### Step 4: TUIã‚³ãƒãƒ³ãƒ‰çµ±åˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/tui/src/commands/review.rs` (æ–°è¦ä½œæˆ)

```rust
use anyhow::Result;
use codex_core::code_review::review_code;
use codex_core::config::Config;

/// /reviewã‚³ãƒãƒ³ãƒ‰ã‚’å‡¦ç†
pub async fn handle_review_command(
    config: &Config,
    args: &[&str],
) -> Result<String> {
    if args.is_empty() {
        return Ok("ä½¿ç”¨æ³•: /review <ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹>\nä¾‹: /review src/main.rs".to_string());
    }

    let file_path = args[0];
    let code = tokio::fs::read_to_string(file_path).await?;

    // ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å®Ÿè¡Œï¼ˆè¨€èªè¨­å®šã¯è‡ªå‹•æ¤œå‡ºï¼‰
    let review_result = review_code(config, &code, Some(file_path)).await?;

    Ok(review_result)
}

/// é¸æŠä¸­ã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼
pub async fn review_selected_code(
    config: &Config,
    code: &str,
) -> Result<String> {
    review_code(config, code, None).await
}
```

---

### Step 5: CLIã‚³ãƒãƒ³ãƒ‰çµ±åˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/cli/src/commands/review.rs` (æ–°è¦ä½œæˆ)

```rust
use anyhow::Result;
use clap::Args;
use codex_core::code_review::review_code;
use codex_core::config::Config;

#[derive(Args, Debug)]
pub struct ReviewArgs {
    /// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
    pub file_path: String,
    
    /// è¨€èªã‚’æ˜ç¤ºçš„ã«æŒ‡å®šï¼ˆAGENTS.mdã‚ˆã‚Šå„ªå…ˆï¼‰
    #[arg(short, long)]
    pub language: Option<String>,
}

pub async fn run(config: &Config, args: ReviewArgs) -> Result<()> {
    let code = tokio::fs::read_to_string(&args.file_path).await?;

    // è¨€èªãŒæ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ä¸€æ™‚çš„ã«ä¸Šæ›¸ã
    let mut config_clone = config.clone();
    if let Some(lang) = args.language {
        // TODO: config_cloneã«è¨€èªè¨­å®šã‚’æ³¨å…¥ã™ã‚‹ä»•çµ„ã¿ã‚’è¿½åŠ 
        tracing::info!("Using explicit language: {}", lang);
    }

    let review_result = review_code(&config_clone, &code, Some(&args.file_path)).await?;

    println!("{}", review_result);

    Ok(())
}
```

---

### Step 6: AGENTS.mdè¨­å®šä¾‹

**ãƒ•ã‚¡ã‚¤ãƒ«**: `AGENTS.md` (ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆ)

```markdown
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š

## ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨­å®š
- language: ja
- review_depth: detailed
- focus: security, performance, best_practices

## ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„
- ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ: 4ã‚¹ãƒšãƒ¼ã‚¹
- è¡Œé•·: æœ€å¤§120æ–‡å­—
- å‘½åè¦å‰‡: snake_case (Rust), camelCase (TypeScript)

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯bcryptã§ãƒãƒƒã‚·ãƒ¥åŒ–
- SQLæ³¨å…¥ã‚’é˜²ããŸã‚ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆä½¿ç”¨
- XSSå¯¾ç­–ã®ãŸã‚å…¥åŠ›ã‚µãƒ‹ã‚¿ã‚¤ã‚ºå¿…é ˆ
```

**è‹±èªç‰ˆä¾‹**:

```markdown
# Project Settings

## Review Settings
- language: en
- review_depth: detailed
- focus: security, performance, best_practices

## Coding Standards
- Indent: 4 spaces
- Line length: max 120 characters
- Naming: snake_case (Rust), camelCase (TypeScript)

## Security Requirements
- Hash passwords with bcrypt
- Use prepared statements to prevent SQL injection
- Input sanitization required for XSS prevention
```

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/tests/code_review_i18n_test.rs`

```rust
use codex_core::code_review::{review_code, types::ReviewPromptTemplate};
use codex_core::config::Config;
use codex_core::project_doc::extract_language_setting;

#[tokio::test]
async fn test_japanese_review() {
    let agents_md_content = r#"
- language: ja
- review_depth: detailed
"#;
    
    let lang = extract_language_setting(agents_md_content);
    assert_eq!(lang, Some("ja".to_string()));
}

#[tokio::test]
async fn test_english_review() {
    let agents_md_content = r#"
language: en
review_depth: standard
"#;
    
    let lang = extract_language_setting(agents_md_content);
    assert_eq!(lang, Some("en".to_string()));
}

#[tokio::test]
async fn test_chinese_review() {
    let agents_md_content = r#"
## è®¾ç½®
- language: zh
"#;
    
    let lang = extract_language_setting(agents_md_content);
    assert_eq!(lang, Some("zh".to_string()));
}

#[test]
fn test_multilingual_prompts() {
    // æ—¥æœ¬èª
    let ja_template = ReviewPromptTemplate::new("ja");
    assert!(ja_template.system_prompt().contains("ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼"));
    
    // è‹±èª
    let en_template = ReviewPromptTemplate::new("en");
    assert!(en_template.system_prompt().contains("code reviewer"));
    
    // ä¸­å›½èª
    let zh_template = ReviewPromptTemplate::new("zh");
    assert!(zh_template.system_prompt().contains("ä»£ç å®¡æŸ¥å‘˜"));
}

#[test]
fn test_fallback_to_english() {
    // æœªçŸ¥ã®è¨€èªã‚³ãƒ¼ãƒ‰
    let unknown_template = ReviewPromptTemplate::new("xyz");
    let prompt = unknown_template.system_prompt();
    // è‹±èªã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
    assert!(prompt.contains("code reviewer"));
}
```

---

## ğŸ“Š ä½¿ç”¨ä¾‹

### æ—¥æœ¬èªã§ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼

```bash
# AGENTS.mdã« language: ja ã¨è¨­å®š
$ cat AGENTS.md
- language: ja

# ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ
$ codex
> /review src/user.rs

ğŸ” ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ

ğŸ“ æ¦‚è¦
ã“ã®ã‚³ãƒ¼ãƒ‰ã¯å…¨ä½“çš„ã«è‰¯å¥½ã§ã™ãŒã€ã„ãã¤ã‹ã®æ”¹å–„ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚

âš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®æ‡¸å¿µ
1. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒãƒƒã‚·ãƒ¥åŒ–ãŒä¸ååˆ†ã§ã™ï¼ˆ17è¡Œç›®ï¼‰
   æ”¹å–„æ¡ˆ: bcryptã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„
   ```rust
   use bcrypt::{hash, DEFAULT_COST};
   let hashed = hash(password, DEFAULT_COST)?;
   ```

2. SQLæ³¨å…¥ã®è„†å¼±æ€§ãŒã‚ã‚Šã¾ã™ï¼ˆ42è¡Œç›®ï¼‰
   æ”¹å–„æ¡ˆ: ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„

âœ… è‰¯ã„ç‚¹
1. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒé©åˆ‡ã§ã™
2. å‘½åè¦å‰‡ãŒä¸€è²«ã—ã¦ã„ã¾ã™
3. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚³ãƒ¡ãƒ³ãƒˆãŒå……å®Ÿã—ã¦ã„ã¾ã™

ğŸ’¡ æ”¹å–„ææ¡ˆ
1. ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„
2. éåŒæœŸå‡¦ç†ã§tokio::spawnã‚’æ´»ç”¨ã§ãã¾ã™
```

### è‹±èªã§ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼

```bash
# AGENTS.mdè¨­å®š
$ cat AGENTS.md
language: en

# ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ
$ codex
> /review src/user.rs

ğŸ” Code Review Results

ğŸ“ Summary
The code is generally good, but there are some areas for improvement.

âš ï¸ Security Concerns
1. Password hashing is insufficient (line 17)
   Suggestion: Use the bcrypt crate
   ```rust
   use bcrypt::{hash, DEFAULT_COST};
   let hashed = hash(password, DEFAULT_COST)?;
   ```

2. SQL injection vulnerability exists (line 42)
   Suggestion: Use prepared statements

âœ… Good Points
1. Error handling is appropriate
2. Naming conventions are consistent
3. Documentation comments are comprehensive

ğŸ’¡ Improvement Suggestions
1. Add unit tests
2. Can leverage tokio::spawn for async processing
```

---

## ğŸš€ ä»Šå¾Œã®æ‹¡å¼µ

### Phase 1: åŸºæœ¬å®Ÿè£…ï¼ˆä¸Šè¨˜ï¼‰
- âœ… AGENTS.mdè¨€èªè¨­å®šãƒ‘ãƒ¼ã‚µãƒ¼
- âœ… å¤šè¨€èªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
- âœ… /reviewã‚³ãƒãƒ³ãƒ‰çµ±åˆ
- âœ… æ—¥æœ¬èªãƒ»è‹±èªãƒ»ä¸­å›½èªå¯¾å¿œ

### Phase 2: æ©Ÿèƒ½æ‹¡å¼µ
- [ ] ä»–ã®ã‚³ãƒãƒ³ãƒ‰å¤šè¨€èªå¯¾å¿œï¼ˆ/plan, /testç­‰ï¼‰
- [ ] è¨€èªåˆ¥ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„DB
- [ ] ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
- [ ] è‡ªå‹•è¨€èªæ¤œå‡ºï¼ˆãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆã‹ã‚‰ï¼‰

### Phase 3: é«˜åº¦ãªæ©Ÿèƒ½
- [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç¿»è¨³æ©Ÿèƒ½
- [ ] è¨€èªæ··åœ¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå¯¾å¿œ
- [ ] å¤šè¨€èªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆè‡ªå‹•ç”Ÿæˆ
- [ ] è¨€èªåˆ¥ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹

---

## ğŸ’» ãƒ“ãƒ«ãƒ‰ï¼†ãƒ†ã‚¹ãƒˆ

```bash
# ãƒ“ãƒ«ãƒ‰
cd codex-rs
cargo build --release

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
cargo test code_review_i18n

# çµ±åˆãƒ†ã‚¹ãƒˆ
cargo test --test code_review_i18n_test

# ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
cargo install --path cli --force

# å‹•ä½œç¢ºèª
codex --version
codex
> /review src/main.rs
```

---

## ğŸ“ ã¾ã¨ã‚

ã“ã®å®Ÿè£…ã§ã€ä»¥ä¸‹ãŒå®Ÿç¾ã§ãã‚‹ã§ï¼š

1. **AGENTS.mdè¨€èªè¨­å®šã®è‡ªå‹•æ¤œå‡º** ğŸ”
   - `language: ja`ãªã©ã®è¨­å®šã‚’è‡ªå‹•èª­ã¿å–ã‚Š
   - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯è‹±èªã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

2. **å¤šè¨€èªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ** ğŸŒ
   - è¨€èªåˆ¥ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã•ã‚ŒãŸãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
   - ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä¸¡å¯¾å¿œ

3. **/reviewã‚³ãƒãƒ³ãƒ‰çµ±åˆ** ğŸ¯
   - TUIãƒ»CLIä¸¡å¯¾å¿œ
   - æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šã‚‚å¯èƒ½

4. **æ‹¡å¼µæ€§ã®é«˜ã„è¨­è¨ˆ** ğŸš€
   - æ–°è¨€èªè¿½åŠ ãŒå®¹æ˜“
   - ã‚«ã‚¹ã‚¿ãƒ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¯¾å¿œ
   - ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ–¹å¼ã§æ‹¡å¼µå¯èƒ½

---

**å®Ÿè£…è€…**: Cursor Agent (Claude Sonnet 4.5)  
**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: zapabob/codex  
**ãƒ©ã‚¤ã‚»ãƒ³ã‚¹**: Apache-2.0  
**GitHub**: https://github.com/zapabob/codex

ã‚ˆã£ã—ã‚ƒã€å®Œç’§ãªå®Ÿè£…ä¾‹ãŒã§ããŸã§ãƒ¼ï¼ğŸ‰âœ¨

