# Loop Driver Design Document

> Loop-based execution control for iterative agent runs in codex-rs.

**Related Documents:**
- [Overview & Implementation Guide](./loop-spawn-overview.md)
- [SpawnTask Design](./spawn-task.md)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Reference: Auto-Coder Implementation](#2-reference-auto-coder-implementation)
3. [LoopCondition](#3-loopcondition)
4. [LoopPromptBuilder](#4-looppromptbuilder)
5. [LoopDriver](#5-loopdriver)
6. [Module Exports](#6-module-exports)
7. [CLI Integration](#7-cli-integration)

---

## 1. Overview

Loop Driver provides iteration/time-based execution control for any Codex agent session.

| Feature | Description |
|---------|-------------|
| **Count-based** | Run N iterations (`--iter 5`) |
| **Time-based** | Run until duration (`--time 1h`) |
| **Git-aware prompts** | Auto-Coder style iterative improvement |
| **Continue-on-error** | Iterations continue after single failure |
| **Cancellation** | Graceful shutdown via CancellationToken |

### Key Design Decision: Continue-on-Error

**Important:** Iterations continue after single iteration failure (AutoCoder pattern).

```rust
// If iteration fails, log warning and continue to next iteration
if let Err(e) = codex.submit(...).await {
    warn!(iteration, error = %e, "Iteration failed, continuing...");
    self.iteration += 1;  // Still count as completed attempt
    continue;  // Don't break - continue to next iteration
}
```

### Use Cases

- `exec --iter 5 "implement feature"` - Run 5 iterations (continues even if one fails)
- `exec --time 30m "fix bugs"` - Run for 30 minutes
- SpawnAgent integration via `LoopDriver`

---

## 2. Reference: Auto-Coder Implementation

> Source: `docs/ref/autocoder/02-async-time-command.md`

### 2.1 Command Syntax

```bash
/auto /async /name <task_name> /time <duration> "query"
/auto /async /name <task_name> /loop <count> "query"
/auto /async /list
/auto /async /kill <task_id>
```

### 2.2 Time Parsing

| Input | Seconds |
|-------|---------|
| `5s` | 5 |
| `10m` | 600 |
| `2h` | 7,200 |
| `1d` | 86,400 |

### 2.3 Execution Loop Pattern (with Continue-on-Error)

```python
# Auto-Coder's execution pattern (Python)
start_time = time.time()
failed_iterations = []

for i in range(loop_count):
    # 1. Check stop signal BEFORE each iteration
    if stop_event.is_set():
        break

    # 2. Select query based on iteration
    if i == 0:
        query = original_query
    else:
        query = original_query + LOOP_INSTRUCTION

    # 3. Execute iteration (with error handling)
    try:
        execute(query)
    except Exception as e:
        # Log error but CONTINUE to next iteration
        logger.warning(f"Iteration {i} failed: {e}")
        failed_iterations.append(i)
        continue  # Don't break!

    # 4. Check time limit AFTER each iteration
    if start_time and (time.time() - start_time) >= max_duration:
        break
```

### 2.4 Loop Prompt (Critical)

Auto-Coder uses this prompt for iterations > 0:

```
{original_query}

Additional instruction: use git log to get the code changes generated by previous
tasks and try to focus on iterative improvements and refinements and make sure to
use git commit command to make a commit after every single file edit.
```

**Key Insights:**
1. **Git awareness** - Agent checks `git log` to understand prior changes
2. **Iterative focus** - "improvements and refinements" not starting fresh
3. **Atomic commits** - One commit per file edit for trackability

### 2.5 Task Metadata

```json
{
    "task_id": "feature-auth",
    "status": "running",
    "created_at": "2024-01-15T10:30:00",
    "completed_at": null,
    "user_query": "Implement user authentication",
    "model": "deepseek/v3",
    "iterations_completed": 3,
    "iterations_failed": 1,
    "error_message": null
}
```

---

## 3. LoopCondition

**File:** `codex-rs/core/src/loop_driver/condition.rs`

```rust
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use ts_rs::TS;

/// Condition that controls loop execution.
///
/// # Examples
///
/// ```rust
/// use codex_core::loop_driver::LoopCondition;
///
/// // Parse from string
/// let iters = LoopCondition::parse("5").unwrap();
/// let duration = LoopCondition::parse("1h").unwrap();
///
/// // Create directly
/// let iters = LoopCondition::Iters { count: 5 };
/// let duration = LoopCondition::Duration { seconds: 3600 };
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, JsonSchema, TS)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum LoopCondition {
    /// Run a fixed number of iterations.
    Iters {
        /// Number of iterations to run.
        count: i32,
    },
    /// Run until duration elapsed.
    Duration {
        /// Duration in seconds.
        seconds: i64,
    },
}

impl LoopCondition {
    /// Parse from CLI string.
    ///
    /// Accepts:
    /// - Iters: "5", "10", "100"
    /// - Duration: "5s", "10m", "2h", "1d"
    ///
    /// # Errors
    ///
    /// Returns error if string doesn't match expected format.
    pub fn parse(s: &str) -> Result<Self, String> {
        let s = s.trim();

        // Try duration first (has unit suffix)
        if let Some(seconds) = Self::try_parse_duration(s) {
            return Ok(Self::Duration { seconds });
        }

        // Fall back to iterations (plain number)
        s.parse::<i32>()
            .map(|count| Self::Iters { count })
            .map_err(|_| format!(
                "Invalid loop condition: '{s}'. Expected iterations (e.g., '5') or duration (e.g., '1h', '30m', '5s')"
            ))
    }

    fn try_parse_duration(s: &str) -> Option<i64> {
        if s.len() < 2 {
            return None;
        }

        let (num_str, unit) = s.split_at(s.len() - 1);
        let value: i64 = num_str.parse().ok()?;

        let multiplier = match unit {
            "s" => 1,
            "m" => 60,
            "h" => 3600,
            "d" => 86400,
            _ => return None,
        };

        Some(value * multiplier)
    }

    /// Get display string for this condition.
    pub fn display(&self) -> String {
        match self {
            Self::Iters { count } => format!("{count} iterations"),
            Self::Duration { seconds } => {
                if *seconds >= 86400 {
                    format!("{}d", seconds / 86400)
                } else if *seconds >= 3600 {
                    format!("{}h", seconds / 3600)
                } else if *seconds >= 60 {
                    format!("{}m", seconds / 60)
                } else {
                    format!("{seconds}s")
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;

    #[test]
    fn parse_iters() {
        assert_eq!(
            LoopCondition::parse("5"),
            Ok(LoopCondition::Iters { count: 5 })
        );
        assert_eq!(
            LoopCondition::parse("100"),
            Ok(LoopCondition::Iters { count: 100 })
        );
    }

    #[test]
    fn parse_duration() {
        assert_eq!(
            LoopCondition::parse("5s"),
            Ok(LoopCondition::Duration { seconds: 5 })
        );
        assert_eq!(
            LoopCondition::parse("10m"),
            Ok(LoopCondition::Duration { seconds: 600 })
        );
        assert_eq!(
            LoopCondition::parse("2h"),
            Ok(LoopCondition::Duration { seconds: 7200 })
        );
        assert_eq!(
            LoopCondition::parse("1d"),
            Ok(LoopCondition::Duration { seconds: 86400 })
        );
    }

    #[test]
    fn parse_invalid() {
        assert!(LoopCondition::parse("abc").is_err());
        assert!(LoopCondition::parse("5x").is_err());
        assert!(LoopCondition::parse("").is_err());
    }

    #[test]
    fn display() {
        assert_eq!(
            LoopCondition::Iters { count: 5 }.display(),
            "5 iterations"
        );
        assert_eq!(
            LoopCondition::Duration { seconds: 3600 }.display(),
            "1h"
        );
    }
}
```

---

## 4. LoopPromptBuilder

**File:** `codex-rs/core/src/loop_driver/prompt.rs`

```rust
/// Builder for loop iteration prompts.
///
/// Implements Auto-Coder style git-based iterative improvement prompts.
pub struct LoopPromptBuilder;

/// Default loop instruction appended to queries after first iteration.
const DEFAULT_LOOP_INSTRUCTION: &str = r#"
Additional instruction: use git log to get the code changes generated by previous
tasks and try to focus on iterative improvements and refinements and make sure to
use git commit command to make a commit after every single file edit."#;

impl LoopPromptBuilder {
    /// Enhance query for loop iterations > 0.
    ///
    /// First iteration (iteration == 0) uses original query unchanged.
    /// Subsequent iterations append loop instructions.
    ///
    /// # Arguments
    ///
    /// * `original` - Original user query
    /// * `iteration` - Current iteration number (0-indexed)
    ///
    /// # Returns
    ///
    /// Enhanced query string
    pub fn build(original: &str, iteration: i32) -> String {
        if iteration == 0 {
            original.to_string()
        } else {
            Self::enhance(original)
        }
    }

    /// Enhance query with loop instructions.
    ///
    /// Appends git-based iterative improvement instructions.
    pub fn enhance(original: &str) -> String {
        format!("{original}\n{DEFAULT_LOOP_INSTRUCTION}")
    }

    /// Build with custom loop instruction.
    ///
    /// Allows users to specify their own loop prompt.
    pub fn build_with_custom(
        original: &str,
        iteration: i32,
        custom_instruction: Option<&str>,
    ) -> String {
        if iteration == 0 {
            original.to_string()
        } else {
            match custom_instruction {
                Some(instruction) => format!("{original}\n\n{instruction}"),
                None => Self::enhance(original),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn first_iteration_unchanged() {
        let query = "Implement user auth";
        assert_eq!(LoopPromptBuilder::build(query, 0), query);
    }

    #[test]
    fn subsequent_iterations_enhanced() {
        let query = "Implement user auth";
        let enhanced = LoopPromptBuilder::build(query, 1);

        assert!(enhanced.starts_with(query));
        assert!(enhanced.contains("git log"));
        assert!(enhanced.contains("iterative improvements"));
    }

    #[test]
    fn custom_instruction() {
        let query = "Fix tests";
        let custom = "Focus on edge cases and error handling";
        let result = LoopPromptBuilder::build_with_custom(query, 1, Some(custom));

        assert!(result.contains(query));
        assert!(result.contains(custom));
        assert!(!result.contains("git log")); // No default instruction
    }
}
```

---

## 5. LoopDriver

**File:** `codex-rs/core/src/loop_driver/driver.rs`

### 5.1 Key Types

```rust
use std::time::Instant;
use tokio_util::sync::CancellationToken;
use tracing::{info, warn};

use crate::codex::Codex;
use crate::loop_driver::condition::LoopCondition;
use crate::loop_driver::prompt::LoopPromptBuilder;
use crate::spawn_task::LogFileSink;  // ⭐ For event logging
use codex_protocol::event::EventMsg;
use codex_protocol::operations::Op;
use codex_protocol::user_input::UserInput;

/// Progress information for callback.
#[derive(Debug, Clone)]
pub struct LoopProgress {
    /// Current iteration number (0-indexed, after completion).
    pub iteration: i32,
    /// Number of iterations that succeeded.
    pub succeeded: i32,
    /// Number of iterations that failed.
    pub failed: i32,
    /// Elapsed time in seconds.
    pub elapsed_seconds: i64,
}

/// Result of loop execution.
#[derive(Debug, Clone)]
pub struct LoopResult {
    /// Number of iterations attempted.
    pub iterations_attempted: i32,
    /// Number of iterations that succeeded.
    pub iterations_succeeded: i32,
    /// Number of iterations that failed.
    pub iterations_failed: i32,
    /// Reason the loop stopped.
    pub stop_reason: LoopStopReason,
    /// Total elapsed time in seconds.
    pub elapsed_seconds: i64,
}

/// Reason why the loop stopped.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LoopStopReason {
    /// Completed all iterations (count mode).
    Completed,
    /// Duration elapsed (time mode).
    DurationElapsed,
    /// Cancelled via CancellationToken.
    Cancelled,
    /// Task returned None (aborted internally).
    TaskAborted,
}
```

### 5.2 LoopDriver Implementation (Continue-on-Error)

```rust
/// Driver for loop-based agent execution.
///
/// Wraps the standard run_task() with loop/time-based execution control.
/// **Key behavior:** Continue-on-error - iterations continue after failure.
///
/// # Example
///
/// ```rust,ignore
/// let condition = LoopCondition::Iters { count: 5 };
/// let mut driver = LoopDriver::new(condition, cancellation_token);
///
/// let result = driver.run_with_loop(
///     session,
///     ctx,
///     "Implement feature X",
/// ).await;
///
/// println!("Completed {} of {} iterations", result.iterations_succeeded, result.iterations_attempted);
/// ```
pub struct LoopDriver {
    condition: LoopCondition,
    start_time: Instant,
    iteration: i32,
    iterations_failed: i32,
    cancellation_token: CancellationToken,
    custom_loop_prompt: Option<String>,
    /// ⭐ Optional progress callback for real-time updates.
    progress_callback: Option<Box<dyn Fn(LoopProgress) + Send + Sync>>,
}

impl LoopDriver {
    /// Create a new LoopDriver.
    ///
    /// # Arguments
    ///
    /// * `condition` - Loop termination condition
    /// * `token` - Cancellation token for graceful shutdown
    pub fn new(condition: LoopCondition, token: CancellationToken) -> Self {
        Self {
            condition,
            start_time: Instant::now(),
            iteration: 0,
            iterations_failed: 0,
            cancellation_token: token,
            custom_loop_prompt: None,
            progress_callback: None,
        }
    }

    /// Set custom loop prompt (instead of default git-based prompt).
    pub fn with_custom_prompt(mut self, prompt: String) -> Self {
        self.custom_loop_prompt = Some(prompt);
        self
    }

    /// ⭐ Set progress callback for real-time iteration updates.
    ///
    /// The callback is invoked after each iteration completes (success or failure).
    /// Use this to persist progress to metadata or update UI.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// let driver = LoopDriver::new(condition, token)
    ///     .with_progress_callback(|progress| {
    ///         println!("Iteration {}: {} succeeded, {} failed",
    ///             progress.iteration, progress.succeeded, progress.failed);
    ///     });
    /// ```
    pub fn with_progress_callback<F>(mut self, callback: F) -> Self
    where
        F: Fn(LoopProgress) + Send + Sync + 'static,
    {
        self.progress_callback = Some(Box::new(callback));
        self
    }

    /// Current iteration number (0-indexed).
    pub fn current_iteration(&self) -> i32 {
        self.iteration
    }

    /// Elapsed time since driver started.
    pub fn elapsed(&self) -> std::time::Duration {
        self.start_time.elapsed()
    }

    /// Check if loop should continue.
    ///
    /// Returns false if:
    /// - Cancellation token is cancelled
    /// - Iteration count reached (iters mode)
    /// - Duration elapsed (time mode)
    pub fn should_continue(&self) -> bool {
        // 1. Check cancellation first
        if self.cancellation_token.is_cancelled() {
            return false;
        }

        // 2. Check condition
        match &self.condition {
            LoopCondition::Iters { count } => {
                self.iteration < *count
            }
            LoopCondition::Duration { seconds } => {
                (self.start_time.elapsed().as_secs() as i64) < *seconds
            }
        }
    }

    /// Build query for current iteration.
    pub fn build_query(&self, original: &str) -> String {
        LoopPromptBuilder::build_with_custom(
            original,
            self.iteration,
            self.custom_loop_prompt.as_deref(),
        )
    }

    /// Run task with loop driver.
    ///
    /// **IMPORTANT: Continue-on-error behavior**
    /// If an iteration fails, it logs a warning and continues to the next iteration.
    /// This follows the AutoCoder pattern for more resilient execution.
    ///
    /// Executes codex.submit() in a loop until condition is met.
    /// Uses the PUBLIC Codex API for proper isolation and upstream compatibility.
    ///
    /// # Arguments
    ///
    /// * `codex` - Codex instance (from Codex::spawn())
    /// * `original_query` - Original user query (enhanced for iterations > 0)
    /// * `sink` - Optional LogFileSink for event logging
    ///
    /// # Returns
    ///
    /// Loop execution result with iteration count and stop reason.
    pub async fn run_with_loop(
        &mut self,
        codex: &Codex,
        original_query: &str,
        sink: Option<&LogFileSink>,  // ⭐ Optional event sink
    ) -> LoopResult {
        info!(
            condition = %self.condition.display(),
            "Starting loop execution"
        );

        while self.should_continue() {
            // Build query for this iteration
            let query = self.build_query(original_query);
            let input = vec![UserInput::Text { text: query }];

            info!(
                iteration = self.iteration,
                elapsed_secs = self.start_time.elapsed().as_secs(),
                "Starting iteration"
            );

            // Submit via PUBLIC Codex API (not internal run_task)
            // ⭐ CONTINUE-ON-ERROR: If submit fails, log and continue
            if let Err(e) = codex.submit(Op::UserInput { items: input }).await {
                warn!(
                    iteration = self.iteration,
                    error = %e,
                    "Iteration failed to submit, continuing to next iteration..."
                );
                self.iterations_failed += 1;
                self.iteration += 1;
                continue;  // ⭐ Don't break - continue to next iteration
            }

            // Wait for task completion by processing events
            // Pass sink for event logging
            let task_completed = self.wait_for_task_complete(codex, sink).await;

            // ⭐ CONTINUE-ON-ERROR: Even if task didn't complete, continue
            if task_completed {
                info!(
                    iteration = self.iteration,
                    elapsed_secs = self.start_time.elapsed().as_secs(),
                    "Iteration succeeded"
                );
            } else {
                warn!(
                    iteration = self.iteration,
                    "Iteration task aborted, continuing to next iteration..."
                );
                self.iterations_failed += 1;
            }

            self.iteration += 1;

            // ⭐ Trigger progress callback after each iteration
            if let Some(ref callback) = self.progress_callback {
                callback(LoopProgress {
                    iteration: self.iteration,
                    succeeded: self.iteration - self.iterations_failed,
                    failed: self.iterations_failed,
                    elapsed_seconds: self.start_time.elapsed().as_secs() as i64,
                });
            }

            // ⭐ Continue to next iteration regardless of success/failure
        }

        let result = LoopResult {
            iterations_attempted: self.iteration,
            iterations_succeeded: self.iteration - self.iterations_failed,
            iterations_failed: self.iterations_failed,
            stop_reason: self.determine_stop_reason(),
            elapsed_seconds: self.start_time.elapsed().as_secs() as i64,
        };

        info!(
            attempted = result.iterations_attempted,
            succeeded = result.iterations_succeeded,
            failed = result.iterations_failed,
            elapsed_secs = result.elapsed_seconds,
            reason = ?result.stop_reason,
            "Loop execution complete"
        );

        result
    }

    /// Determine why loop stopped.
    fn determine_stop_reason(&self) -> LoopStopReason {
        if self.cancellation_token.is_cancelled() {
            return LoopStopReason::Cancelled;
        }

        match &self.condition {
            LoopCondition::Iters { count } => {
                if self.iteration >= *count {
                    LoopStopReason::Completed
                } else {
                    LoopStopReason::TaskAborted
                }
            }
            LoopCondition::Duration { seconds } => {
                if (self.start_time.elapsed().as_secs() as i64) >= *seconds {
                    LoopStopReason::DurationElapsed
                } else {
                    LoopStopReason::TaskAborted
                }
            }
        }
    }

    /// Wait for task completion by consuming events from Codex.
    ///
    /// # Arguments
    /// * `codex` - Codex instance
    /// * `sink` - Optional LogFileSink for event logging
    ///
    /// Returns true if TaskComplete was received, false if aborted.
    async fn wait_for_task_complete(
        &self,
        codex: &Codex,
        sink: Option<&LogFileSink>,  // ⭐ Optional event sink
    ) -> bool {
        loop {
            // Check cancellation
            if self.cancellation_token.is_cancelled() {
                if let Some(s) = sink {
                    s.log("Cancelled by user");
                }
                return false;
            }

            // Get next event from Codex
            match codex.next_event().await {
                Ok(event) => {
                    // ⭐ Log event to sink if provided
                    if let Some(s) = sink {
                        s.log(&format!("{:?}", event.msg));
                    }

                    match event.msg {
                        EventMsg::TaskComplete(_) => return true,
                        EventMsg::TurnAborted(_) => return false,
                        // Continue processing other events (progress, tool calls, etc.)
                        _ => continue,
                    }
                }
                Err(e) => {
                    if let Some(s) = sink {
                        s.log(&format!("Error: {e}"));
                    }
                    warn!(error = %e, "Error receiving event");
                    return false;
                }
            }
        }
    }
}
```

### 5.3 Tests (Including Continue-on-Error)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn should_continue_iters() {
        let token = CancellationToken::new();
        let mut driver = LoopDriver::new(
            LoopCondition::Iters { count: 3 },
            token,
        );

        assert!(driver.should_continue()); // iteration 0 < 3
        driver.iteration = 2;
        assert!(driver.should_continue()); // iteration 2 < 3
        driver.iteration = 3;
        assert!(!driver.should_continue()); // iteration 3 >= 3
    }

    #[test]
    fn should_continue_cancelled() {
        let token = CancellationToken::new();
        let driver = LoopDriver::new(
            LoopCondition::Iters { count: 100 },
            token.clone(),
        );

        assert!(driver.should_continue());
        token.cancel();
        assert!(!driver.should_continue());
    }

    #[test]
    fn build_query_iterations() {
        let token = CancellationToken::new();
        let mut driver = LoopDriver::new(
            LoopCondition::Iters { count: 5 },
            token,
        );

        let original = "Fix the bug";

        // Iteration 0: unchanged
        assert_eq!(driver.build_query(original), original);

        // Iteration 1+: enhanced
        driver.iteration = 1;
        let enhanced = driver.build_query(original);
        assert!(enhanced.contains(original));
        assert!(enhanced.contains("git log"));
    }

    #[test]
    fn loop_result_tracks_failures() {
        // Verify LoopResult correctly tracks both attempted and failed iterations
        let result = LoopResult {
            iterations_attempted: 5,
            iterations_succeeded: 3,
            iterations_failed: 2,
            stop_reason: LoopStopReason::Completed,
            elapsed_seconds: 100,
        };

        assert_eq!(result.iterations_attempted, 5);
        assert_eq!(result.iterations_succeeded, 3);
        assert_eq!(result.iterations_failed, 2);
    }
}
```

---

## 6. Module Exports

**File:** `codex-rs/core/src/loop_driver/mod.rs`

```rust
//! Loop driver for iterative agent execution.
//!
//! This module provides loop/time-based execution control for the agent.
//!
//! # Features
//!
//! - **Count-based loops**: Run N iterations
//! - **Time-based loops**: Run until duration elapsed
//! - **Git-based prompts**: Auto-Coder style iterative improvement
//! - **Continue-on-error**: Iterations continue after single failure
//! - **Cancellation support**: Graceful shutdown via CancellationToken
//!
//! # Example
//!
//! ```rust,ignore
//! use codex_core::loop_driver::{LoopCondition, LoopDriver};
//!
//! let condition = LoopCondition::parse("5")?;  // or "1h"
//! let driver = LoopDriver::new(condition, token);
//!
//! let result = driver.run_with_loop(session, ctx, "query").await;
//!
//! // Check results including any failed iterations
//! println!("Completed {}/{} iterations ({} failed)",
//!     result.iterations_succeeded,
//!     result.iterations_attempted,
//!     result.iterations_failed
//! );
//! ```

mod condition;
mod driver;
mod prompt;

pub use condition::LoopCondition;
pub use driver::{LoopDriver, LoopProgress, LoopResult, LoopStopReason};
pub use prompt::LoopPromptBuilder;
```

---

## 7. CLI Integration

### 7.1 Add CLI Args

**File:** `codex-rs/exec/src/lib.rs`

```rust
/// Number of iterations to run (e.g., 5)
#[arg(long)]
iter: Option<i32>,

/// Duration to run (e.g., "1h", "30m", "5s")
#[arg(long)]
time: Option<String>,
```

### 7.2 Integration Flow

```rust
// In exec main flow
let loop_condition = match (&args.iter, &args.time) {
    (Some(count), None) => Some(LoopCondition::Iters { count: *count }),
    (None, Some(duration)) => Some(LoopCondition::parse(duration)?),
    (None, None) => None,
    (Some(_), Some(_)) => anyhow::bail!("Cannot specify both --iter and --time"),
};

if let Some(condition) = loop_condition {
    let mut driver = LoopDriver::new(condition, cancellation_token.clone());
    let result = driver.run_with_loop(&codex, &query).await;

    // Report results including any failures
    println!("Completed {}/{} iterations ({} failed)",
        result.iterations_succeeded,
        result.iterations_attempted,
        result.iterations_failed
    );
} else {
    // Normal single execution
}
```

### 7.3 Usage Examples

```bash
# Run 5 iterations (continues even if some fail)
just exec --iter 5 "implement feature"

# Run for 1 hour
just exec --time 1h "fix bugs"

# Run for 30 minutes
just exec --time 30m "refactor code"
```

### 7.4 Output Example

```
Starting loop execution: 5 iterations
[Iteration 0] Starting...
[Iteration 0] Succeeded
[Iteration 1] Starting...
[Iteration 1] Failed: timeout, continuing...
[Iteration 2] Starting...
[Iteration 2] Succeeded
[Iteration 3] Starting...
[Iteration 3] Succeeded
[Iteration 4] Starting...
[Iteration 4] Succeeded
Loop execution complete: 5/5 attempted, 4 succeeded, 1 failed
```
