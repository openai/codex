# Loop Context Passing Design Document

> 跨迭代上下文传递增强方案 for LoopDriver / SpawnAgent

**Related Documents:**
- [Loop Driver Design](./loop-driver.md)
- [SpawnTask Design](./spawn-task.md)
- [Overview & Implementation Guide](./loop-spawn-overview.md)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Problem Analysis](#2-problem-analysis)
3. [Solution Design](#3-solution-design)
4. [Data Structures](#4-data-structures)
5. [Module Design](#5-module-design)
6. [Integration Flow](#6-integration-flow)
7. [Prompt Templates](#7-prompt-templates)
8. [compact_v2 Reuse Analysis](#8-compact_v2-reuse-analysis)
9. [Implementation Plan](#9-implementation-plan)
10. [Testing Strategy](#10-testing-strategy)
11. [Configuration Options](#11-configuration-options)

---

## 1. Overview

### 1.1 目标

增强 SpawnAgent 的 LoopDriver，实现跨迭代的上下文传递：

| 阶段 | 动作 |
|-----|-----|
| **初始化** | 保存 plan 内容、base commit ID、initial prompt |
| **每轮结束** | 收集变更文件、生成 summary、执行 git commit |
| **下一轮** | 注入完整的迭代历史上下文到 prompt |

### 1.2 核心思路

```
┌─────────────────────────────────────────────────────────────────────┐
│  内存中的 LoopContext                                                │
│  ├── base_commit_id: "abc123"                                       │
│  ├── initial_prompt: "Implement feature X"                          │
│  ├── plan_content: "## Steps\n1. Create...\n2. Add..."             │
│  └── iterations: [                                                  │
│        { iter: 0, commit: "def456", files: [...], summary: "..." }, │
│        { iter: 1, commit: "ghi789", files: [...], summary: "..." }, │
│      ]                                                              │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│  下一轮 Prompt 注入                                                  │
│  <task_context>                                                     │
│  ## Original Task                                                   │
│  Implement feature X                                                │
│  ## Plan                                                            │
│  1. Create... 2. Add...                                             │
│  ## Previous Iterations                                             │
│  ### Iteration 0 → commit def456                                    │
│  Files: file1.rs, file2.rs                                          │
│  Summary: Implemented basic structure...                            │
│  </task_context>                                                    │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.3 方案选择：混合策略

**复用 compact_v2 的纯函数工具，新建迭代专用组件。**

```
compact_v2/ (复用)                  loop_driver/ (新建/修改)
├── filter_for_summarization() ──→  summarizer.rs
├── is_valid_summary() ──────────→  summarizer.rs
├── cleanup_summary_tags() ──────→  summarizer.rs
├── TokenCounter ────────────────→  summarizer.rs
│
loop_driver/ (新建)
├── context.rs      → LoopContext, IterationRecord
├── summarizer.rs   → 迭代总结, commit message 生成
├── git_ops.rs      → git 命令封装
│
loop_driver/ (修改)
├── prompt.rs       → 增强 prompt 模板
└── driver.rs       → 集成上下文传递逻辑
```

---

## 2. Problem Analysis

### 2.1 当前实现的局限性

**当前 LoopDriver 的迭代机制：**

```rust
// prompt.rs - 当前实现
const DEFAULT_LOOP_INSTRUCTION: &str = r#"
Additional instruction: use git log to get the code changes generated by previous
tasks and try to focus on iterative improvements and refinements and make sure to
use git commit command to make a commit after every single file edit."#;
```

**问题：**

| 问题 | 描述 |
|-----|-----|
| **依赖模型自觉** | 模型可能忘记执行 `git log` 或 `git commit` |
| **无对话历史** | 每轮是独立的 Codex 会话，无历史传递 |
| **唯一上下文是 Git** | 只能通过 git 仓库状态传递信息 |
| **无结构化记录** | 没有每轮的 summary、文件变更记录 |

### 2.2 对比 Auto-Coder

| 特性 | **Codex (当前)** | **Auto-Coder** |
|-----|-----------------|----------------|
| **对话历史** | ❌ 每轮独立会话 | ✅ 数据库持久化 |
| **上下文传递** | 仅靠 prompt 指示 | 对话历史 + git + checkpoint |
| **Commit 处理** | 依赖模型自觉 | LLM 生成 commit message |
| **Summary** | 无 | 有 pruning 机制 |

### 2.3 设计目标

1. **结构化上下文记录**：每轮保存 commit ID、变更文件、summary
2. **流程保证 commit**：不依赖模型自觉，由框架执行 commit
3. **增强 prompt 注入**：下一轮注入完整的迭代历史
4. **复用现有能力**：复用 compact_v2 的 message 过滤和 summary 验证

---

## 3. Solution Design

### 3.1 架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│  SpawnAgent                                                             │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  LoopDriver (enhanced)                                            │  │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐         │  │
│  │  │ LoopContext   │  │ Summarizer    │  │ GitOps        │         │  │
│  │  │ (context.rs)  │  │ (summarizer.rs)│  │ (git_ops.rs)  │         │  │
│  │  └───────────────┘  └───────────────┘  └───────────────┘         │  │
│  │         │                   │                   │                 │  │
│  │         └───────────────────┼───────────────────┘                 │  │
│  │                             ↓                                     │  │
│  │  ┌───────────────────────────────────────────────────────────┐   │  │
│  │  │  run_with_loop() - 增强版                                  │   │  │
│  │  │  1. 初始化: 保存 base commit, prompt, plan                 │   │  │
│  │  │  2. 每轮: submit → wait → collect → summary → commit       │   │  │
│  │  │  3. 下轮: 组装增强 prompt                                   │   │  │
│  │  └───────────────────────────────────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                    │                                    │
│                                    ↓                                    │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  Codex Session (内存中)                                           │  │
│  │  - 获取 history: session.clone_history().get_history()           │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 执行流程

```
Phase 1: 初始化
─────────────────────────────────────────────────────────────────────────
1. base_commit_id = git rev-parse HEAD
2. initial_prompt = user query
3. plan_content = read plan file (if exists)
4. LoopContext = { base_commit_id, initial_prompt, plan_content, iterations: [] }


Phase 2: 迭代执行 (iteration = 0)
─────────────────────────────────────────────────────────────────────────
1. prompt = initial_prompt (第0轮不注入历史)
2. codex.submit(Op::UserInput { items: [prompt] })
3. wait_for_task_complete() → success
4. 获取 session history (从 Codex 内部)
5. messages → filter_for_summarization() → LLM → summary
6. git status --porcelain → changed_files
7. 如果有变更:
   - LLM 生成 commit message
   - git add -A && git commit
   - commit_id = git rev-parse HEAD
8. LoopContext.iterations.push(IterationRecord { ... })


Phase 3: 迭代执行 (iteration >= 1)
─────────────────────────────────────────────────────────────────────────
1. prompt = build_enhanced_prompt(initial_prompt, iteration, LoopContext)
   包含:
   - <task_context> 标签
   - Original Task
   - Plan
   - Progress (iteration N of M)
   - Previous Iterations (每轮的 commit, files, summary)
   - DO NOT commit 指令
2. (同 Phase 2 的步骤 2-8)


Phase 4: 完成
─────────────────────────────────────────────────────────────────────────
1. 保存 LoopContext 到 metadata
2. 返回 LoopResult
```

---

## 4. Data Structures

### 4.1 LoopContext

**File:** `codex-rs/core/src/loop_driver/context.rs`

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// 循环执行的完整上下文
///
/// 存储跨迭代的状态信息，用于构建增强 prompt 和持久化记录。
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoopContext {
    // === 初始状态 (在第一次迭代前设置) ===

    /// 任务开始时的 HEAD commit ID
    /// 用于确定变更的基准点
    pub base_commit_id: String,

    /// 用户的原始 prompt
    /// 每轮都会作为任务描述注入
    pub initial_prompt: String,

    /// Plan 文件内容 (如果存在)
    /// 来自 .claude/plans/*.md 或 forked_plan_content
    pub plan_content: Option<String>,

    // === 迭代记录 (每轮追加) ===

    /// 所有已完成迭代的记录
    pub iterations: Vec<IterationRecord>,

    // === 运行时配置 ===

    /// 总迭代次数 (来自 LoopCondition::Iters)
    /// 对于 Duration 模式，设置为 -1
    pub total_iterations: i32,
}

/// 单轮迭代的记录
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IterationRecord {
    /// 迭代编号 (0-indexed)
    pub iteration: i32,

    /// 本轮的 commit ID (如果有提交)
    /// None 表示本轮没有文件变更
    pub commit_id: Option<String>,

    /// 本轮修改的文件列表
    pub changed_files: Vec<String>,

    /// 本轮工作的 summary (LLM 生成)
    pub summary: String,

    /// 本轮是否成功完成
    pub success: bool,

    /// 完成时间戳
    pub timestamp: DateTime<Utc>,
}
```

### 4.2 方法实现

```rust
impl LoopContext {
    /// 创建新的 LoopContext
    pub fn new(
        base_commit_id: String,
        initial_prompt: String,
        plan_content: Option<String>,
        total_iterations: i32,
    ) -> Self {
        Self {
            base_commit_id,
            initial_prompt,
            plan_content,
            iterations: Vec::new(),
            total_iterations,
        }
    }

    /// 添加迭代记录
    pub fn add_iteration(&mut self, record: IterationRecord) {
        self.iterations.push(record);
    }

    /// 获取当前迭代编号 (下一个要执行的)
    pub fn current_iteration(&self) -> i32 {
        self.iterations.len() as i32
    }

    /// 获取成功的迭代数
    pub fn successful_iterations(&self) -> i32 {
        self.iterations.iter().filter(|r| r.success).count() as i32
    }

    /// 获取失败的迭代数
    pub fn failed_iterations(&self) -> i32 {
        self.iterations.iter().filter(|r| !r.success).count() as i32
    }

    /// 格式化为 prompt 注入格式
    pub fn format_for_prompt(&self, current_iteration: i32) -> String {
        // 实现见 Section 7
    }
}

impl IterationRecord {
    /// 创建新的迭代记录
    pub fn new(
        iteration: i32,
        commit_id: Option<String>,
        changed_files: Vec<String>,
        summary: String,
        success: bool,
    ) -> Self {
        Self {
            iteration,
            commit_id,
            changed_files,
            summary,
            success,
            timestamp: Utc::now(),
        }
    }

    /// 格式化 commit 状态
    pub fn commit_status(&self) -> String {
        match &self.commit_id {
            Some(id) => format!("commit {}", &id[..7]),
            None => "no changes".to_string(),
        }
    }

    /// 格式化文件列表
    pub fn files_display(&self) -> String {
        if self.changed_files.is_empty() {
            "none".to_string()
        } else if self.changed_files.len() <= 5 {
            self.changed_files.join(", ")
        } else {
            format!(
                "{}, ... ({} more)",
                self.changed_files[..5].join(", "),
                self.changed_files.len() - 5
            )
        }
    }
}
```

---

## 5. Module Design

### 5.1 git_ops.rs

**File:** `codex-rs/core/src/loop_driver/git_ops.rs`

```rust
//! Git operations for loop driver context passing.

use crate::error::CodexErr;
use std::path::Path;
use std::process::Command;

/// 获取当前 HEAD commit ID
pub async fn get_head_commit(cwd: &Path) -> Result<String, CodexErr> {
    let output = tokio::task::spawn_blocking({
        let cwd = cwd.to_path_buf();
        move || {
            Command::new("git")
                .args(["rev-parse", "HEAD"])
                .current_dir(&cwd)
                .output()
        }
    })
    .await
    .map_err(|e| CodexErr::Fatal(format!("Failed to spawn git task: {e}")))?
    .map_err(|e| CodexErr::Fatal(format!("Failed to run git rev-parse: {e}")))?;

    if !output.status.success() {
        return Err(CodexErr::Fatal(format!(
            "git rev-parse failed: {}",
            String::from_utf8_lossy(&output.stderr)
        )));
    }

    Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())
}

/// 获取未提交的变更文件列表
///
/// 使用 `git status --porcelain` 获取所有未提交的变更
pub async fn get_uncommitted_changes(cwd: &Path) -> Result<Vec<String>, CodexErr> {
    let output = tokio::task::spawn_blocking({
        let cwd = cwd.to_path_buf();
        move || {
            Command::new("git")
                .args(["status", "--porcelain"])
                .current_dir(&cwd)
                .output()
        }
    })
    .await
    .map_err(|e| CodexErr::Fatal(format!("Failed to spawn git task: {e}")))?
    .map_err(|e| CodexErr::Fatal(format!("Failed to run git status: {e}")))?;

    let stdout = String::from_utf8_lossy(&output.stdout);
    let files: Vec<String> = stdout
        .lines()
        .filter_map(|line| {
            // git status --porcelain 格式: "XY filename"
            // X = staged status, Y = unstaged status
            let trimmed = line.trim();
            if trimmed.len() > 3 {
                Some(trimmed[3..].to_string())
            } else {
                None
            }
        })
        .collect();

    Ok(files)
}

/// 获取两个 commit 之间的变更文件
pub async fn get_changed_files_since(
    cwd: &Path,
    base_commit: &str,
) -> Result<Vec<String>, CodexErr> {
    let output = tokio::task::spawn_blocking({
        let cwd = cwd.to_path_buf();
        let base = base_commit.to_string();
        move || {
            Command::new("git")
                .args(["diff", "--name-only", &base, "HEAD"])
                .current_dir(&cwd)
                .output()
        }
    })
    .await
    .map_err(|e| CodexErr::Fatal(format!("Failed to spawn git task: {e}")))?
    .map_err(|e| CodexErr::Fatal(format!("Failed to run git diff: {e}")))?;

    let stdout = String::from_utf8_lossy(&output.stdout);
    let files: Vec<String> = stdout
        .lines()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();

    Ok(files)
}

/// 执行 commit (如果有变更)
///
/// 返回 commit ID 或 None (如果没有变更)
pub async fn commit_if_needed(
    cwd: &Path,
    message: &str,
) -> Result<Option<String>, CodexErr> {
    // 1. 检查是否有变更
    let changes = get_uncommitted_changes(cwd).await?;
    if changes.is_empty() {
        return Ok(None);
    }

    // 2. git add -A
    let add_output = tokio::task::spawn_blocking({
        let cwd = cwd.to_path_buf();
        move || {
            Command::new("git")
                .args(["add", "-A"])
                .current_dir(&cwd)
                .output()
        }
    })
    .await
    .map_err(|e| CodexErr::Fatal(format!("Failed to spawn git add: {e}")))?
    .map_err(|e| CodexErr::Fatal(format!("Failed to run git add: {e}")))?;

    if !add_output.status.success() {
        return Err(CodexErr::Fatal(format!(
            "git add failed: {}",
            String::from_utf8_lossy(&add_output.stderr)
        )));
    }

    // 3. git commit
    let commit_output = tokio::task::spawn_blocking({
        let cwd = cwd.to_path_buf();
        let msg = message.to_string();
        move || {
            Command::new("git")
                .args(["commit", "-m", &msg])
                .current_dir(&cwd)
                .output()
        }
    })
    .await
    .map_err(|e| CodexErr::Fatal(format!("Failed to spawn git commit: {e}")))?
    .map_err(|e| CodexErr::Fatal(format!("Failed to run git commit: {e}")))?;

    if !commit_output.status.success() {
        let stderr = String::from_utf8_lossy(&commit_output.stderr);
        // 如果是 "nothing to commit" 不算错误
        if stderr.contains("nothing to commit") {
            return Ok(None);
        }
        return Err(CodexErr::Fatal(format!("git commit failed: {stderr}")));
    }

    // 4. 获取新的 commit ID
    let commit_id = get_head_commit(cwd).await?;
    Ok(Some(commit_id))
}

/// 读取 plan 文件 (如果存在)
pub async fn read_plan_file_if_exists(cwd: &Path) -> Option<String> {
    // 查找 .claude/plans/*.md
    let plans_dir = cwd.join(".claude").join("plans");
    if !plans_dir.exists() {
        return None;
    }

    // 读取目录中最新的 .md 文件
    let entries = match std::fs::read_dir(&plans_dir) {
        Ok(e) => e,
        Err(_) => return None,
    };

    let mut latest_file: Option<(std::path::PathBuf, std::time::SystemTime)> = None;

    for entry in entries.flatten() {
        let path = entry.path();
        if path.extension().map(|e| e == "md").unwrap_or(false) {
            if let Ok(metadata) = entry.metadata() {
                if let Ok(modified) = metadata.modified() {
                    match &latest_file {
                        None => latest_file = Some((path, modified)),
                        Some((_, prev_time)) if modified > *prev_time => {
                            latest_file = Some((path, modified));
                        }
                        _ => {}
                    }
                }
            }
        }
    }

    if let Some((path, _)) = latest_file {
        std::fs::read_to_string(&path).ok()
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_get_head_commit_in_git_repo() {
        // 在当前项目目录测试
        let cwd = std::env::current_dir().unwrap();
        let result = get_head_commit(&cwd).await;
        // 如果在 git repo 中应该成功
        assert!(result.is_ok() || result.is_err());
    }

    #[tokio::test]
    async fn test_get_uncommitted_changes_empty() {
        let temp = TempDir::new().unwrap();
        // 初始化空 git repo
        Command::new("git")
            .args(["init"])
            .current_dir(temp.path())
            .output()
            .unwrap();

        let changes = get_uncommitted_changes(temp.path()).await.unwrap();
        assert!(changes.is_empty());
    }
}
```

### 5.2 summarizer.rs

**File:** `codex-rs/core/src/loop_driver/summarizer.rs`

```rust
//! Iteration summarization and commit message generation.
//!
//! Reuses compact_v2 components for message filtering and validation.

use crate::client::ModelClient;
use crate::compact_v2::{
    cleanup_summary_tags,
    filter_for_summarization,
    is_valid_summary,
    TokenCounter,
};
use crate::error::CodexErr;
use codex_protocol::models::ResponseItem;
use std::sync::Arc;

/// 迭代总结的系统 prompt
const ITERATION_SUMMARY_SYSTEM_PROMPT: &str = r#"You are a concise technical summarizer.
Your task is to summarize an AI agent's work in a single iteration.
Be factual and brief. Focus on what was actually done, not what was planned."#;

/// 迭代总结的用户 prompt 模板
const ITERATION_SUMMARY_USER_PROMPT: &str = r#"Summarize this agent iteration in 3-5 sentences:

1. What task was attempted
2. What was accomplished (files created/modified, features implemented)
3. Key decisions made or blockers encountered

This summary will be passed to the next iteration for context continuity.
Output ONLY the summary text, no explanations or formatting.

Agent conversation to summarize:
{messages}"#;

/// Commit message 生成的系统 prompt
const COMMIT_MSG_SYSTEM_PROMPT: &str = r#"You are a git commit message generator.
Generate clear, conventional commit messages following this format:
- First line: [iter-N] Brief description (max 50 chars)
- Blank line
- Body: What was done (2-3 lines max)

Output ONLY the commit message, nothing else."#;

/// Commit message 生成的用户 prompt 模板
const COMMIT_MSG_USER_PROMPT: &str = r#"Generate a git commit message for this iteration.

Iteration: {iteration}
Task (truncated): {task}
Changed files: {files}
Summary: {summary}

Output ONLY the commit message."#;

/// 生成迭代总结
///
/// 使用 compact_v2 的 filter_for_summarization 过滤 messages，
/// 然后调用 LLM 生成简短摘要。
pub async fn summarize_iteration(
    messages: &[ResponseItem],
    client: Arc<ModelClient>,
) -> Result<String, CodexErr> {
    // 1. 过滤 messages (复用 compact_v2)
    let filtered = filter_for_summarization(messages);
    if filtered.is_empty() {
        return Ok("No significant actions in this iteration.".to_string());
    }

    // 2. 序列化 messages 为文本
    let messages_text = format_messages_for_summary(&filtered);

    // 3. 构建 prompt
    let user_prompt = ITERATION_SUMMARY_USER_PROMPT.replace("{messages}", &messages_text);

    // 4. 调用 LLM
    let response = client
        .simple_completion(ITERATION_SUMMARY_SYSTEM_PROMPT, &user_prompt)
        .await
        .map_err(|e| CodexErr::Fatal(format!("Failed to generate summary: {e}")))?;

    // 5. 验证响应 (复用 compact_v2)
    if !is_valid_summary(&response) {
        return Ok("Summary generation produced invalid output.".to_string());
    }

    // 6. 清理 XML tags (复用 compact_v2)
    Ok(cleanup_summary_tags(&response))
}

/// 生成 commit message
pub async fn generate_commit_message(
    iteration: i32,
    task: &str,
    files: &[String],
    summary: &str,
    client: Arc<ModelClient>,
) -> Result<String, CodexErr> {
    // 截断 task 到合理长度
    let task_truncated = if task.len() > 200 {
        format!("{}...", &task[..200])
    } else {
        task.to_string()
    };

    // 格式化文件列表
    let files_str = if files.len() <= 10 {
        files.join(", ")
    } else {
        format!("{}, ... ({} more)", files[..10].join(", "), files.len() - 10)
    };

    // 构建 prompt
    let user_prompt = COMMIT_MSG_USER_PROMPT
        .replace("{iteration}", &iteration.to_string())
        .replace("{task}", &task_truncated)
        .replace("{files}", &files_str)
        .replace("{summary}", summary);

    // 调用 LLM
    let response = client
        .simple_completion(COMMIT_MSG_SYSTEM_PROMPT, &user_prompt)
        .await
        .map_err(|e| CodexErr::Fatal(format!("Failed to generate commit message: {e}")))?;

    // 确保 commit message 格式正确
    let cleaned = response.trim();
    if cleaned.is_empty() {
        // Fallback commit message
        return Ok(format!(
            "[iter-{}] Iteration {} changes\n\n{}",
            iteration, iteration, summary
        ));
    }

    Ok(cleaned.to_string())
}

/// 格式化 messages 为可读文本
fn format_messages_for_summary(messages: &[ResponseItem]) -> String {
    let counter = TokenCounter::default();
    let mut result = Vec::new();
    let mut total_tokens = 0;
    const MAX_TOKENS: i64 = 4000; // 限制输入长度

    for item in messages {
        let text = format_single_message(item);
        let tokens = counter.approximate(&text);

        if total_tokens + tokens > MAX_TOKENS {
            result.push("[... truncated for length ...]".to_string());
            break;
        }

        result.push(text);
        total_tokens += tokens;
    }

    result.join("\n\n")
}

/// 格式化单个 message
fn format_single_message(item: &ResponseItem) -> String {
    match item {
        ResponseItem::Message { role, content, .. } => {
            let content_text: Vec<String> = content
                .iter()
                .filter_map(|c| match c {
                    codex_protocol::models::ContentItem::InputText { text } => Some(text.clone()),
                    codex_protocol::models::ContentItem::OutputText { text } => Some(text.clone()),
                    _ => None,
                })
                .collect();
            format!("[{}]: {}", role, content_text.join("\n"))
        }
        ResponseItem::FunctionCall { name, arguments, .. } => {
            format!("[tool_use]: {} - {}", name, truncate_str(arguments, 200))
        }
        ResponseItem::FunctionCallOutput { output, .. } => {
            format!("[tool_result]: {}", truncate_str(output, 500))
        }
        _ => String::new(),
    }
}

/// 截断字符串
fn truncate_str(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        s.to_string()
    } else {
        format!("{}...", &s[..max_len])
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use codex_protocol::models::ContentItem;
    use pretty_assertions::assert_eq;

    fn make_user_msg(text: &str) -> ResponseItem {
        ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![ContentItem::InputText {
                text: text.to_string(),
            }],
        }
    }

    fn make_assistant_msg(text: &str) -> ResponseItem {
        ResponseItem::Message {
            id: None,
            role: "assistant".to_string(),
            content: vec![ContentItem::OutputText {
                text: text.to_string(),
            }],
        }
    }

    #[test]
    fn test_format_messages_basic() {
        let messages = vec![
            make_user_msg("Implement feature X"),
            make_assistant_msg("I'll help you implement feature X."),
        ];

        let result = format_messages_for_summary(&messages);
        assert!(result.contains("[user]: Implement feature X"));
        assert!(result.contains("[assistant]: I'll help you"));
    }

    #[test]
    fn test_truncate_str() {
        assert_eq!(truncate_str("hello", 10), "hello");
        assert_eq!(truncate_str("hello world", 5), "hello...");
    }
}
```

---

## 6. Integration Flow

### 6.1 LoopDriver 修改

**File:** `codex-rs/core/src/loop_driver/driver.rs`

#### 新增字段

```rust
pub struct LoopDriver {
    condition: LoopCondition,
    start_time: Instant,
    iteration: i32,
    iterations_failed: i32,
    cancellation_token: CancellationToken,
    custom_loop_prompt: Option<String>,
    progress_callback: Option<Box<dyn Fn(LoopProgress) + Send + Sync>>,

    // === 新增: 上下文传递 ===

    /// 循环上下文 (可选，启用上下文传递时使用)
    context: Option<LoopContext>,

    /// 工作目录 (用于 git 操作)
    cwd: Option<PathBuf>,

    /// ModelClient 引用 (用于生成 summary 和 commit message)
    model_client: Option<Arc<ModelClient>>,
}
```

#### 新增方法

```rust
impl LoopDriver {
    /// 启用上下文传递
    ///
    /// 调用后，每轮迭代将:
    /// 1. 收集变更文件
    /// 2. 生成 iteration summary
    /// 3. 执行 git commit
    /// 4. 将历史注入下一轮 prompt
    pub fn with_context_passing(
        mut self,
        base_commit: String,
        initial_prompt: String,
        plan_content: Option<String>,
        cwd: PathBuf,
        model_client: Arc<ModelClient>,
    ) -> Self {
        let total = match &self.condition {
            LoopCondition::Iters { count } => *count,
            LoopCondition::Duration { .. } => -1, // Unknown for duration mode
        };

        self.context = Some(LoopContext::new(
            base_commit,
            initial_prompt,
            plan_content,
            total,
        ));
        self.cwd = Some(cwd);
        self.model_client = Some(model_client);
        self
    }

    /// 构建 prompt (支持上下文增强)
    fn build_prompt_with_context(&self, original: &str) -> String {
        match &self.context {
            Some(ctx) if self.iteration > 0 => {
                prompt::build_enhanced_prompt(original, self.iteration, ctx)
            }
            _ => self.build_query(original),
        }
    }
}
```

#### 修改 run_with_loop()

```rust
pub async fn run_with_loop(
    &mut self,
    codex: &Codex,
    original_query: &str,
    sink: Option<&LogFileSink>,
) -> LoopResult {
    info!(
        condition = %self.condition.display(),
        context_enabled = self.context.is_some(),
        "Starting loop execution"
    );

    while self.should_continue() {
        // 1. 构建 prompt (使用 context 如果启用)
        let query = self.build_prompt_with_context(original_query);
        let input = vec![UserInput::Text { text: query }];

        if let Some(s) = sink {
            s.log(&format!("Iteration {}: Starting...", self.iteration));
        }

        // 2. 提交执行
        if let Err(e) = codex.submit(Op::UserInput { items: input }).await {
            warn!(iteration = self.iteration, error = %e, "Iteration failed to submit");
            self.iterations_failed += 1;
            self.iteration += 1;
            continue;
        }

        // 3. 等待完成
        let success = self.wait_for_task_complete(codex, sink).await;

        // 4. 如果启用上下文传递，处理本轮结果
        if self.context.is_some() {
            self.process_iteration_context(codex, success, sink).await;
        }

        // 5. 更新计数
        if !success {
            self.iterations_failed += 1;
        }
        self.iteration += 1;

        // 6. 触发 progress callback
        if let Some(ref callback) = self.progress_callback {
            callback(LoopProgress {
                iteration: self.iteration,
                succeeded: self.iteration - self.iterations_failed,
                failed: self.iterations_failed,
                elapsed_seconds: self.start_time.elapsed().as_secs() as i64,
            });
        }
    }

    // 返回结果
    LoopResult {
        iterations_attempted: self.iteration,
        iterations_succeeded: self.iteration - self.iterations_failed,
        iterations_failed: self.iterations_failed,
        stop_reason: self.determine_stop_reason(),
        elapsed_seconds: self.start_time.elapsed().as_secs() as i64,
    }
}

/// 处理迭代上下文 (收集变更、生成 summary、执行 commit)
async fn process_iteration_context(
    &mut self,
    codex: &Codex,
    success: bool,
    sink: Option<&LogFileSink>,
) {
    let ctx = match self.context.as_mut() {
        Some(c) => c,
        None => return,
    };

    let cwd = match &self.cwd {
        Some(c) => c.clone(),
        None => return,
    };

    // 4a. 获取变更文件
    let changed_files = git_ops::get_uncommitted_changes(&cwd)
        .await
        .unwrap_or_default();

    // 4b. 生成 summary
    let summary = if let Some(client) = &self.model_client {
        // 获取 session history (需要 Codex 暴露此方法)
        let messages = codex.get_current_history().await.unwrap_or_default();
        summarizer::summarize_iteration(&messages, client.clone())
            .await
            .unwrap_or_else(|e| {
                warn!(error = %e, "Failed to generate summary");
                "Summary generation failed".to_string()
            })
    } else {
        "No summary (client not available)".to_string()
    };

    if let Some(s) = sink {
        s.log(&format!("Iteration {} summary: {}", self.iteration, &summary));
    }

    // 4c. 执行 commit (如果有变更)
    let commit_id = if !changed_files.is_empty() {
        if let Some(client) = &self.model_client {
            match summarizer::generate_commit_message(
                self.iteration,
                &ctx.initial_prompt,
                &changed_files,
                &summary,
                client.clone(),
            )
            .await
            {
                Ok(msg) => {
                    match git_ops::commit_if_needed(&cwd, &msg).await {
                        Ok(id) => {
                            if let Some(s) = sink {
                                if let Some(ref commit) = id {
                                    s.log(&format!("Committed: {}", &commit[..7]));
                                }
                            }
                            id
                        }
                        Err(e) => {
                            warn!(error = %e, "Failed to commit");
                            None
                        }
                    }
                }
                Err(e) => {
                    warn!(error = %e, "Failed to generate commit message");
                    None
                }
            }
        } else {
            None
        }
    } else {
        None
    };

    // 4d. 记录本轮
    ctx.add_iteration(IterationRecord::new(
        self.iteration,
        commit_id,
        changed_files,
        summary,
        success,
    ));
}
```

### 6.2 Session History 访问

**File:** `codex-rs/core/src/codex.rs`

```rust
impl Session {
    /// 获取当前会话的 history (供 LoopDriver 使用)
    ///
    /// 返回经过规范化的 ResponseItem 列表。
    /// 注意：如果发生过 compact，返回的是 compact 后的历史。
    pub(crate) async fn get_current_history(&self) -> Result<Vec<ResponseItem>, CodexErr> {
        Ok(self.state.lock().await.clone_history().get_history())
    }
}

// Codex 公开方法 (如果需要从外部访问)
impl Codex {
    /// 获取当前会话的 history
    pub async fn get_current_history(&self) -> Result<Vec<ResponseItem>, CodexErr> {
        self.session.get_current_history().await
    }
}
```

---

## 7. Prompt Templates

### 7.1 增强 Prompt 模板

**File:** `codex-rs/core/src/loop_driver/prompt.rs` (新增部分)

```rust
/// 迭代上下文模板
const LOOP_CONTEXT_TEMPLATE: &str = r#"<task_context>
## Original Task
{initial_prompt}

{plan_section}
## Progress
Iteration: {current} of {total}
Base commit: {base_commit_id}

## Previous Iterations
{iteration_records}
</task_context>

IMPORTANT:
- DO NOT run git commit yourself - the system handles commits automatically
- Focus on making improvements and refinements based on previous work
- You can use git diff/log to review detailed changes if needed
- Each iteration should build upon the previous ones
"#;

/// Plan section 模板 (可选)
const PLAN_SECTION_TEMPLATE: &str = r#"## Plan
{plan_content}

"#;

/// 单轮记录模板
const ITERATION_RECORD_TEMPLATE: &str = r#"### Iteration {iteration} → {commit_status}
Files: {files}
Summary: {summary}
"#;

/// 构建增强 prompt
pub fn build_enhanced_prompt(
    original: &str,
    iteration: i32,
    context: &LoopContext,
) -> String {
    // 构建 plan section
    let plan_section = match &context.plan_content {
        Some(plan) => PLAN_SECTION_TEMPLATE.replace("{plan_content}", plan),
        None => String::new(),
    };

    // 构建迭代记录
    let iteration_records: String = context
        .iterations
        .iter()
        .map(|record| {
            ITERATION_RECORD_TEMPLATE
                .replace("{iteration}", &record.iteration.to_string())
                .replace("{commit_status}", &record.commit_status())
                .replace("{files}", &record.files_display())
                .replace("{summary}", &record.summary)
        })
        .collect::<Vec<_>>()
        .join("\n");

    // 格式化总迭代数
    let total_str = if context.total_iterations > 0 {
        context.total_iterations.to_string()
    } else {
        "ongoing".to_string()
    };

    // 构建完整 prompt
    let context_block = LOOP_CONTEXT_TEMPLATE
        .replace("{initial_prompt}", &context.initial_prompt)
        .replace("{plan_section}", &plan_section)
        .replace("{current}", &(iteration + 1).to_string()) // 1-indexed for display
        .replace("{total}", &total_str)
        .replace("{base_commit_id}", &context.base_commit_id)
        .replace("{iteration_records}", &iteration_records);

    format!("{}\n\n{}", context_block, original)
}
```

### 7.2 示例输出

**Iteration 2 的 Prompt:**

```
<task_context>
## Original Task
Implement user authentication with JWT tokens

## Plan
1. Create User model
2. Add login endpoint
3. Implement JWT middleware
4. Add tests

## Progress
Iteration: 3 of 5
Base commit: abc1234

## Previous Iterations
### Iteration 0 → commit def5678
Files: src/models/user.rs, src/models/mod.rs
Summary: Created User model with email/password fields and validation.

### Iteration 1 → commit ghi9012
Files: src/routes/auth.rs, src/routes/mod.rs
Summary: Added login endpoint with password verification. Returns JWT on success.

</task_context>

IMPORTANT:
- DO NOT run git commit yourself - the system handles commits automatically
- Focus on making improvements and refinements based on previous work
- You can use git diff/log to review detailed changes if needed
- Each iteration should build upon the previous ones

Implement user authentication with JWT tokens

Additional instruction: use git log to get the code changes generated by previous
tasks and try to focus on iterative improvements and refinements and make sure to
use git commit command to make a commit after every single file edit.
```

---

## 8. compact_v2 Reuse Analysis

### 8.1 复用组件清单

| 组件 | 位置 | 用途 | 复用方式 |
|-----|-----|-----|---------|
| `filter_for_summarization()` | `compact_v2/message_filter.rs` | 过滤 synthetic messages | 直接 `use` |
| `is_valid_summary()` | `compact_v2/summary.rs` | 验证 LLM 输出 | 直接 `use` |
| `cleanup_summary_tags()` | `compact_v2/summary.rs` | 清理 XML tags | 直接 `use` |
| `TokenCounter` | `compact_v2/token_counter.rs` | 估算 token 数 | 直接 `use` |
| `collect_user_message_texts()` | `compact_v2/message_filter.rs` | 收集用户消息 | 可选使用 |

### 8.2 不复用的组件

| 组件 | 原因 |
|-----|-----|
| `generate_summarization_prompt()` | 为对话级压缩设计，需要专用 prompt |
| `create_summary_message()` | 格式为对话恢复设计，不适合迭代记录 |
| `CompactBoundary` | 对话级边界概念，不适用 |
| `restore_context()` | 对话级上下文恢复，不适用 |
| `CompactState` | 对话级状态追踪，不适用 |

### 8.3 filter_for_summarization 过滤规则

```rust
// 过滤掉的 message 类型:
- GhostSnapshot         // 内部 git 快照
- Compaction           // 压缩标记
- Other                // 未知类型
- system reminders     // 系统提醒
- progress messages    // 进度消息
- synthetic errors     // 合成错误
- thinking-only blocks // 仅思考内容
- previous summaries   // 之前的摘要
```

---

## 9. Implementation Plan

### 9.1 文件清单

#### 新建文件

| 文件 | 行数 | 优先级 |
|-----|-----|-------|
| `codex-rs/core/src/loop_driver/context.rs` | ~100 | P0 |
| `codex-rs/core/src/loop_driver/git_ops.rs` | ~150 | P0 |
| `codex-rs/core/src/loop_driver/summarizer.rs` | ~180 | P1 |

#### 修改文件

| 文件 | 修改行数 | 优先级 |
|-----|---------|-------|
| `codex-rs/core/src/loop_driver/mod.rs` | ~15 | P0 |
| `codex-rs/core/src/loop_driver/prompt.rs` | ~80 | P1 |
| `codex-rs/core/src/loop_driver/driver.rs` | ~120 | P1 |
| `codex-rs/core/src/spawn_task/agent/agent.rs` | ~40 | P2 |
| `codex-rs/core/src/codex.rs` | ~15 | P2 |

### 9.2 实现顺序

```
Phase 1: 基础设施 (无依赖)
────────────────────────────
1. context.rs    - 数据结构定义
2. git_ops.rs    - Git 命令封装
3. mod.rs        - 导出新模块

Phase 2: 核心功能 (依赖 Phase 1)
────────────────────────────────
4. summarizer.rs - 迭代总结 (复用 compact_v2)
5. prompt.rs     - 增强 prompt 模板

Phase 3: 集成 (依赖 Phase 1-2)
────────────────────────────────
6. driver.rs     - LoopDriver 集成
7. codex.rs      - 暴露 history 方法
8. agent.rs      - SpawnAgent 启用
```

### 9.3 估算工作量

| Phase | 文件数 | 代码行数 | 复杂度 |
|-------|-------|---------|-------|
| Phase 1 | 3 | ~265 | 低 |
| Phase 2 | 2 | ~260 | 中 |
| Phase 3 | 3 | ~175 | 中 |
| **Total** | **8** | **~700** | - |

---

## 10. Testing Strategy

### 10.1 单元测试

```rust
// context.rs
#[test] fn test_loop_context_new()
#[test] fn test_loop_context_add_iteration()
#[test] fn test_loop_context_format_for_prompt()
#[test] fn test_iteration_record_commit_status()
#[test] fn test_iteration_record_files_display()

// git_ops.rs
#[test] fn test_get_head_commit()
#[test] fn test_get_uncommitted_changes()
#[test] fn test_commit_if_needed()
#[test] fn test_read_plan_file()

// summarizer.rs
#[test] fn test_format_messages_for_summary()
#[test] fn test_truncate_str()

// prompt.rs
#[test] fn test_build_enhanced_prompt_first_iteration()
#[test] fn test_build_enhanced_prompt_with_history()
#[test] fn test_build_enhanced_prompt_with_plan()
```

### 10.2 集成测试

```rust
// tests/loop_context_integration.rs

#[tokio::test]
async fn test_full_loop_with_context_passing() {
    // 1. 创建临时 git repo
    // 2. 初始化 LoopDriver with context
    // 3. 执行多轮迭代
    // 4. 验证 commit 历史
    // 5. 验证 context 记录
}

#[tokio::test]
async fn test_context_passing_with_failures() {
    // 测试某轮失败后继续
}

#[tokio::test]
async fn test_context_passing_no_changes() {
    // 测试某轮无文件变更
}
```

---

## 11. Configuration Options

### 11.1 未来扩展配置

```toml
# config.toml

[spawn_task.context_passing]
# 是否启用上下文传递 (默认 true)
enabled = true

# 是否自动 commit (默认 true)
auto_commit = true

# 是否生成 summary (默认 true)
generate_summary = true

# Summary 最大 token 数
summary_max_tokens = 500

# Commit message 模型 (可选，默认用主模型)
commit_message_model = "haiku"
```

### 11.2 配置优先级

1. 代码默认值
2. `config.toml` 配置
3. CLI 参数覆盖 (未来)

---

## Summary

本设计文档描述了 LoopDriver 上下文传递增强方案，采用混合策略：

1. **复用 compact_v2** 的 message 过滤和 summary 验证能力
2. **新建独立模块** 处理 git 操作和迭代专用 summarization
3. **增强 prompt 模板** 注入完整的迭代历史上下文
4. **流程保证 commit** 不依赖模型自觉执行

预计新增/修改代码约 700 行，分 3 个 Phase 实现。
