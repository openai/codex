# Codex機能拡張統合の要求仕様書

## 背景

OpenAIが提供する「Codex」は、ターミナル上で動作する軽量のコーディングエージェントであり、対話を通じてコードの生成・編集やテスト実行など開発支援を行います 。現行のOpenAI版Codex（以下「本家Codex」）は、VS CodeやCursorといったIDEとの連携、GitHubプルリクエストレビュー機能、シングルスレッドでの非同期タスク実行、Web/ターミナル統合といった基本機能を備えています 。一方で、コミュニティにおける派生版であるzapabob氏のCodex（以下「zapabob版Codex」）では、本家Codexにはない高度な機能拡張が多数実装されています 。主な相違点として、zapabob版Codexはエージェントのオーケストレーション（編成管理）方法に革新的な改良が加えられており、複数エージェントの並列実行や動的生成、エージェント自身による自己呼び出し（メタオーケストレーション）などを可能にしています 。またCLI上の対話フローやファイル編集操作に関しても、独自のフック機構やカスタムコマンド体系を備え、利便性の向上が図られています。セキュリティ面では、本家Codexがサンドボックスとユーザー承認機構によって外部アクセスや書き込みを制限しているのに対し 、zapabob版Codexではセキュリティプロファイルの概念導入や包括的なサンドボックス逸脱テストによって、より細かな信頼性設定とログ監査が追加されています 。

以上を踏まえ、本仕様書では本家Codexのコードベースに対し、zapabob版Codexで実現された機能拡張を統合し、GUI（グラフィカルユーザインタフェース）での操作やショートカットキーによる実行、自然言語によるモード切替、DeepResearch（深層リサーチ）機能の統合、およびGit/MCP対応のエージェントオーケストレーションといった提案機能を組み込むための要件を定義します。これらの新機能を追加するにあたり、OpenAI本家のアップストリームコードベースとの互換性を確保しつつ、zapabob版での有用な改良点を可能な限り活かすことを目標とします。

## 目的

本ドキュメントの目的は、OpenAI Codex（本家版）の既存機能とzapabob版Codexの拡張機能を統合した次世代システムの技術的要求事項を明確にすることです。開発チームおよび関係者がこの要求仕様に基づき設計・実装・テストを行えるよう、機能要件および非機能要件を網羅的に示します。特に、エージェントのオーケストレーション方式の拡充、ユーザインタフェースの刷新、操作性の向上（GUI操作・キーボードショートカット）、モード切替手段の自然言語化、DeepResearch機能の組み込み、Git連携およびOpenAI Agents SDK（Model Context Protocol, MCP）との統合に関する事項について詳細に記述します。

本仕様は、可能な限り本家Codexの設計哲学・コード構造を尊重し、アップストリームへの変更を最小限に抑えつつ機能拡張を実現する方針に従います。具体的には、新規機能は既存コードベースへの修正量を減らし、設定可能なオプションやプラグイン的拡張として提供すること、また既存のCLIフローやAPIを破壊的に変更しないことを重視します。これにより、本家リポジトリへの将来的な取り込み（マージ）や保守も容易にし、Zapabob版で培われた有用な機能をコミュニティ全体で共有できるようにします。

## 適用範囲

本要求仕様書が対象とする範囲は、CodexのコアCLIアプリケーションおよびその周辺ツール・インタフェースです。具体的には以下のコンポーネントを含みます。

- Codex CLI本体: 対話型のコーディングエージェントとしての機能全般（エージェントの生成・管理、ユーザからの指示解析、コード変更の提案・適用、テスト実行等）。
- エージェントオーケストレーション機構: 複数のサブエージェントの管理、タスクの並列・逐次実行、エージェント間の情報共有、結果マージ戦略など。
- ユーザインタフェース: 新規に導入するGUI部分および既存CLI/IDE拡張との統合部分。ユーザがCodexと対話・操作するためのUI要素やワークフロー。
- 入力インタラクション: キーボードショートカット、自然言語コマンドなど、ユーザがエージェントの動作を制御するための操作系。
- 外部連携: Gitリポジトリとの連携（ファイル差分管理、ブランチ操作等）およびOpenAI Agents SDK (MCP)とのプロトコル連携。
- セキュリティサンドボックスおよび承認フロー: OSレベルのコマンド実行制限、ファイルアクセス制限、ネットワークアクセス設定、ならびに危険操作に対するユーザー承認プロンプトの動作。

本仕様に含まれない範囲（除外事項）：

- OpenAI APIそのもののモデル性能や大規模言語モデルの改良点（本仕様はCodexアプリケーション側の拡張に焦点を当て、基盤となるモデル部分の変更は扱わない）。
- VS Code拡張など既存IDEプラグイン自体の実装（ただし、Codex CLI側の変更がIDE連携に与える影響は考慮する）。
- Codex Cloud（ホスト型サービス）特有の機能。本仕様は主にローカルCLI版を対象とするが、可能な限りCloud版との機能整合性も考慮する。

## 現行システム概要

### 本家Codexのアーキテクチャと機能

OpenAI Codex CLIはRust製のコマンドラインツールであり、ユーザから与えられた自然言語の指示や質問に基づき、ローカルのプロジェクトファイル群に対してコード生成や編集を行います 。エージェントは対話履歴とプロジェクトコンテキスト（ファイル内容、AGENTS.mdに定義された手順やコーディング規約など）を元に、次に行うべきコード変更やアクションを決定します。現行の本家Codexの特徴を以下にまとめます。

- シングルエージェントモデル: 標準では1つのCodexインスタンス（エージェント）がユーザと対話し、すべてのタスク（理解、コード編集、テスト実行など）を単独で順次実行します。エージェントの役割定義はAGENTS.mdやYAML設定により静的に指定できますが、同時に複数のエージェントが連携して動く仕組みは提供されていません（マルチエージェント対応は今後の拡張が検討されています ）。本家Codexでは非同期実行に対応していますが、基本的にイベントループ上での逐次処理であり並列実行は行われません 。
- CLIインタラクション: Codex CLIでは対話形式でユーザ入力を受け付け、エージェントからの応答（提案コードやログ）をターミナルに出力します。ユーザは提案内容を確認し、必要に応じて/approveコマンド等でコード変更の適用を承認したり、追加の指示を与えたりします。コマンドライン引数や対話内コマンドによってエージェントの挙動を制御する仕組みがあり、たとえば/undoで前回の変更を取り消す、/planで次にやるべきタスクの計画を表示するといった機能があります（注: 具体的なコマンド名は例示）。本家Codex CLIはあくまでCUI中心であり、GUIは提供されていません。ただしVS Code拡張やCursorなどのIDEを通じて、Codex CLIと連携したグラフィカルな対話が可能です 。
- サンドボックスと承認メカニズム: 本家Codexはセキュリティ上の配慮から、デフォルトではファイルの読み書きやコマンド実行の権限を現在のプロジェクトディレクトリ内に制限しています 。エージェントはOSごとの仕組み（macOSならSeatbeltによるsandbox-exec、Linuxならseccomp/Landlock等）で隔離された環境下でコマンドを実行し 、ネットワークアクセスも標準では無効化されています  。ユーザはCodexに与えるフラグや設定ファイル（config.toml）でサンドボックスのモードを変更可能です。例えば--sandbox read-onlyを指定すればエージェントを読み取り専用モードで起動できます 。また承認（Approval）ポリシーにより、エージェントが実行しようとする操作に対するユーザ確認のタイミングを制御できます 。デフォルト設定（Autoモード）では、エージェントはワークスペース内のファイル読み書きと安全なコマンド実行は自動で行いますが、外部への書き込みやネットワークアクセス等「信頼できない操作」を実行する際にはユーザに許可を求めます 。ユーザは--ask-for-approvalオプションでalways（常に許可確認）、never（一切確認しない）、untrusted（デフォルト）等を選択可能であり、危険度に応じてエージェントの自律性を調整できます 。極端なケースでは、--dangerously-bypass-approvals-and-sandbox（エイリアス: --yolo）オプションにより全てのサンドボックス制限と承認確認を無効化することもできます （推奨されません）。
- Gitおよび開発ワークフローとの統合: CodexはGit管理下のフォルダで動作することを想定しており、エージェントはgit status等を内部的に確認して作業ブランチがクリーンかどうか検知し、モードを自動調整する仕組みがあります 。例えば、Gitでバージョン管理されているフォルダではデフォルトの承認ポリシーをAutoに設定し、そうでない場合はRead-Onlyモードを推奨する、といった挙動です 。またCodexはコード変更時にできるだけ**差分パッチ（git diff形式）**を生成し、それを適用する形でファイルを書き換えます。これは、大きな変更を直接ファイルに書き込むのではなく、小さな変更単位でパッチを作成・適用することで、人間によるレビューやロールバックを容易にするためです 。ユーザにはエージェントの提案を一種のPull Requestと見なして、小まめにテストやレビューを行い、コミットメッセージに経緯を残す、といった運用が推奨されています 。
- パフォーマンス: 本家Codex (Rust実装)のパフォーマンスは対話型ツールとして十分高速ですが、zapabob版の分析ではデバッグビルド時にバイナリサイズが80MB近くになること、また一部警告が残っていることが指摘されています 。起動時間もチューニングの余地があり、本家版では標準的なマシンで数百ミリ秒程度と推定されます。なお2025年1月時点の最新版Codexのアップデートで、モデル応答の安定性やコラボレーション性能の向上が図られています が、エージェントの根本的な実行モデル（単一対話エージェント）に大きな変化はありません。

### zapabob版Codexの拡張ポイント

zapabob版Codex（フォーク版）は、本家Codexの制約を打破し、より自律的かつ高度なコーディングエージェントを目指して多くの機能強化を行っています。特に注目すべき拡張点を以下に列挙します。

- 並列エージェント実行: 複数のエージェントを並列に走らせることが可能です。本家Codexがシングルスレッドのイベントループ上で順次タスクを処理するのに対し、zapabob版ではRustの非同期実行ランタイム（Tokio）を用いてマルチスレッドでエージェントを同時稼働させられます 。これにより、あるタスクを複数のサブエージェントに分担させて同時進行させたり、独立した複数の課題に対し同時に解決策を試行したりといったことが可能となります。実測では逐次実行と比べ2.5倍以上の速度向上を達成しています 。特に大規模プロジェクトや時間のかかる分析工程では、この並列化により応答時間を大幅に短縮できるメリットがあります。
- 動的エージェント生成: zapabob版はエージェントの役割定義を実行時に動的生成できます。本家Codexではエージェントの役割や方針をYAMLやAGENTS.mdで予め静的に定義しますが、zapabob版では対話中に大規模言語モデル(LLM)を用いて新規エージェントのプロファイルを生成し、そのエージェントを追加で起動することが可能です 。たとえば「この問題に詳しいデータベースの専門家エージェントを呼び出して」というユーザ指示に応じて、LLMがデータベースエキスパートのエージェント定義（役割や知識範囲など）を作成し、そのエージェントがサブタスクを担当するといった使い方ができます。YAML不要でエージェントを柔軟に増員できるため、未知の問題領域にも適応しやすくなります 。
- メタオーケストレーション（自己言及型エージェント）: zapabob版Codexでは、Codexエージェントが自身をサブエージェントとして呼び出すこと（再帰的オーケストレーション）が可能になっています 。具体的には、Codex CLI自体をMCP（Model Context Protocol）サーバーモードで起動し、エージェントが内部で別のCodexインスタンスにタスクを委譲する、という動作を取れます。OpenAIのAgents SDKを介してCodexをツール（MCPエージェント）として利用することで、単一エージェントから複数協調型のエージェントチームまでシームレスにスケールするワークフローが構築可能です 。zapabob版はこの仕組みを利用して自己オーケストレーションAIとも言うべき振る舞いを実現しており、エージェントが判断に迷った際に「自分自身にもう一度考えさせる」ための再帰呼び出しを行うことや、親エージェントが子エージェントを生成して問題解決を分担させる、といった高度な戦略を取ることができます 。
- マルチエージェント・スーパーバイザ機構: zapabob版にはエージェントチームを統括するスーパーバイザの概念が導入されています。8種類の専門エージェント（例: CodeExpert（コード専門家）、Researcher（リサーチ担当）、Tester（テスト担当）、Security（セキュリティ監査）、Backend/Frontend（各層開発）、Database、DevOps 等）が用意され 、問題に応じてスーパーバイザがこれらを指揮し協調動作させます。スーパーバイザはタスクの実行戦略を逐次・並列・ハイブリッドから選択し、各エージェントに指示を割り振ります 。また各エージェントの出力結果を統合するマージ戦略として、単純連結、投票（多数決）、スコア評価（信頼度の高い回答を選択）といった手法を取り、最終的な解決策をまとめます 。このマルチエージェント協調により、単一のAIでは見落としがちな問題も様々な視点から検討され、質の高いコーディング提案が可能となります。
- Deep Researchシステム: 複雑な実装課題や未知の技術領域に対して、zapabob版は**深層リサーチ（DeepResearch）**機能を提供します。従来のweb検索ツールを拡張したdeep_web_searchにより、エージェントは複数回にわたる検索クエリの発行や資料集約を自動で行い、関連情報を深く掘り下げて収集できます 。ユーザは「この新しいフレームワークについて調査して」と指示するだけで、エージェントがComprehensive（網羅的）、Focused（特定テーマ集中）、Exploratory（探索的）といった3種のリサーチ戦略から適切なものを選び 、必要な深さ（検索深度レベル1～5）に応じて資料を集めます 。集めた情報はソースの信頼性評価やバイアス検出を行った上で要約・統合され、引用付きの構造化レポートとしてエージェントの回答に組み込まれます 。これによりCodexはユーザに正確な技術的背景知識を提供しつつ、得られた知見を踏まえてコード生成・提案を行えるようになります。DeepResearchはCodexを単なるコード生成AIから、インターネット上の知識を調査・応用できる高度なエンジニア助手へと進化させる機能です。なお、ネットワークアクセスが必要なDeepResearch機能はCodexの承認設定と連動しており、ユーザが許可した範囲内でのみ外部検索を行います（例えば--searchフラグや設定でウェブ検索を有効化した場合に実行可能） 。
- セキュリティ強化: zapabob版Codexは既存のサンドボックス/承認機構を拡張し、5段階のセキュリティプロファイルを導入しています 。これにより「極めて安全（Strict）」から「開発者フレンドリ（通常の承認）」、「高リスク許容（ほぼ自動実行）」まで、あらかじめ定義されたポリシーセットを選択可能になっています（具体的なプロファイル名・内容は設計段階で定義）。各プロファイルはSandboxモード（read-only, workspace-write, full-access等）とApprovalポリシー（always, on-request, never等）の組み合わせ、およびネットワークアクセス許可設定を内包しており、ユーザは自分のリスク許容度に応じて簡単に切り替えられます。zapabob版ではさらにプライバシーに配慮した監査ログ機能が追加され、エージェントの全ファイルアクセスやコマンド実行を構造化したイベントログ（AgentExecutionEvent）として記録します 。これらのログは個人情報や機密データを含まない形で出力され、後で行動のトレースや問題発生時の解析が可能です 。また、サンドボックス逸脱を試みる攻撃に対する耐性を確認するため16種類のE2Eテストが導入されており、既知のエスケープ手法ではエージェントが隔離を破れないことが検証されています 。これらにより、zapabob版Codexは本家版以上にセキュアで監査可能な運用が可能となっています。
- その他の改良点: 上記以外にも、zapabob版はトークン予算管理機能やフック機構の実装など多数の改良を含みます。トークン予算管理とは、各エージェント毎に使用したAPIトークン数を追跡し、あらかじめ設定した上限内に収める仕組みです  。例えば大規模プロジェクトで長時間エージェントを動作させる際、うっかりAPI使用量が膨大にならないようコストを制御できます。またフック機構とは、エージェントのライフサイクル各所（プロンプト生成前、ユーザ応答後、ファイル出力後など）にカスタム処理を挟み込める拡張点を提供するものです 。zapabob版ではClaudecode（Anthropic ClaudeベースのコードAI）の手法を参考に、10種類のフックポイントと7つのデフォルトフックコマンドを実装し、さらにフックからサブエージェントを呼び出すことも可能にしています 。これにより上級ユーザやプラグイン開発者はCodexの振る舞いを柔軟にカスタマイズできます。

また、コード品質面ではzapabob版で全てのコンパイル警告が修正され、結果としてビルド時の警告がゼロになっています 。リリースビルド時のバイナリサイズも約38.35MBと大幅に最適化され（本家版デバッグビルド比で52.5%減） 、平均起動時間も約129msと軽快です 。これらは本家版との互換性を保ちつつ達成された改善であり、統合後のシステムでも維持・継承すべき重要な非機能特性です。

以上がzapabob版Codexの主な特徴です。本仕様では、これら優れた機能拡張を本家Codexに違和感なく組み込み、ユーザに一貫した体験を提供するための要件を定義していきます。

## 機能要件

本章では、統合後のCodexシステムに求められる機能要件を述べます。機能要件は、大きく分けて以下のカテゴリに分類されます。

1. ユーザインタフェース要件（GUI統合）
2. 操作性要件（ショートカットキー・対話操作）
3. モード管理要件（作業モードの切替）
4. エージェントオーケストレーション要件
5. 外部連携要件（DeepResearch, Git, MCP統合）
6. セキュリティ要件（サンドボックス・承認フロー）

各項目について詳細な要求仕様を以下に示します。

### 1. GUIインタラクション（グラフィカルUIでの操作）

本システムでは、新規に**グラフィカルユーザインタフェース（GUI）**を導入し、ユーザが従来のCLI対話に加えて直感的にCodexエージェントとやり取りできるようにします。GUIは以下の要件を満たすものとします。

- チャット画面の提供: GUI上に、人間とエージェントの対話を表示するチャット形式のビューを設けます。ユーザの指示（プロンプト）とエージェントからの回答（コード提案やメッセージ）を時系列で吹き出し形式等で見やすく提示し、長いやり取りでもスクロールで履歴を遡れること。Markdown形式の出力（コードブロック、リスト、テーブル等）も適切にレンダリングして表示すること。
- コード差分ビューア: エージェントがコード変更を提案した場合、その差分（どのファイルのどの行がどのように変更されるか）をGUI上で視覚的に表示できるようにします。具体的には、Gitの差分ビューのように削除行は赤、追加行は緑でハイライト表示し、変更内容を一目で把握できるUIを提供します。ユーザはこの差分を確認した上で承認または却下の操作をGUI上のボタン等で行えること（CLIの/approve等の操作をGUIボタンに対応付け）。エージェントから複数の差分提案（パッチ）が提示された場合にも対応し、各パッチをタブや一覧で切り替えて比較できるようにします。
- 実行コンソール: Codexエージェントがテストの実行やビルド、その他のコマンド実行を行った際、その標準出力・エラー出力のログをリアルタイムに閲覧できるコンソールペインをGUI内に設けます。開発者がターミナルで見るのと同様の情報をGUI上に表示し、色分けやフィルタリング（例: エラー行のみ強調）もサポートしてデバッグ容易性を高めます。
- ユーザー入力フィールド: GUI下部にはユーザがエージェントに指示や質問を入力するテキストフィールドを配置します。ここでは基本的に自然言語でプロンプトを記述できますが、スラッシュコマンド（例: /planや/undo）の入力もサポートします。入力フィールドではMarkdown記法の補助や、過去に入力したコマンドの履歴呼び出しなどUX向上の工夫も行います。改行・送信など基本的な操作は一般的なチャットUIの慣習に従います（Enterで送信、Shift+Enterで改行挿入等）。
- モード切替・エージェント制御UI: GUI上に、現在のCodexの動作モード（後述する「ワークツリー競合モード」「オーケストレーション編集モード」）を表示・切替するトグルスイッチまたはドロップダウンを設けます。ユーザはワンクリックでモードを確認・変更でき、その変更は即座にエージェントオーケストレーションに反映されます。また、GUI上にエージェントの状態を示すインジケータ（Thinking中/実行中/待機中など）を表示し、必要に応じ「一時停止」「再開」「停止」ボタンを提供します。たとえばエージェントが長時間処理を行っている際にユーザが中断させたい場合、停止ボタンで現在の処理をキャンセルできるようにすること。
- エージェントチーム可視化: マルチエージェントモード（複数エージェント協調動作）が有効な場合、GUI上で現在アクティブなサブエージェントの一覧や関与状況を視覚的に示します。例えば「Researcher」「Tester」など役割名のラベルと、それぞれの進捗（どのタスクを実行中か、完了したか）、簡易なログ（最新の発言要旨や結果）を表示するパネルを設けます。これによりユーザは裏で何が起きているかを理解しやすくなり、不必要な不安を軽減できます。
- ショートカット・ホットキー対応: GUI上の各操作（送信、承認、差分切替、モードトグル等）には対応するキーボードショートカットが設定されます（詳細は次節）。GUIはユーザのキーボード入力を監視し、定義済みのショートカットが押下されたら即座に該当アクションを実行します。これにより上級ユーザはマウス操作を減らし迅速にエージェントを操作できます。ショートカットの存在とキー割り当てはGUI上で確認可能であり、できればカスタマイズも許容します。
- レスポンシブデザイン: GUIは開発者が利用する様々な環境（フルHDの外部モニタ、大型4Kディスプレイ、ノートPCの画面、あるいはタブレット）で見やすく使いやすいよう、レスポンシブデザイン/レイアウトを採用します。ウィンドウサイズに応じて各ペイン（チャット、差分、コンソール等）の配置を柔軟に変更し、必要に応じて折り畳み・展開できるようにすること。例えば横幅が狭い場合にはコンソールペインをタブで切り替える形式にする、広ければ横並びに表示する、といったUI変化に対応します。
- CLIモードとの両立: GUI提供後も、従来通りターミナル上で動作するCLIモードは引き続きサポートされます。すなわちGUIはオプション機能として実装し、ユーザが望まない場合やサーバ環境で画面のない場合でも、CodexをCLIとして利用できること（GUIは起動しない設定が可能）。内部実装的には、GUIはCodexの出力を受け取って描画し、ユーザ入力をCodexエンジンに渡す一種のフロントエンドとして動作します。このアーキテクチャにより、GUI追加によるCodexコアロジックへの影響を最小限に抑え、CLIモードとGUIモードが同じエンジン・APIを共有できるようにします。
- アップストリーム親和性: GUI部分の実装は、本家Codexプロジェクトに大規模な依存関係を追加したり、既存コードに大幅な改変を加えない方針で行います。可能であればGUIはCodex本体とは別のモジュールやクレートとして実装し、Codex本体とは明確なAPIインタフェースで通信する形を取ります。例えばCodexコアをRPCサーバー（MCPサーバーとして）起動し、GUIはクライアントとしてそのAPIを叩く構成も検討します 。こうすることで、本家への提案時にもGUI部分を分離可能なオプション機能として提示し、受け入れられやすくします。

### 2. ショートカットキーによる操作

GUIおよびCLI上でのキーボードショートカット対応についての要件を示します。ショートカットはユーザが素早くCodexを操作するのに不可欠であり、特にエディタに手を置いたままAIを制御したい開発者にとって有用です。本仕様では、一般的な開発ツールの慣習に倣いつつ、Codex特有の操作に合ったキー割り当てを提案します。

- 基本送信操作:
  - Enterキー: チャット入力フィールドでのメッセージ送信。ユーザが入力したプロンプトやコマンドをエージェントに送ります（GUI上では送信ボタンをクリックする代わりにEnterキーが使える）。
  - Shift + Enter: チャットフィールド内で改行を挿入します（送信せずテキストを次の行に継続）。
- 承認/却下操作:
  - Ctrl + Y / Cmd + Y: エージェントの提案したコード変更を**承認（Yes）**します。現在表示中の差分パッチを適用する旨をエージェントに伝え、実行させます（CLIの/approve相当） 。複数パッチが提示されている場合は、フォーカスの当たっている（現在選択中の）パッチに対する承認となります。
  - Ctrl + N / Cmd + N: エージェントの提案を**却下（No）**します。現在の差分提案を採用しない旨をエージェントに伝え、別解の提示や計画変更を促します。CLIの/rejectまたは未承認で続行する操作に相当します。
  - 実装上の注意: これらのキー操作は誤爆を避けるため、必要に応じて確認ダイアログやアンドゥ機能と組み合わせます。例えばCtrl+Yを押した際に即座に適用せず、「適用しますか？ (Y/N)」と一瞬表示するといった配慮も検討します。とはいえ、過度な確認はせっかくの迅速性を損なうため、デフォルトではワンタッチ承認し、代わりにUndo操作（後述）で巻き戻せる設計が望ましいです。
- コード差分ナビゲーション:
  - Ctrl + ↑ / ↓ (上下矢印): 提案された複数のパッチがある場合に、前後の差分に切り替えます。例えば3つの差分案A, B, Cが提示されている場面で、Ctrl+↓を押すと次の案にビューを移し、Ctrl+↑で前の案に戻る、といった動作を実装します。GUIではパッチ一覧をキーボードで選択可能にし、CLIではコマンド（/nextや/prev）のショートハンドとして機能させます。
- モード切替:
  - Ctrl + M: Codexの実行モードをトグルします。後述する「ワークツリー競合モード」と「オーケストレーション編集モード」を切り替えるショートカットとします（初回押下で競合モード→編集モード、再押下で元に戻す等）。モード変更時にはGUI上に現在のモードがトースト通知や明示的なUIで表示され、ユーザに切替完了を知らせます。
  - 補足: モード切替は誤操作による意図しない変化を避けるため、二段構えの操作（例えばCtrl+M押下後にポップアップが出て、もう一度確定キーを押す）にする案もあります。ただし操作量を増やす欠点もあるため、実験的段階ではシンプルなトグルとし、UXテストを経て調整します。
- その他便利操作:
  - Ctrl + Z: Undo操作。直前に適用したコード変更を取り消します 。これはCLIの/undoに対応し、GUIでも履歴管理と組み合わせて複数回の取り消しが可能だと望ましいです。
  - Ctrl + P: プラン表示。エージェントが今後予定しているタスクの計画や、問題解決のために考えている手順を要約表示します（CLIの/planコマンド相当）。モードによっては複数エージェントの分担計画を統合して表示する必要があります。
  - Ctrl + D: DeepResearchトリガ。DeepResearch機能を明示的に開始させるショートカットです。ユーザが今いる対話コンテキストに関連する技術調査を要求する際、このキーを押すことでエージェントに調査モードへの移行を促します。例えばユーザが「まだ理解が浅いので調べて」と言った場合に押すなど。押下後、エージェントはDeepResearchシステムを起動し関連情報の収集に入ります（詳細後述） 。
- ショートカットの表示とカスタマイズ: GUI上に「ヘルプ」または「キーバインド一覧」画面を用意し、現行の全ショートカットキーとその機能説明を一覧表示します。ユーザはこれを参照して操作を学習できます。また高度なユーザ向けに、ショートカット割り当てを設定ファイル等で再定義可能にすることも検討します（例: Emacs派の開発者向けにCtrl+MではなくAlt+Mに変更する等）。但し初期バージョンでは固定でも構いません。その場合も内部的にはキー設定を1箇所で管理し、将来的なカスタマイズ対応に備えます。

上記ショートカット要件は、作業効率の向上とユーザビリティのために重要です。実装においては、GUIフレームワークのホットキー機能を活用しつつ、本家CodexのCLI操作体系と矛盾しないよう配慮します（CLIでの/approve等との二重定義に注意）。また、ショートカット機能追加によって本家コードへの影響を抑えるため、キーバインド処理はUIレイヤ（例えばElectronやTauriなどGUI側）で完結させ、Codexコアへの入力は既存のコマンド文字列として送信する形をとります。これならばCodexエンジン自体は変更不要か最小限で済みます。

### 3. 自然言語によるモード切替

Codexは様々なタスク解決手法を持ち得ます。本仕様では特に、「ワークツリー競合モード」（Worktree-Competition Mode）と**「オーケストレーション編集モード」（Orchestrated-Edit Mode）という2つのアプローチモードを定義し、ユーザが自然言語または簡単な操作でこれらを切り替え指示**できるようにする要件を示します。

モード概要:

- ワークツリー競合モード: いわば「競争的解決」アプローチです。このモードでは、エージェント（または複数のサブエージェント）が与えられた課題に対し複数の代替解決策を並行して試みます 。例えば、あるバグ修正に対して2種類の異なる修正案をそれぞれ別のエージェントが実装し、最終的にテスト結果や評価スコアに基づいて優秀な方の案を採用するといった流れになります 。まさにチーム内コンペティションのように、複数案を競わせて最適解を選択する方式です。Codexは各案を別々のブランチやワークツリー上の差分として用意し、競合のないよう管理します。ユーザから見れば、エージェントが「案A」と「案B」を提示し、その長所短所を比較検討した上で自動的にまたはユーザと協議して一方を選ぶ、という挙動になります。このモードは解決策の探索多様性を確保したい場合に有効であり、特に要求仕様が曖昧なタスクで複数のアプローチを試したい時や、エージェント自身にどの実装が最善か判断させたい時に使用します。技術的にはzapabob版の「Parallel Agent Execution」「Merge Strategy: Voting/HighestScore」機能に相当します 。
- オーケストレーション編集モード: こちらは「協調的分業」アプローチです。エージェントが問題を細かいサブタスクに分割し、複数の専門エージェントが順次または並行にそれらを処理し、結果を統合していくモードです 。例えば新機能実装では、まず「設計プラン策定」タスクをPlannerエージェントが行い、そのプランに基づき「コード生成」タスクをCoderエージェントが担当、並行して「セキュリティ検討」タスクをSecurityエージェントが実施し、最後にTesterエージェントが統合テストをする、といったパイプライン的な協調を実現します 。このモードではスーパーバイザが中心となり全体を見渡して調整し、必要に応じてタスクの再割り当てや追加調査（ResearcherエージェントのDeepResearch活用など）を指示します。ユーザから見れば、エージェントが「まずAを行い、その結果Bして、次にCをする計画です」と説明しながら着実に進めていくイメージになります。これは問題を段階的に解決するもので、逐次最適化アプローチとも言えます。技術的にはzapabob版の「Sequential/Hybrid Execution Strategy」や「Multi-Agent Supervisor System」の挙動に相当します 。

上記2モードは一長一短があり、ユーザが課題の性質に応じて使い分けられるようにします。本仕様では自然言語によるモード変更を可能とし、ユーザが「では複数案試してみて」「みんなで協力して解決して」といった指示をするだけでエージェント側がモードを切り替えて対応することを目指します。

具体的な要件は以下の通りです。

- モード識別と言語理解: エージェントはユーザからのメッセージを解析し、モード変更の意図が含まれているかを判断できること。例えばユーザ発話中に「別の方法も検討して」や「違うアプローチで試して」等があればCompetitionモードへの切替要求と解釈し、「手分けして進めて」や「各分野の専門AIで協力して」等があればOrchestratedモードへの切替と解釈するといったルールを設けます。多少曖昧な表現でも大きな間違いが起きないよう、安全側に倒した実装とします（分からなければ確認を返す）。
- モード変更の確認応答: エージェントがユーザのモード変更リクエストを受け取った場合、その解釈結果を一度ユーザに確認する応答を返します。例えば「了解しました。競合モードで複数の解決策を試みます。」や「承知しました。オーケストレーションモードで分担して取り組みます。」のように、選択されたモード名を明示して応答することで、ユーザに誤認識が無いか確認します。ユーザがもし意図と違う返答だと感じたら、その時点で訂正指示を出せます。
- モード維持と再切替: 一度モードが切り替わったら、そのセッション内では明示的に再指示があるか、完了条件に達するまでそのモード戦略を維持します。例えば競合モードに入ったら、エージェントは複数案提示と評価を行うループに入り、最終的に1案に絞り込んでユーザに提案するまでその方針で進みます。途中でユーザから「やっぱり協力モードでやって」と指示があれば、その時点でオーケストレーション編集モードに切り替え、以後の進行を変更します（必要なら状況に応じてタスクを再計画）。こうしてユーザは対話を続けながら柔軟にアプローチを変更できます。
- GUIでのモード表示: 前述したように、GUI上には現在のモードが常に表示されます。自然言語での切替が行われた場合もGUI上のトグル表示がそれに追随して更新されます。逆にユーザがGUIのモードトグルを操作した場合は、エージェント側にその旨が伝達され、次の発話タイミングで確認応答（「GUI操作により○○モードに切り替えます」等）を行ってから新モードの挙動に入ります。
- モード別の応答フォーマット: モードによってエージェントの応答スタイルにも違いを持たせます。競合モードでは各案を識別するため、「案1: …」「案2: …」のように番号や名前を付けて複数提案を提示する、評価結果を表にまとめて報告する、など比較しやすい出力を心がけます。一方オーケストレーション編集モードでは、「まず○○を実施します…完了しました。次に…」といったステップごとの進捗報告や、複数エージェントの発言を区別する（例: [DBExpert]「…」など発話者を明示）など、協調作業の過程が見える出力を行います。これらのフォーマット仕様は要求というよりガイドラインですが、ユーザ体験を左右する重要点として実装で考慮します。
- 内部パラメータと切替実装: モード切替の実装は、Codexの中核であるタスク実行オーケストレータに対するパラメータ切替として行います。例えばAgentOrchestratorクラスにモードフラグを持たせ、mode = COMPETITIONの時は並列エージェント生成＋結果マージ、mode = ORCHESTRATIONの時は予め定義したサブタスク分割シーケンスに従う、といった分岐を実装します。アップストリームへの影響を抑えるため、既存のシングルエージェント動作はmode = SINGLE（デフォルト）として保ち、特別なフラグを立てた場合にのみ上記新モードロジックが有効になるようにします。つまり、本家Codexのユーザは何も意識しなければ従来通り単独エージェントで動作し、統合版特有のモードはオプトインで使えるように設計します。
- ドキュメント: 自然言語モード切替の存在と使用法について、ユーザドキュメントに明記します。具体的なフレーズ例や効果的な使い方、注意事項（例えば競合モードでは計算資源を多く使う可能性がある等）を説明し、ユーザが正しく理解して利用できるようにします。

### 4. エージェント・オーケストレーションの強化

Codex統合版におけるエージェントオーケストレーション機能の要求を述べます。これはシステムの中核的改良点であり、zapabob版で導入されたマルチエージェントの管理・並列実行・トークン管理等の機構を統合するものです。具体的な要件は以下の通りです。

- 並列実行フレームワーク: システムは複数エージェントの並列実行をサポートしなければなりません。具体的には、非同期ランタイム（Tokio等）上で複数のエージェントタスクを同時にspawnし、それぞれの結果を将来（Future）で待ち合わせ、適切に集約する仕組みを備えます 。並列度はシナリオに応じて動的に決定されます。例えば競合モードでは2～3程度のエージェントを並列起動し、協調モードではタスク分割数に応じて並列に走らせる部分と直列に待つ部分を混在させます。特にI/O待ちやAPI呼び出し待機が発生する処理では並列化によるメリットが大きいため、ネットワーク検索（DeepResearch）や外部コマンド実行待ちなどを他のタスクと重ねて進めるなど、効率的なタスクスケジューリングを行います。実装上はZapabob版の例にならい、tokio::spawnによるマルチスレッドタスク駆動をCodexエンジンに導入します 。これにより、本家版がイベントループ上でシーケンシャルに処理していたものが真の並列処理となり、全体の処理時間短縮が期待できます。並列化の導入によって生じうる競合状態や共有リソースのロック等については、細心の注意を払いスレッド安全性を確保します（Rustの所有権/借用ルールに則り、グローバルな可変状態を極力持たない設計とする）。また、オプション設定で並列機能を無効化し、従来通りシングルスレッドで動かすモードも提供してデバッグやトラブルシューティングを容易にします。
- 動的エージェントハンドリング: システムは実行時に新たなエージェントを動的に生成・起動できる仕組みを提供します 。たとえば、エージェントオーケストレータが「必要な役割のサブエージェントが存在しない」と判断した場合、LLMにその役割に適したエージェント定義（プロンプトテンプレートや目標）を生成させ、新規エージェントインスタンスを立ち上げます。生成されたエージェントには一時的なIDや名前（例えば「Helper1」）が付与され、現在の対話コンテキストに参加します。エージェントオーケストレータはこの新エージェントにタスクを割り当て、既存エージェントと同様に管理します。動的生成されたエージェントは、タスク完了後に破棄（シャットダウン）されるか、もしくはセッション内で再利用されます（使い捨てか常駐かはシナリオによる）。本機能により、固定のYAML定義ではカバーできない未知の分野にも柔軟に対応できます。実装としては、Zapabob版で言及されているagent-createコマンド/オペレーションを参考に、LLMへの「エージェント定義生成プロンプト」を設計し、返ってきた定義をパースしてエージェント構築する流れになります 。なお、動的生成を乱発するとシステム資源を圧迫したり管理が煩雑になる恐れがあるため、必要性を厳格に評価するロジックを組み込みます（例えば既存エージェントで十分対処できる場合は新規生成しない等）。また、生成されたエージェントの品質を担保するため、LLMにエージェント定義を作らせる際にはAGENTS.mdなどプロジェクトの文脈を与え、適切な役割説明やコーディング規約を継承させるようにします。
- マルチエージェント役割割り当て: Zapabob版に準じ、当システムでも標準で複数の専門エージェント役割を定義します 。例としてCodeExpert（コード生成のエキスパート）、Tester（テスト担当）、Researcher（調査担当）、Security（セキュリティ監査担当）、Backend/Frontend開発担当、Databaseスキーマ担当、DevOps担当など8種程度のテンプレートを用意します 。エージェントオーケストレータは、ユーザの依頼内容やプロジェクト特性に応じて、これら定義済みエージェントから適切なものを選択してチームを構成します。例えば「Webアプリのフロントエンドでバグ修正」ならFrontendとTesterを、「パフォーマンス改善」ならCodeExpertとTesterと perhaps Researcherを、などシナリオに応じた割り当てロジックを持ちます。ユーザが特定エージェントを明示的にリクエストする（「セキュリティ専門AIにも確認させて」等）ことも許容し、その場合オーケストレータは対応する役割エージェントを有効化します。これら役割定義は設定ファイルやプラグインによって追加・カスタマイズできるように設計し、コミュニティが独自エージェントを拡張しやすいよう配慮します。
- タスク分割と実行戦略: 複数エージェントが存在する場合、オーケストレータは入力されたユーザ課題をサブタスクに分解し、それぞれをどのエージェントに割り当てるか決定します 。この際、Zapabob版で導入された3種の実行戦略（Sequential, Parallel, Hybrid）を踏襲します 。
  - Sequential: サブタスクを順番に一つずつ実行し、前の結果を次に活かす方式。依存関係が強いタスクチェーン（設計→実装→テストなど）に適します。
  - Parallel: 複数のサブタスクを並行して実行し、最後に結果を集約する方式。相互に独立した課題（例: フロントエンドとバックエンドの別箇所の改修）に適します。
  - Hybrid: 一部は並列、一部は順次で行う混合型。たとえば、まず複数案を並行生成し、結果を評価してから一つ選び、それを洗練する工程を順次行う、など柔軟な流れを構築できます。
オーケストレータは各戦略をタスク性質により自動選択しますが、ユーザが希望する戦略を指定する手段も提供します（上級者向けに、/strategy parallelのようなコマンドや設定で明示可能にする）。戦略の違いは内部のFutureの待ち方や、エージェント間同期の入れ方の違いに反映されます。シーケンシャル戦略では1エージェント完了まで他は待機、パラレルでは全エージェントFutureをjoinし集約、ハイブリッドではスケジューリングを工夫して一部join一部awaitとします。
- 結果マージと選抜: 並行または分担実行したサブ結果を統合するロジックを実装します。Zapabob版の3種のマージ戦略（Concatenate, Voting, HighestScore）を参考にします 。
  - Concatenate（連結）: 複数のエージェント出力をそのまま順に繋げて結果とする。例えば異なるモジュールのコード変更を別エージェントが行ったなら、それら差分を合わせて一つのパッチにする。
  - Voting（投票）: 複数エージェントからの解決案が競合関係にある場合、投票で多数決を取るか、ユーザに選択を委ねる。例えば2つの実装案A/Bがあるなら、エージェント自身に「どちらが良いか」を評価させ、多数の支持を得た方を採用する。または品質評価スコアを各案について算出し比較する。ユーザが介入して選ぶUIも提供する（GUI上でA/B比較して選択）。
  - HighestScore（高スコア）: 各エージェント結果に信頼度やスコアを付与し、自動的に一番良いスコアの案を選ぶ方式。評価軸は例えばテストケースのパス数、実行性能、コード品質（リンター警告の少なさ）などタスクに応じて設定します。Zapabob版ではLLMにセルフ評価させるような仕組みもあるかもしれません。
これら戦略の適用はオーケストレータに組み込み、シナリオに応じて適切に使い分けます。必要に応じ、結果マージの前にConflict解消のプロセス（例えば2つの差分が同じ箇所を変更して衝突した場合の解決）も実装します。
- トークン予算管理: エージェントオーケストレータは、各エージェント（特にAPIを叩くLLMエージェント）のトークン使用量を追跡し、事前に定めた上限内で収めるよう自動制御します 。Zapabob版で実装されたTokenBudgeterを統合し、例えば全体セッションで使用可能なトークン予算を1万トークン、各サブエージェントは最大3000トークンまで等と設定できるようにします 。オーケストレータは各エージェントのプロンプト長・応答長をモニタし、超過しそうなら警告をログに出すか、そのエージェントへの割り当てタスクを切り上げるなど対策を取ります。極端な長大出力が出続ける場合はエージェントに打ち切りを指示することもあります。これにより、ユーザがCodexを長時間動作させても予測不能な高額API費用が発生しないようにします 。この管理機構は非アクティブにも切替可能（無制限モード）とし、小規模プロジェクトなどでは煩わしくないようにします。
- 監査ログとイベント: オーケストレータおよびエージェント各個は、構造化されたログイベントを生成します 。Zapabob版のAgentExecutionEventを参考に、各エージェントの開始/終了、サブタスクの割当、ユーザへの提案内容、実行したコマンド、テスト結果等を時系列で記録していきます 。ログはJSONまたはYAML形式で保存するオプションを設け、後からプログラムで解析可能にします 。またプライバシー情報（ファイル内容そのもの等）は含めず、操作のメタ情報に留めることでプライバシーに配慮します 。このログ機能はオプション設定で有効化し、デフォルトでは簡易なサマリ（CLI画面上に出す通常ログ）に留めるか、もしくは高度なエンタープライズ環境向け機能として位置付けます。いずれにせよ、オーケストレーション強化に伴うシステムの複雑化に対処するため、透明性を高め、不具合時のトラブルシュートを容易にするログ仕組みは必須と考えます。

### 5. 外部連携: DeepResearch・Git・MCP統合

Codex統合版では、外部ツールやプロトコルとの連携強化も重視します。具体的にはDeepResearch機能の統合と、GitおよびOpenAI Agents SDK (MCP)との統合を発展させます。

#### 5.1 DeepResearch機能の統合

DeepResearchは前述した通り、エージェントによるインターネット検索と知識集約を可能にする強力な仕組みです 。統合版ではこれを正式な機能として組み込みます。

- **DeepResearch起動条件**: エージェントは、ユーザから明示的な指示（「調査して」「関連情報を集めて」等）や、タスク達成に明らかに知識不足がある状況において、自発的にDeepResearchを開始します。前者はユーザの要求に忠実に従うケース、後者は例えばエージェントが内部で「このエラーコードは何か？」と疑問を持った際に自律的に判断して実行するケースです。もっとも、後者の自律的判断は誤作動の原因となり得るため、初期実装ではユーザ明示指示がある場合に限定するか、あるいは必ずユーザに「調査を実行してよいか」確認してから行うようにします。
- **ウェブ検索ツールとの連携**: Codexには既にweb_searchツールが存在し（OpenAI公式にも--searchオプションで有効化可能） 、特定クエリについてDuckDuckGo等の検索結果を取得することができます。DeepResearchではこれを拡張したdeep_web_searchモジュールを使用し、複数回にわたる検索クエリ発行と結果収集を行います 。例えば「Rust 非同期 ライフタイム 問題」で1回検索し、得られた記事から派生して「Rust ライフタイム エラーメッセージ 詳細」で追加検索するといったように、エージェントが興味深いキーワードを自律生成して再帰的な検索が可能です。検索の深さ（何段階ネストするか）は設定で制限し（デフォルト3、最大5など）、無関係な深追いを避けます 。
- **情報フィルタリングと評価**: 取得した検索結果（ウェブページの内容テキスト）は、その出典の信頼性や内容の関連性を評価します 。Zapabob版では「ソース品質とバイアス検出」という表現があり 、例えばドメインが公式か個人ブログか、内容が広告的か技術的か、情報が古すぎないか、などをLLMで判定する処理が入っていると推測されます。統合版でも、OpenAIのモデルを活用して各情報片にスコア付けを行い、一定以上の信頼度・関連度のものだけを知識として採用します。不要なテキストや偏った意見はレポートに含めません。また重複情報は統合し、一貫性ある知識集合を構築します。
- **出典付きレポート生成**: 集約した知識はユーザへの回答メッセージ中でレポート形式にまとめて提示します 。この際、情報の出典（参照URLや記事名等）を明記し、可能であれば引用文献番号やハイパーリンクとして表示します。例えば「Stack Overflow回答【12】によると…」のように注を付けます。GUIではこれをクリックするとブラウザでそのページが開くようにするなど、利便性を図ります（テキストUIではURL文字列を表示）。こうした引用付き回答は、ユーザがエージェントの出した情報を自分で裏付け確認できるようにするためであり、結果の信頼性向上につながります 。
- **DeepResearchの結果利用**: 得られた知識は、単にユーザへのレポートに留まらず、Codexエージェントのその後のコード生成や提案に積極的に活用されます。例えば、調査で「あるAPI関数には既知のバグがある」という情報を得たら、エージェントはそれを考慮して実装戦略を変えたり、ユーザに注意喚起します。また必要に応じてレポートから重要部分をプロンプトに再投入し、解決策のアイデア出しに役立てます。要するに、DeepResearchで取得した知識をCodexの内部知識状態に反映させ、以降の応答の品質を高めます。
- **設定と制御**: ユーザはDeepResearch機能をオン/オフできます。config.tomlに例えばdeep_research = trueといったフラグを用意し、デフォルトではオフ（明示的に有効化した場合のみ使う）とすることが考えられます。また検索に使用するエンジン（DuckDuckGo既定だがGoogleを使う選択肢など）や、一回のDeepResearchで許可する最大クエリ回数、1クエリあたり取得する結果件数などを設定で調整可能にします 。セキュリティ上は、DeepResearchであってもCodexのネットワークアクセスポリシーを逸脱しないようにします。つまり通常はsandbox設定でネットワーク禁止ならDeepResearchもしないし、許可された範囲（特定ドメインのみ等）に従います  。さらに検索クエリ自体にユーザの機密情報を含めないよう注意します（例えばエラーログに社内パス等が含まれていたら検索前にマスキングする）。
- **Agents SDKからの利用**: DeepResearch機能はCodex内だけでなく、OpenAI Agents SDKからツールとして呼び出せるようにもします 。Cursor IDE統合の例では、MCPツールとしてcodex-deep-researchが追加されているとのことなので 、これに倣いCodex MCPサーバ起動時にDeepResearch用のMCPハンドラを登録します。これにより外部のオーケストレーションシナリオから「ここでDeepResearchツールを使って知識を集める」呼び出しが可能になり、Codexを専門の調査エージェントとしても利用できます。

#### 5.2 Git連携およびMCP（Agents SDK）対応

Codexは元々Gitとの協調を想定していますが、統合版ではさらにGit操作への対応とOpenAI Agents SDK (MCP)との統合を発展させます。

- **Gitリポジトリ認識強化**: 本家Codexにもある機能ですが、プロジェクトがGitリポジトリである場合にエージェントはそれを認識し、最適な振る舞いを取ります 。統合版ではこの認識をさらに活用し、例えば複数ブランチを用いた作業を許可します。競合モードで複数の案を実装する際、システムは裏で一時的なGitブランチを2つ切って（例えば`codex/solutionA`と`codex/solutionB`）、それぞれに変更を適用しテストを走らせ、その結果を比較する、といった高度な使い方を可能にします。採用しなかったブランチは削除するか、ユーザが後から参照できるよう残すオプションを提供します。このようにGitを内部で積極活用してエージェントの作業結果を管理することで、変更の巻き戻しや差分の永続化をより安全に行えます。実装上、CodexがGitコマンド（`git branch`, `git switch`, `git merge`等）を必要に応じ発行しますが、セキュリティ上これらも「外部コマンド実行」の一種なので、適切な承認設定下でのみ動作します。
- **コミットメッセージ生成**: エージェントがコード変更を確定させる際、Gitコミットを行う場合は自動でコミットメッセージを生成します。コミットメッセージには、どのような変更を行い何故それが必要かを簡潔に記述し、必要ならIssue番号や参照も含めます。Codexは既に変更内容を把握しているため、モデルに「今回の変更の要約メッセージを生成して」とプロンプトすることでこれを実現します。コミットはユーザの確認後に行うか、承認操作と合わせて自動実行するか選択可能にします。メッセージのスタイル（文体やフォーマット）はAGENTS.mdやプロジェクトのContributing規約を参照させ、チーム文化に合ったものにします 。
- **プルリクエスト支援**: GitHub連携をさらに推し進め、CodexエージェントがPull Request (PR) を作成する補助も視野に入れます。本家CodexはGitHub上でのPRレビュー機能を備えていました が、統合版ではローカルからPRを投げる操作もエージェントが代行できるようにします（ユーザがGitHubトークンを設定している場合に限る等セキュアに）。エージェントはコミットをGitHubにプッシュし、PRタイトル・説明を生成し、オプションで自動レビューコメント（コードに対する自己注釈）もつけます。ただし、これらはスコープ外寄りの機能なので、要件として必須ではなく将来拡張の可能性として記載します。
- **MCPサーバ/クライアントの実装**: OpenAI Agents SDKとの連携のため、CodexはMCP (Model Context Protocol) インターフェースを完全サポートします。本家Codexには既に`codex mcp`というCLIサブコマンドでMCPサーバとして起動する機能があります 。統合版でもこれを維持・拡張し、長時間実行するCodex MCPサーバを立ち上げておけば、Agents SDK経由で外部プログラムがCodexエージェントとの対話を手続き的に制御できます 。要求としては、我々の拡張機能（マルチエージェントやDeepResearch等）もMCP経由で利用可能であることです。例えば、外部から「Codexに対して質問Xを投げ、結果を得る」という基本操作に加え、「CodexにDeepResearchを実行させる」「Codexを競合モードで動かす」といった指定もMCPでできるようにします。具体的には、MCPで公開するツール/関数のインターフェースを増やし、Zapabob版で紹介されている`codex-supervisor`や`codex-deep-research`といったエンドポイントを実装します 。Agents SDKから見れば、これらは別個のツールとして登録され、ワークフロー中で呼び出せるようになります。
- **MCP互換の出力/ログ**: MCP統合に際し、Codexの出力フォーマットや対話ログをAgents SDK側で解釈しやすい形式に合わせます。OpenAI Agents SDKでは各ツールが標準化された応答スキーマを持つことが推奨されるため、Codex MCPサーバもそのガイドラインに従い、可能ならJSON Lines形式や事前定義のAction/Observation構造で通信します。既存CodexのMCP実装を踏襲しつつ、マルチエージェントの複雑な応答（複数エージェントの結果など）も破綻なくシリアライズできるようにします。
- **Zero-Data-Retention (ZDR)**: これはOpenAI Codexに付随するポリシーで、Codexはセッション終了時にユーザのコードやデータを保持しない（プライバシー保護のため）というものですが 、統合版でもこれを遵守します。MCPサーバモード等で長時間動作させログを取る際も、ユーザが保存を許可しない限り、セッション終了後はメモリ上のデータをクリアします。Gitプッシュなど外部システムに出る際もユーザ意思でのみ行うよう注意します。

以上、DeepResearchおよびGit/MCP連携に関する要件でした。これら外部連携強化は、本家Codexの進化（Agents SDK対応など）と軌を一にするものであり、アップストリームに受け入れられやすい形で実装することが重要です。

### 6. セキュリティと承認フローの維持・拡張

Codex統合版においても、ユーザコードや環境の安全性確保は最重視事項です。本家Codexが持つサンドボックス＆ユーザ承認フレームワークを踏襲・維持しつつ、zapabob版で提案された改良を取り入れ、より柔軟で信頼できるシステムとします。

- **既存サンドボックス機構の維持**: 統合版でもmacOSのSeatbeltポリシー、Linuxのseccomp/Landlockによるプロセス制限をそのまま利用します 。エージェントが実行する全コマンドは、ユーザ設定の`--sandbox`モードに従い、許可された領域（通常は現在ディレクトリと一時ディレクトリ）のみファイル書き込み可、それ以外読み取り専用、ネットワークはデフォルト禁止等の制約下で動作します 。
- **承認ポリシーの拡張**: ユーザが承認プロンプトの頻度・条件をより細かく制御できるよう、zapabob版のセキュリティプロファイルを導入します 。具体的には、設定で`security_profile = "strict"`のように指定すると、例えば「read-only + always-ask」（最も厳格）にマップされ、`"permissive"`なら「workspace-write + untrusted-ask」（デフォルト相当）にマップされる、といった具合です。5段階程度のプリセットを用意し、それぞれSandboxとApprovalの組み合わせ、およびネットワークアクセス許可設定を内包します。
- **きめ細かな承認UI**: GUI導入に伴い、承認が必要な操作が発生した際はポップアップダイアログや画面上部への通知でユーザに許可を求めます。CLIでは対話プロンプトで[Y/n]を待っていた箇所ですが、GUIでは例えば「エージェントがシステムコマンド`rm -rf /tmp/...`を実行しようとしています。許可しますか？」とメッセージを表示し、「許可」「拒否」のボタンを出します。
- **秘密情報の扱い**: エージェントはユーザプロジェクト内の機密情報（例えばAPIキーがハードコードされているファイルなど）を外部に漏らさないよう厳格なルールを守ります。具体的には、本家Codexの設計にもある「データを保持しない、無断で外部送信しない（Zero Data Retention）」方針を継承し、モデルのプロンプトにもその種の指示を与えます 。DeepResearchでウェブ検索する場合も、問い合わせ内容から秘密らしき文字列はマスクするといった処理を入れます。
- **サンドボックス逸脱検知**: システムに複数エージェントかつ自律度の高い機能を組み込むことで、意図せぬ形でのサンドボックス逸脱リスクが増える可能性があります。zapabob版で16件のE2Eテストにより確認されているように 、既知の抜け道は塞がれていると期待できます。統合版では、そのテストケース群を取り込みCIに組み込むことで、新機能追加によってサンドボックスが破られていないか継続的に検証します。
- **危険操作のオンデマンド実行**: どうしてもセキュリティを緩めねば解決できない課題の場合、ユーザは最終手段として`--dangerously-bypass-approvals-and-sandbox`（`--yolo`）モードに切り替えることができます 。統合版でもこの逃げ道は維持しますが、GUI上で有効化する際には複数の確認を入れるなど慎重に扱います。

以上、セキュリティと承認フローに関する要件でした。

## 非機能要件

本章では、本システムに求められる非機能要件（性能、保守性、互換性など）を定義します。

- **性能要件**:
  - 高速起動: システムの起動時間は、本家Codexに匹敵する高速性を維持します。Zapabob版で達成された平均約129msという起動時間 を目安とし、GUIモードでも数秒以内に対話開始できることを目指します。
  - メモリ・バイナリ効率: 機能が増えても不要なメモリ消費を抑え、リリースビルド時のバイナリサイズも可能な限り小さく保ちます。Zapabob版では約38MBまで最適化されているため、40MB前後程度を目標とします。
  - レスポンス速度: 並列化の恩恵で応答時間を短縮しつつ、マルチエージェント協調処理によるオーバーヘッドを最適化でカバーします。
  - スケーラビリティ: プロジェクト規模が大きくなっても性能劣化が極端にならないようにし、必要に応じて要約や検索を活用します。
- **互換性要件**:
  - 既存CLIとの互換性: 統合版Codexは従来のCodex CLIと後方互換であることが求められます。新機能はデフォルトで無効または安全側に寄った挙動とし、ユーザが明示的に有効化した場合のみ作用するようにします。
  - IDE拡張との両立: VS Code拡張やCursorなど既存ツールとの互換性も維持します。CLIモードの基本入出力仕様は変更しないため、拡張はそのまま動作します。
  - プラットフォーム互換: 対応OS（Linux, macOS, Windows/WSL）の範囲およびサンドボックス実装は本家と同一であることを保証します 。
- **保守性・可読性要件**:
  - 最小限のコード分岐: 既存コードを直接改変する量は必要最小限に留め、追加モジュールやプラグインアーキテクチャで機能を盛り込みます。
  - コード品質: Zapabob版で達成された警告ゼロの状態 を維持します。Rustコンパイラの警告は全て潰し、Clippyの指摘も重要なものは修正して出荷します。
  - ドキュメントと設定: 新機能に関するドキュメント（README追補や専用MDファイル、CLIヘルプメッセージ）を充実させます。
  - テストとCI: Zapabob版で追加された各種テスト（E2E含む50/50の全テストパス ）を統合し、本家CodexのCIに組み込みます。
- **拡張性要件**:
  - 将来の拡張を見据え、エージェント役割の追加や新ツール導入に柔軟に対応できるアーキテクチャとします。
  - OpenAI本家との整合性を意識し、アップストリームの計画と競合しないよう仕様をすり合わせます。

以上、非機能要件をまとめました。

## 実装上の考慮事項（アップストリーム互換性）

提案する機能群を実装するにあたり、OpenAI Codex本家リポジトリへの取り込みやすさを高め、既存コードとの整合性を保つための方針と注意点を以下にまとめます。

- **フラグ・オプション設計**: 新機能はすべてオプションフラグまたは設定ファイルキーで有効化/無効化できるように実装します。これにより、本家へのPR時に「デフォルト無効なので既存ユーザ影響なし」と説明できます。
- **段階的マージ**: 全機能を一度に巨大な変更として出すのではなく、機能単位でブランチを分け、段階的にPRを提出する戦略を取ります。
- **コードスタイル統一**: 本家Codexのコーディングスタイル（Rustfmtや変数命名規則）に準拠します。diffが目立たないよう、不要なリファクタは混ぜません。
- **機能トグルによるリスク低減**: 新機能実装箇所にはコンパイル時/実行時の機能トグルを設け、必要に応じて無効化できるようにします。
- **テスト・検証の充実**: 追加機能には自動テストを必ず用意し、本家CIですべてパスすることを確認してからPR提出します。
- **アップストリームIssue参照**: 開発中およびPR作成時には、本家CodexのIssueで関連するものがあれば言及し、コミュニティの需要に応えるものであることを示します。
- **機能トレードオフ説明**: GUIに関しては本家があえてCLIに留めている可能性もあるため、その場合は統合版では公式に含めず、外部ツールとして提供する選択肢も検討します。

以上の考慮により、Codex機能拡張統合がスムーズに本家コードベースにマージされ、より強力で利便性の高いCodexとしてユーザに提供されることを期待します。

---

### 参考文献・出典

- 【6】 zapabob氏 提供: 「本番環境対応のメタオーケストレーション機能追加」Pull Request記述 – Zapabob版CodexにおけるOpenAI Codexとの差分表および新機能概要
- 【8】 zapabob氏 提供: Zapabob版Codexのコミットログ – マルチエージェントスーパーバイザ、DeepResearch、セキュリティプロファイル等の詳細
- 【10】 OpenAI 開発者ドキュメント: Codexセキュリティガイド – Codexのサンドボックス動作と承認オプションの公式解説
- 【15】 OpenAI 開発者ガイド: Agents SDK と Codex の連携 – MCPによるCodex CLIのエージェント化とワークフロー拡張
- 【19】 zapabob氏 提供: Zapabob版Codexの差分（TokenBudgeter/AuditLogger） – トークン予算管理と監査ログ機能の具体的内容
