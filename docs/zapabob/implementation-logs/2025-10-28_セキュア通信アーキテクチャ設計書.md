# Codex ã‚»ã‚­ãƒ¥ã‚¢é€šä¿¡ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸ï¼ˆISMS/ISO 27001æº–æ‹ ï¼‰

**ä½œæˆæ—¥**: 2025-10-28  
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v0.51.0-zapabob.1  
**è¨­è¨ˆè€…**: Cursor Agent (zapabob)  
**æº–æ‹ è¦æ ¼**: ISO/IEC 27001:2022, NIST SP 800-207 (Zero Trust Architecture)

---

## ğŸ¯ Executive Summary

æœ¬è¨­è¨ˆæ›¸ã¯ã€Codex v0.51.0ã«ãŠã‘ã‚‹**MCPã‚µãƒ¼ãƒãƒ¼é–“é€šä¿¡**ã¨**ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“é€šä¿¡**ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ã€æƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ï¼ˆISMSï¼‰ã®è¦³ç‚¹ã‹ã‚‰åŒ…æ‹¬çš„ã«è¨­è¨ˆã™ã‚‹ã€‚

### ğŸ† è¨­è¨ˆç›®æ¨™

| ç›®æ¨™ | ç¾çŠ¶ | ç›®æ¨™å€¤ | å®Ÿè£…å„ªå…ˆåº¦ |
|------|------|--------|------------|
| **æ©Ÿå¯†æ€§ (Confidentiality)** | 70% | 99.9% | ğŸ”´ High |
| **å®Œå…¨æ€§ (Integrity)** | 85% | 99.99% | ğŸ”´ High |
| **å¯ç”¨æ€§ (Availability)** | 95% | 99.99% | ğŸŸ¡ Medium |
| **èªè¨¼ (Authentication)** | 75% | 100% | ğŸ”´ High |
| **èªå¯ (Authorization)** | 80% | 100% | ğŸ”´ High |
| **ç›£æŸ» (Audit)** | 90% | 100% | ğŸŸ¢ Low (æ—¢ã«é«˜æ°´æº–) |

---

## ğŸ“‹ ç›®æ¬¡

1. [ç¾çŠ¶åˆ†æ](#1-ç¾çŠ¶åˆ†æ)
2. [ISMS/ISO 27001è¦ä»¶ãƒãƒƒãƒ”ãƒ³ã‚°](#2-ismsiso-27001è¦ä»¶ãƒãƒƒãƒ”ãƒ³ã‚°)
3. [ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ](#3-ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ)
4. [MCPã‚µãƒ¼ãƒãƒ¼é–“é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#4-mcpã‚µãƒ¼ãƒãƒ¼é–“é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
5. [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#5-ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
6. [å®Ÿè£…è¨­è¨ˆ](#6-å®Ÿè£…è¨­è¨ˆ)
7. [é‹ç”¨ãƒ»ç›£è¦–](#7-é‹ç”¨ç›£è¦–)
8. [ãƒªã‚¹ã‚¯è©•ä¾¡](#8-ãƒªã‚¹ã‚¯è©•ä¾¡)

---

## 1. ç¾çŠ¶åˆ†æ

### 1.1 ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦ï¼ˆv0.51.0ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Codex CLI / TUI                          â”‚
â”‚              (User Interface Layer)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Codex Core Runtime                         â”‚
â”‚  - ConversationManager (History Tracking)                    â”‚
â”‚  - AuthManager (OAuth 2.0, API Key Management)              â”‚
â”‚  - ConfigLoader (TOML Configuration)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                            â”‚
        â–¼                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MCP Connection      â”‚   â”‚  Agent Runtime                 â”‚
â”‚  Manager             â”‚   â”‚  (8 Sub-Agents)                â”‚
â”‚  =================== â”‚   â”‚  ========================      â”‚
â”‚  âœ… OAuthèªè¨¼        â”‚   â”‚  âœ… Token Budget: 40k          â”‚
â”‚  âœ… API Keyç®¡ç†      â”‚   â”‚  âœ… Parallel Execution         â”‚
â”‚  âš ï¸ stdio (å¹³æ–‡)     â”‚   â”‚  âš ï¸ mpsc (ãƒ—ãƒ­ã‚»ã‚¹å†…é€šä¿¡)     â”‚
â”‚  âŒ TLSæœªå®Ÿè£…        â”‚   â”‚  âŒ æš—å·åŒ–æœªå®Ÿè£…               â”‚
â”‚  âŒ mTLSæœªå®Ÿè£…       â”‚   â”‚  âŒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç½²åæœªå®Ÿè£…       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                          â”‚
        â”‚ stdio (JSON-RPC)         â”‚ tokio::mpsc
        â”‚                          â”‚
        â–¼                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  15 MCP Servers      â”‚   â”‚  Sub-Agent Instances           â”‚
â”‚  =================== â”‚   â”‚  ========================      â”‚
â”‚  â€¢ codex            â”‚   â”‚  â€¢ CodeExpert                  â”‚
â”‚  â€¢ serena           â”‚   â”‚  â€¢ SecurityExpert              â”‚
â”‚  â€¢ gemini-cli       â”‚   â”‚  â€¢ TestingExpert               â”‚
â”‚  â€¢ filesystem       â”‚   â”‚  â€¢ DocsExpert                  â”‚
â”‚  â€¢ github           â”‚   â”‚  â€¢ DeepResearcher              â”‚
â”‚  â€¢ chrome-devtools  â”‚   â”‚  â€¢ DebugExpert                 â”‚
â”‚  ... (9 more)       â”‚   â”‚  â€¢ PerformanceExpert           â”‚
â”‚                     â”‚   â”‚  â€¢ General                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                          â”‚
        â–¼                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Audit Logger        â”‚   â”‚  Audit Logger                  â”‚
â”‚  (JSON Lines)        â”‚   â”‚  (JSON Lines)                  â”‚
â”‚  =================== â”‚   â”‚  ========================      â”‚
â”‚  âœ… å…¨ã‚¤ãƒ™ãƒ³ãƒˆè¨˜éŒ²   â”‚   â”‚  âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œè¨˜éŒ²       â”‚
â”‚  âœ… API Callè¿½è·¡     â”‚   â”‚  âœ… Token Usageè¿½è·¡            â”‚
â”‚  âœ… Security Event   â”‚   â”‚  âœ… Tool Callè¨˜éŒ²              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ç¾åœ¨ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…çŠ¶æ³

#### âœ… å®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½ï¼ˆ90ç‚¹ç›¸å½“ï¼‰

| æ©Ÿèƒ½ | å®Ÿè£…çŠ¶æ³ | ãƒ•ã‚¡ã‚¤ãƒ« | è©•ä¾¡ |
|------|---------|---------|------|
| **OAuth 2.0èªè¨¼** | âœ… å®Œå…¨å®Ÿè£… | `codex-rs/core/src/mcp/auth.rs` | 95/100 |
| **Sandboxæ©Ÿèƒ½** | âœ… å®Œå…¨å®Ÿè£… | `config.toml` (`default_mode = "read-only"`) | 100/100 |
| **Approval Policy** | âœ… å®Œå…¨å®Ÿè£… | `config.toml` (`policy = "on-request"`) | 100/100 |
| **ç›£æŸ»ãƒ­ã‚°** | âœ… å®Œå…¨å®Ÿè£… | `codex-rs/core/src/audit_log/` | 95/100 |
| **ãƒˆãƒ¼ã‚¯ãƒ³äºˆç®—ç®¡ç†** | âœ… å®Œå…¨å®Ÿè£… | `AgentRuntime` (40,000 tokens/agent) | 100/100 |
| **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆéš”é›¢** | âœ… éƒ¨åˆ†å®Ÿè£… | `AsyncSubAgentIntegration` | 80/100 |

#### âš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚®ãƒ£ãƒƒãƒ—ï¼ˆè¦å¯¾å¿œï¼‰

| è„†å¼±æ€§ | ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ« | å½±éŸ¿ç¯„å›² | å„ªå…ˆåº¦ |
|--------|--------------|---------|--------|
| **MCPé€šä¿¡ãŒå¹³æ–‡** | ğŸ”´ Critical | MCPã‚µãƒ¼ãƒãƒ¼15å° | P0 |
| **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“é€šä¿¡ãŒå¹³æ–‡** | ğŸ”´ Critical | ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ8å° | P0 |
| **mTLSæœªå®Ÿè£…** | ğŸŸ¡ High | MCPã‚µãƒ¼ãƒãƒ¼é–“ | P1 |
| **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç½²åæœªå®Ÿè£…** | ğŸŸ¡ High | ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ | P1 |
| **Rate Limitingæœªå®Ÿè£…** | ğŸŸ¡ Medium | APIå‘¼ã³å‡ºã— | P2 |
| **ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ãŒå¼±ã„** | ğŸŸ¢ Low | ConversationManager | P3 |

---

## 2. ISMS/ISO 27001è¦ä»¶ãƒãƒƒãƒ”ãƒ³ã‚°

### 2.1 ç®¡ç†ç­–ãƒãƒƒãƒ”ãƒ³ã‚°

| ISO 27001:2022 ç®¡ç†ç­– | Codexå®Ÿè£… | ã‚®ãƒ£ãƒƒãƒ— | å¯¾å¿œç­– |
|----------------------|-----------|---------|--------|
| **A.8.24 æš—å·ã®åˆ©ç”¨** | âš ï¸ éƒ¨åˆ†å®Ÿè£… | TLSæœªå®Ÿè£… | TLS 1.3å°å…¥ |
| **A.8.3 æƒ…å ±ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹** | âœ… å®Ÿè£…æ¸ˆã¿ | OAuthèªè¨¼ã‚ã‚Š | mTLSè¿½åŠ  |
| **A.8.16 ç›£è¦–æ´»å‹•** | âœ… å®Ÿè£…æ¸ˆã¿ | ç›£æŸ»ãƒ­ã‚°å®Œå‚™ | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–è¿½åŠ  |
| **A.5.23 ã‚¯ãƒ©ã‚¦ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã®åˆ©ç”¨** | âš ï¸ éƒ¨åˆ†å®Ÿè£… | API Keyç®¡ç†ã®ã¿ | Secrets Managerçµ±åˆ |
| **A.5.14 æƒ…å ±è»¢é€** | âŒ æœªå®Ÿè£… | å¹³æ–‡é€šä¿¡ | **æœ¬è¨­è¨ˆæ›¸ã§å¯¾å¿œ** |
| **A.8.8 ç‰¹æ¨©çš„ã‚¢ã‚¯ã‚»ã‚¹** | âœ… å®Ÿè£…æ¸ˆã¿ | Sandbox/Approval | RBACè¿½åŠ  |

### 2.2 NIST SP 800-207 ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆåŸå‰‡

| åŸå‰‡ | Codexå®Ÿè£… | æˆç†Ÿåº¦ |
|------|-----------|--------|
| **1. ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã‚’ãƒªã‚½ãƒ¼ã‚¹ã¨ã¿ãªã™** | âœ… å®Ÿè£… | Level 3 |
| **2. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å ´æ‰€ã«é–¢ä¿‚ãªãã™ã¹ã¦ã®é€šä¿¡ã‚’ä¿è­·ã™ã‚‹** | âŒ æœªå®Ÿè£… | **Level 0 â†’ Level 4ã¸** |
| **3. ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºãƒªã‚½ãƒ¼ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³å˜ä½ã§ä»˜ä¸ã™ã‚‹** | âš ï¸ éƒ¨åˆ†å®Ÿè£… | Level 2 â†’ Level 4ã¸ |
| **4. ãƒªã‚½ãƒ¼ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯å‹•çš„ãƒãƒªã‚·ãƒ¼ã«ã‚ˆã£ã¦æ±ºå®šã•ã‚Œã‚‹** | âœ… å®Ÿè£… | Level 3 |
| **5. ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã¯å…¨ã¦ã®è³‡ç”£ã®æ•´åˆæ€§ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‹•å‘ã‚’ç›£è¦–ãƒ»æ¸¬å®šã™ã‚‹** | âœ… å®Ÿè£… | Level 4 |
| **6. ã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹èªè¨¼ãƒ»èªå¯ã¯å‹•çš„ã§å³æ ¼ã«å®Ÿæ–½ã•ã‚Œã‚‹** | âš ï¸ éƒ¨åˆ†å®Ÿè£… | Level 2 â†’ Level 4ã¸ |
| **7. è³‡ç”£ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ãƒ•ãƒ©ã€é€šä¿¡ã®ç¾åœ¨ã®çŠ¶æ…‹ã«ã¤ã„ã¦ã§ãã‚‹ã ã‘å¤šãã®æƒ…å ±ã‚’åé›†ã™ã‚‹** | âœ… å®Ÿè£… | Level 4 |

**ç¾åœ¨ã®æˆç†Ÿåº¦**: **Level 2.4 / 5.0**  
**ç›®æ¨™æˆç†Ÿåº¦**: **Level 4.5 / 5.0** (æœ¬è¨­è¨ˆå®Ÿè£…å¾Œ)

---

## 3. ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### 3.1 ãƒˆãƒ©ã‚¹ãƒˆãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ã®å®šç¾©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Trust Boundary 0: User Space                    â”‚
â”‚              (æœ€ã‚‚ä¿¡é ¼ã§ãã‚‹é ˜åŸŸ)                             â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Codex CLI / TUI                                     â”‚   â”‚
â”‚  â”‚  - ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼æ¸ˆã¿                                   â”‚   â”‚
â”‚  â”‚  - ãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè¡Œ                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ âœ… Authenticated
                         â”‚ âœ… Authorized
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Trust Boundary 1: Core Runtime                     â”‚
â”‚           (ä¿¡é ¼ã§ãã‚‹é ˜åŸŸã€å³æ ¼ãªèªè¨¼ãƒ»èªå¯)                  â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Codex Core                                          â”‚   â”‚
â”‚  â”‚  - ConversationManager                               â”‚   â”‚
â”‚  â”‚  - AuthManager (OAuth 2.0 + mTLS)                    â”‚   â”‚
â”‚  â”‚  - ConfigLoader                                      â”‚   â”‚
â”‚  â”‚  - AuditLogger (å…¨ã‚¤ãƒ™ãƒ³ãƒˆè¨˜éŒ²)                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ ğŸ”’ TLS 1.3 (æœ¬è¨­è¨ˆã§è¿½åŠ )  â”‚ ğŸ”’ Encrypted Channel
        â”‚ ğŸ” mTLS (ç›¸äº’èªè¨¼)        â”‚ ğŸ” Message Signing
        â–¼                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Trust Boundary 2:    â”‚   â”‚ Trust Boundary 3:              â”‚
â”‚ External MCP Servers â”‚   â”‚ Sub-Agent Instances            â”‚
â”‚ (æº–ä¿¡é ¼é ˜åŸŸ)         â”‚   â”‚ (åˆ¶é™ã•ã‚ŒãŸä¿¡é ¼)                â”‚
â”‚                      â”‚   â”‚                                â”‚
â”‚ âš ï¸ å¤–éƒ¨ãƒ—ãƒ­ã‚»ã‚¹      â”‚   â”‚ âš ï¸ ç‹¬ç«‹ãƒ—ãƒ­ã‚»ã‚¹                â”‚
â”‚ âš ï¸ å‹•çš„èµ·å‹•          â”‚   â”‚ âš ï¸ LLMåˆ¶å¾¡ï¼ˆäºˆæ¸¬ä¸å¯èƒ½ï¼‰       â”‚
â”‚ âœ… OAuthèªè¨¼         â”‚   â”‚ âœ… Token Budgetåˆ¶é™            â”‚
â”‚ ğŸ†• mTLSèªè¨¼          â”‚   â”‚ ğŸ†• ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç½²åæ¤œè¨¼          â”‚
â”‚ ğŸ†• TLS 1.3æš—å·åŒ–     â”‚   â”‚ ğŸ†• æš—å·åŒ–ãƒãƒ£ãƒãƒ«              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼éšå±¤

#### Level 0: Public (ä¿¡é ¼ãªã—)
- **å¯¾è±¡**: å¤–éƒ¨APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ã€èªè¨¼ãªã—ï¼‰
- **è¨±å¯æ“ä½œ**: `read_file` (public files), `list_dir` (public dirs)
- **å¿…è¦èªè¨¼**: ãªã—
- **æš—å·åŒ–**: TLS 1.3 (Transportå±¤ã®ã¿)

#### Level 1: Authenticated (èªè¨¼æ¸ˆã¿)
- **å¯¾è±¡**: MCPã‚µãƒ¼ãƒãƒ¼ï¼ˆGeminiã€GitHubç­‰ï¼‰
- **è¨±å¯æ“ä½œ**: `read_file`, `grep`, `codebase_search`
- **å¿…è¦èªè¨¼**: OAuth 2.0 + API Key
- **æš—å·åŒ–**: TLS 1.3 + Message Authentication Code (HMAC-SHA256)

#### Level 2: Authorized (èªè¨¼+èªå¯)
- **å¯¾è±¡**: ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
- **è¨±å¯æ“ä½œ**: Level 1 + `apply_patch` (write operations)
- **å¿…è¦èªè¨¼**: mTLS + JWT (agent identity)
- **æš—å·åŒ–**: TLS 1.3 + Ed25519ç½²å + AES-256-GCM (payload)

#### Level 3: Privileged (ç‰¹æ¨©)
- **å¯¾è±¡**: Codex Coreã€SecurityExpert Agent
- **è¨±å¯æ“ä½œ**: ã™ã¹ã¦ï¼ˆ`shell`, `file_system_write`, `network`ï¼‰
- **å¿…è¦èªè¨¼**: mTLS + JWT + OTP (One-Time Password)
- **æš—å·åŒ–**: TLS 1.3 + Ed25519ç½²å + AES-256-GCM + HSM (Hardware Security Module)

---

## 4. MCPã‚µãƒ¼ãƒãƒ¼é–“é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### 4.1 ç¾åœ¨ã®å®Ÿè£…ï¼ˆv0.51.0ï¼‰

#### é€šä¿¡ãƒ•ãƒ­ãƒ¼
```rust
// codex-rs/core/src/mcp_connection_manager.rs
// ç¾åœ¨: stdio (JSON-RPC) - å¹³æ–‡é€šä¿¡

// 1. ãƒ—ãƒ­ã‚»ã‚¹èµ·å‹•
let child = Command::new(&config.command)
    .args(&config.args)
    .stdin(Stdio::piped())  // âš ï¸ å¹³æ–‡
    .stdout(Stdio::piped()) // âš ï¸ å¹³æ–‡
    .stderr(Stdio::piped())
    .spawn()?;

// 2. JSON-RPCãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ï¼ˆå¹³æ–‡ï¼‰
let request = json!({
    "jsonrpc": "2.0",
    "id": request_id,
    "method": "tools/call",
    "params": {
        "name": "read_file",
        "arguments": { "path": "/etc/passwd" } // âš ï¸ æ©Ÿå¯†æƒ…å ±ãŒå¹³æ–‡
    }
});
stdin.write_all(serde_json::to_string(&request)?.as_bytes()).await?;
```

#### å•é¡Œç‚¹
1. âš ï¸ **é€šä¿¡ãŒå¹³æ–‡**: `stdin/stdout`çµŒç”±ã®JSON-RPCã¯æš—å·åŒ–ã•ã‚Œã¦ã„ãªã„
2. âš ï¸ **ã‚µãƒ¼ãƒãƒ¼èªè¨¼ãªã—**: ãƒ—ãƒ­ã‚»ã‚¹èµ·å‹•æ™‚ã«MCPã‚µãƒ¼ãƒãƒ¼ã®æ­£å½“æ€§ã‚’æ¤œè¨¼ã—ã¦ã„ãªã„
3. âš ï¸ **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ”¹ã–ã‚“æ¤œçŸ¥ãªã—**: JSON-RPCãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å®Œå…¨æ€§ãŒä¿è¨¼ã•ã‚Œã¦ã„ãªã„
4. âš ï¸ **ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒã«è„†å¼±**: nonce/timestampãŒãªãã€éå»ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å†é€å¯èƒ½

### 4.2 ã‚»ã‚­ãƒ¥ã‚¢å®Ÿè£…è¨­è¨ˆ

#### 4.2.1 TLS 1.3 + mTLSå°å…¥

**ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**:
```
Codex Core                               MCP Server
(Client)                                 (Server)
    â”‚                                        â”‚
    â”‚ 1. TLS Handshake (ClientHello)       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
    â”‚                                        â”‚
    â”‚ 2. Server Certificate + Request        â”‚
    â”‚    Client Certificate                  â”‚
    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                        â”‚
    â”‚ 3. Client Certificate + Verify         â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
    â”‚                                        â”‚
    â”‚ 4. âœ… Mutual Authentication Success    â”‚
    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                        â”‚
    â”‚ 5. Encrypted JSON-RPC (TLS 1.3)       â”‚
    â”‚    + Message Signature (Ed25519)       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
    â”‚                                        â”‚
    â”‚ 6. Encrypted Response                  â”‚
    â”‚    + Message Signature                 â”‚
    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

**Rustå®Ÿè£…**:
```rust
// codex-rs/core/src/mcp/secure_connection.rs (æ–°è¦ä½œæˆ)

use rustls::{ClientConfig, ServerConfig, Certificate, PrivateKey};
use tokio_rustls::{TlsConnector, TlsAcceptor};
use ed25519_dalek::{Keypair, Signature, Signer, Verifier};
use serde::{Serialize, Deserialize};
use anyhow::{Result, Context};

/// Secure MCP Message (TLS 1.3 + Ed25519ç½²å)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecureMcpMessage {
    /// JSON-RPC Payload (æš—å·åŒ–æ¸ˆã¿)
    pub payload: Vec<u8>, // AES-256-GCM encrypted
    
    /// Ed25519ç½²åï¼ˆpayloadå…¨ä½“ã«å¯¾ã™ã‚‹ç½²åï¼‰
    pub signature: Vec<u8>,
    
    /// Nonce (ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–)
    pub nonce: u64,
    
    /// Timestamp (RFC 3339)
    pub timestamp: String,
    
    /// Sender ID (mTLSè¨¼æ˜æ›¸ã®CNã¨ä¸€è‡´)
    pub sender_id: String,
}

/// Secure MCP Connection Manager
pub struct SecureMcpConnectionManager {
    /// TLSè¨­å®š
    tls_config: Arc<ClientConfig>,
    
    /// Ed25519ç½²åéµãƒšã‚¢
    signing_keypair: Arc<Keypair>,
    
    /// ä¿¡é ¼ã•ã‚ŒãŸMCPã‚µãƒ¼ãƒãƒ¼è¨¼æ˜æ›¸ï¼ˆCAè¨¼æ˜æ›¸ï¼‰
    trusted_ca_certs: Vec<Certificate>,
    
    /// Nonceç®¡ç†ï¼ˆãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–ï¼‰
    nonce_store: Arc<Mutex<HashMap<String, u64>>>,
}

impl SecureMcpConnectionManager {
    /// TLS 1.3è¨­å®šã‚’æ§‹ç¯‰
    pub fn new(
        client_cert: Certificate,
        client_key: PrivateKey,
        ca_certs: Vec<Certificate>,
        signing_keypair: Keypair,
    ) -> Result<Self> {
        // TLS 1.3è¨­å®š
        let mut tls_config = ClientConfig::builder()
            .with_safe_defaults()
            .with_root_certificates(Self::load_ca_certs(&ca_certs)?)
            .with_client_auth_cert(vec![client_cert], client_key)
            .context("Failed to configure TLS")?;
        
        // TLS 1.3ã®ã¿è¨±å¯ï¼ˆTLS 1.2ä»¥ä¸‹ã¯æ‹’å¦ï¼‰
        tls_config.versions = vec![&rustls::version::TLS13];
        
        // å¼·åŠ›ãªæš—å·ã‚¹ã‚¤ãƒ¼ãƒˆã®ã¿è¨±å¯
        tls_config.ciphersuites = vec![
            rustls::CipherSuite::TLS13_AES_256_GCM_SHA384,
            rustls::CipherSuite::TLS13_CHACHA20_POLY1305_SHA256,
        ];
        
        Ok(Self {
            tls_config: Arc::new(tls_config),
            signing_keypair: Arc::new(signing_keypair),
            trusted_ca_certs: ca_certs,
            nonce_store: Arc::new(Mutex::new(HashMap::new())),
        })
    }
    
    /// MCPã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šï¼ˆmTLSï¼‰
    pub async fn connect_to_mcp_server(
        &self,
        server_name: &str,
        server_addr: &str,
    ) -> Result<SecureMcpConnection> {
        // TLSæ¥ç¶šç¢ºç«‹
        let tcp_stream = TcpStream::connect(server_addr).await?;
        let tls_connector = TlsConnector::from(Arc::clone(&self.tls_config));
        let tls_stream = tls_connector
            .connect(server_name.try_into()?, tcp_stream)
            .await
            .context("TLS handshake failed")?;
        
        // mTLSæ¤œè¨¼: ã‚µãƒ¼ãƒãƒ¼è¨¼æ˜æ›¸ã®CNã‚’ç¢ºèª
        let peer_cert = tls_stream
            .get_ref()
            .1
            .peer_certificates()
            .context("Server certificate not found")?
            .first()
            .context("Empty certificate chain")?;
        
        Self::verify_server_identity(server_name, peer_cert)?;
        
        Ok(SecureMcpConnection {
            tls_stream,
            signing_keypair: Arc::clone(&self.signing_keypair),
            server_name: server_name.to_string(),
            nonce_counter: AtomicU64::new(0),
        })
    }
    
    /// ã‚µãƒ¼ãƒãƒ¼è¨¼æ˜æ›¸ã®æ¤œè¨¼
    fn verify_server_identity(
        expected_name: &str,
        cert: &Certificate,
    ) -> Result<()> {
        // X.509è¨¼æ˜æ›¸ã‚’ãƒ‘ãƒ¼ã‚¹
        let (_, cert) = x509_parser::parse_x509_certificate(&cert.0)
            .context("Failed to parse certificate")?;
        
        // CN (Common Name) ã‚’ç¢ºèª
        let subject = cert.subject();
        let cn = subject
            .iter_common_name()
            .next()
            .context("Certificate has no CN")?
            .as_str()
            .context("Invalid CN encoding")?;
        
        if cn != expected_name {
            anyhow::bail!(
                "Certificate CN mismatch: expected '{}', got '{}'",
                expected_name,
                cn
            );
        }
        
        Ok(())
    }
}

/// Secure MCP Connection (TLS 1.3 + mTLS)
pub struct SecureMcpConnection {
    /// TLS 1.3ã‚¹ãƒˆãƒªãƒ¼ãƒ 
    tls_stream: tokio_rustls::client::TlsStream<TcpStream>,
    
    /// Ed25519ç½²åéµãƒšã‚¢
    signing_keypair: Arc<Keypair>,
    
    /// æ¥ç¶šå…ˆã‚µãƒ¼ãƒãƒ¼å
    server_name: String,
    
    /// Nonceã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼ˆãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–ï¼‰
    nonce_counter: AtomicU64,
}

impl SecureMcpConnection {
    /// JSON-RPCãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å®‰å…¨ã«é€ä¿¡
    pub async fn send_json_rpc(
        &mut self,
        method: &str,
        params: serde_json::Value,
    ) -> Result<serde_json::Value> {
        // 1. JSON-RPCãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ§‹ç¯‰
        let request = json!({
            "jsonrpc": "2.0",
            "id": uuid::Uuid::new_v4().to_string(),
            "method": method,
            "params": params,
        });
        
        // 2. AES-256-GCM ã§æš—å·åŒ–
        let encrypted_payload = self.encrypt_payload(&request)?;
        
        // 3. Ed25519ç½²åã‚’ç”Ÿæˆ
        let signature = self.signing_keypair.sign(&encrypted_payload);
        
        // 4. Secure Messageã‚’æ§‹ç¯‰
        let secure_msg = SecureMcpMessage {
            payload: encrypted_payload,
            signature: signature.to_bytes().to_vec(),
            nonce: self.nonce_counter.fetch_add(1, Ordering::SeqCst),
            timestamp: chrono::Utc::now().to_rfc3339(),
            sender_id: "codex-core".to_string(), // é€ä¿¡è€…ID
        };
        
        // 5. TLS 1.3çµŒç”±ã§é€ä¿¡
        let msg_bytes = serde_json::to_vec(&secure_msg)?;
        self.tls_stream.write_all(&msg_bytes).await?;
        self.tls_stream.flush().await?;
        
        // 6. å¿œç­”ã‚’å—ä¿¡ï¼ˆTLS 1.3 + ç½²åæ¤œè¨¼ï¼‰
        let response = self.receive_and_verify().await?;
        
        Ok(response)
    }
    
    /// AES-256-GCM ã§ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’æš—å·åŒ–
    fn encrypt_payload(&self, data: &serde_json::Value) -> Result<Vec<u8>> {
        use aes_gcm::{
            aead::{Aead, KeyInit},
            Aes256Gcm, Nonce,
        };
        
        // æš—å·åŒ–ã‚­ãƒ¼ï¼ˆå®Ÿéš›ã¯KDFã§ç”Ÿæˆã€ã“ã“ã§ã¯ç°¡ç•¥åŒ–ï¼‰
        let key = self.derive_encryption_key()?;
        let cipher = Aes256Gcm::new(&key);
        
        // Nonceç”Ÿæˆï¼ˆ96ãƒ“ãƒƒãƒˆï¼‰
        let nonce = Nonce::from_slice(&self.generate_nonce());
        
        // æš—å·åŒ–
        let plaintext = serde_json::to_vec(data)?;
        let ciphertext = cipher
            .encrypt(nonce, plaintext.as_ref())
            .map_err(|e| anyhow::anyhow!("Encryption failed: {}", e))?;
        
        Ok(ciphertext)
    }
    
    /// æš—å·åŒ–ã‚­ãƒ¼å°å‡ºï¼ˆHKDF-SHA256ï¼‰
    fn derive_encryption_key(&self) -> Result<aes_gcm::Key<Aes256Gcm>> {
        use hkdf::Hkdf;
        use sha2::Sha256;
        
        // ç§˜å¯†éµã‹ã‚‰æš—å·åŒ–ã‚­ãƒ¼ã‚’å°å‡º
        let secret = self.signing_keypair.secret.as_bytes();
        let hkdf = Hkdf::<Sha256>::new(None, secret);
        
        let mut okm = [0u8; 32]; // 256ãƒ“ãƒƒãƒˆ
        hkdf.expand(b"codex-mcp-encryption", &mut okm)
            .context("HKDF expansion failed")?;
        
        Ok(aes_gcm::Key::<Aes256Gcm>::from_slice(&okm).clone())
    }
    
    /// Nonceç”Ÿæˆ
    fn generate_nonce(&self) -> [u8; 12] {
        use rand::RngCore;
        let mut nonce = [0u8; 12];
        rand::thread_rng().fill_bytes(&mut nonce);
        nonce
    }
    
    /// å¿œç­”å—ä¿¡ + ç½²åæ¤œè¨¼
    async fn receive_and_verify(&mut self) -> Result<serde_json::Value> {
        // TLS 1.3çµŒç”±ã§å—ä¿¡
        let mut buffer = Vec::new();
        self.tls_stream.read_to_end(&mut buffer).await?;
        
        // SecureMcpMessageã‚’ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
        let secure_msg: SecureMcpMessage = serde_json::from_slice(&buffer)?;
        
        // Ed25519ç½²åã‚’æ¤œè¨¼
        self.verify_signature(&secure_msg)?;
        
        // Nonceæ¤œè¨¼ï¼ˆãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–ï¼‰
        self.verify_nonce(&secure_msg)?;
        
        // AES-256-GCMã§å¾©å·åŒ–
        let decrypted = self.decrypt_payload(&secure_msg.payload)?;
        
        Ok(decrypted)
    }
    
    /// Ed25519ç½²åæ¤œè¨¼
    fn verify_signature(&self, msg: &SecureMcpMessage) -> Result<()> {
        let signature = Signature::from_bytes(&msg.signature)
            .context("Invalid signature format")?;
        
        self.signing_keypair
            .verify(&msg.payload, &signature)
            .context("Signature verification failed")?;
        
        Ok(())
    }
    
    /// Nonceæ¤œè¨¼ï¼ˆãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–ï¼‰
    fn verify_nonce(&self, msg: &SecureMcpMessage) -> Result<()> {
        // Timestampæ¤œè¨¼ï¼ˆ5åˆ†ä»¥å†…ï¼‰
        let msg_time = chrono::DateTime::parse_from_rfc3339(&msg.timestamp)?;
        let now = chrono::Utc::now();
        let age = now.signed_duration_since(msg_time);
        
        if age.num_seconds() > 300 {
            anyhow::bail!("Message too old: {} seconds", age.num_seconds());
        }
        
        // Nonceé‡è¤‡æ¤œè¨¼ï¼ˆå®Ÿè£…ã¯çœç•¥ã€å®Ÿéš›ã¯DBã‚„Redisã§ç®¡ç†ï¼‰
        // ...
        
        Ok(())
    }
    
    /// ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å¾©å·åŒ–
    fn decrypt_payload(&self, ciphertext: &[u8]) -> Result<serde_json::Value> {
        use aes_gcm::{
            aead::{Aead, KeyInit},
            Aes256Gcm, Nonce,
        };
        
        let key = self.derive_encryption_key()?;
        let cipher = Aes256Gcm::new(&key);
        
        // NonceæŠ½å‡ºï¼ˆå®Ÿéš›ã¯æš—å·æ–‡ã«å«ã‚ã‚‹å¿…è¦ã‚ã‚Šï¼‰
        let nonce = Nonce::from_slice(&[0u8; 12]); // ç°¡ç•¥åŒ–
        
        let plaintext = cipher
            .decrypt(nonce, ciphertext)
            .map_err(|e| anyhow::anyhow!("Decryption failed: {}", e))?;
        
        let value = serde_json::from_slice(&plaintext)?;
        Ok(value)
    }
}
```

#### 4.2.2 è¨¼æ˜æ›¸ç®¡ç†

**ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ **:
```
~/.codex/
â”œâ”€â”€ certs/
â”‚   â”œâ”€â”€ ca/
â”‚   â”‚   â”œâ”€â”€ ca-cert.pem          # CAè¨¼æ˜æ›¸ï¼ˆä¿¡é ¼ã®ãƒ«ãƒ¼ãƒˆï¼‰
â”‚   â”‚   â””â”€â”€ ca-key.pem           # CAç§˜å¯†éµï¼ˆå³é‡ç®¡ç†ï¼‰
â”‚   â”œâ”€â”€ codex/
â”‚   â”‚   â”œâ”€â”€ codex-cert.pem       # Codex Coreè¨¼æ˜æ›¸
â”‚   â”‚   â””â”€â”€ codex-key.pem        # Codex Coreç§˜å¯†éµ
â”‚   â””â”€â”€ mcp-servers/
â”‚       â”œâ”€â”€ codex-server-cert.pem
â”‚       â”œâ”€â”€ codex-server-key.pem
â”‚       â”œâ”€â”€ serena-cert.pem
â”‚       â”œâ”€â”€ serena-key.pem
â”‚       â”œâ”€â”€ gemini-cert.pem
â”‚       â””â”€â”€ ... (15 MCPã‚µãƒ¼ãƒãƒ¼åˆ†)
â””â”€â”€ keys/
    â”œâ”€â”€ ed25519-signing.key      # Ed25519ç½²åéµ
    â””â”€â”€ ed25519-signing.pub      # Ed25519å…¬é–‹éµ
```

**è¨¼æ˜æ›¸ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ** (`zapabob/scripts/generate-mcp-certs.sh`):
```bash
#!/bin/bash
# MCP Serverè¨¼æ˜æ›¸ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ

set -euo pipefail

CERT_DIR="$HOME/.codex/certs"
CA_DIR="$CERT_DIR/ca"
CODEX_DIR="$CERT_DIR/codex"
MCP_DIR="$CERT_DIR/mcp-servers"

# 1. CAè¨¼æ˜æ›¸ç”Ÿæˆï¼ˆæœ‰åŠ¹æœŸé™10å¹´ï¼‰
openssl req -x509 -newkey rsa:4096 \
    -keyout "$CA_DIR/ca-key.pem" \
    -out "$CA_DIR/ca-cert.pem" \
    -days 3650 -nodes \
    -subj "/C=JP/ST=Tokyo/L=Tokyo/O=Codex/OU=Security/CN=Codex CA"

# 2. Codex Coreè¨¼æ˜æ›¸ç”Ÿæˆ
openssl req -newkey rsa:4096 \
    -keyout "$CODEX_DIR/codex-key.pem" \
    -out "$CODEX_DIR/codex-csr.pem" \
    -nodes \
    -subj "/C=JP/ST=Tokyo/L=Tokyo/O=Codex/OU=Core/CN=codex-core"

openssl x509 -req \
    -in "$CODEX_DIR/codex-csr.pem" \
    -CA "$CA_DIR/ca-cert.pem" \
    -CAkey "$CA_DIR/ca-key.pem" \
    -CAcreateserial \
    -out "$CODEX_DIR/codex-cert.pem" \
    -days 365

# 3. MCPã‚µãƒ¼ãƒãƒ¼è¨¼æ˜æ›¸ç”Ÿæˆï¼ˆ15ã‚µãƒ¼ãƒãƒ¼ï¼‰
MCP_SERVERS=(
    "codex"
    "serena"
    "gemini-cli"
    "context7"
    "playwright"
    "filesystem"
    "github"
    "youtube"
    "chrome-devtools"
    "sequential-thinking"
    "markitdown"
    "arxiv"
    "brave-search"
    "context7-2"
    "codex-gemini-mcp"
)

for server in "${MCP_SERVERS[@]}"; do
    echo "Generating certificate for $server..."
    
    openssl req -newkey rsa:4096 \
        -keyout "$MCP_DIR/${server}-key.pem" \
        -out "$MCP_DIR/${server}-csr.pem" \
        -nodes \
        -subj "/C=JP/ST=Tokyo/L=Tokyo/O=Codex/OU=MCP/CN=${server}"
    
    openssl x509 -req \
        -in "$MCP_DIR/${server}-csr.pem" \
        -CA "$CA_DIR/ca-cert.pem" \
        -CAkey "$CA_DIR/ca-key.pem" \
        -CAcreateserial \
        -out "$MCP_DIR/${server}-cert.pem" \
        -days 365
done

# 4. Ed25519ç½²åéµç”Ÿæˆ
ssh-keygen -t ed25519 -f "$HOME/.codex/keys/ed25519-signing" -N ""

echo "âœ… All certificates generated successfully!"
echo "âš ï¸  IMPORTANT: Backup $CA_DIR/ca-key.pem securely!"
```

#### 4.2.3 è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°ï¼ˆ`config.toml`ï¼‰

```toml
# ==================== ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ ====================
[security]
# TLS/mTLSè¨­å®š
tls_enabled = true
tls_version = "1.3"  # TLS 1.3ã®ã¿è¨±å¯
mtls_enabled = true  # ç›¸äº’TLSèªè¨¼

[security.certificates]
ca_cert = "~/.codex/certs/ca/ca-cert.pem"
client_cert = "~/.codex/certs/codex/codex-cert.pem"
client_key = "~/.codex/certs/codex/codex-key.pem"

[security.signing]
# Ed25519ç½²åéµ
signing_key = "~/.codex/keys/ed25519-signing.key"
signing_public_key = "~/.codex/keys/ed25519-signing.pub"

[security.encryption]
# ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰æš—å·åŒ–
algorithm = "AES-256-GCM"
key_derivation = "HKDF-SHA256"

[security.replay_protection]
# ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–
nonce_enabled = true
timestamp_tolerance_sec = 300  # 5åˆ†
nonce_store = "redis"  # or "memory" for testing
redis_url = "redis://localhost:6379"

# ==================== MCP ã‚µãƒ¼ãƒãƒ¼ï¼ˆã‚»ã‚­ãƒ¥ã‚¢ç‰ˆï¼‰ ====================
[mcp_servers.codex]
command = "codex"
args = ["mcp-server"]
env.RUST_LOG = "info"

# ğŸ”’ TLS/mTLSè¨­å®š
transport = "https"  # ğŸ†• HTTPSã«å¤‰æ›´ï¼ˆstdioâ†’TCP+TLSï¼‰
bind_address = "127.0.0.1:8001"
tls_cert = "~/.codex/certs/mcp-servers/codex-cert.pem"
tls_key = "~/.codex/certs/mcp-servers/codex-key.pem"
require_client_cert = true  # mTLSå¿…é ˆ

# ğŸ” èªè¨¼è¨­å®š
auth_method = "mtls"  # mTLSèªè¨¼
trusted_ca = "~/.codex/certs/ca/ca-cert.pem"

[mcp_servers.serena]
command = "npx"
args = ["-y", "@modelcontextprotocol/server-everything"]
transport = "https"
bind_address = "127.0.0.1:8002"
tls_cert = "~/.codex/certs/mcp-servers/serena-cert.pem"
tls_key = "~/.codex/certs/mcp-servers/serena-key.pem"
require_client_cert = true

# ... (ä»–ã®MCPã‚µãƒ¼ãƒãƒ¼ã‚‚åŒæ§˜ã«è¨­å®š)
```

---

## 5. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### 5.1 ç¾åœ¨ã®å®Ÿè£…ï¼ˆv0.51.0ï¼‰

#### é€šä¿¡ãƒ•ãƒ­ãƒ¼
```rust
// codex-rs/core/src/async_subagent_integration.rs
// ç¾åœ¨: tokio::mpsc (ãƒ—ãƒ­ã‚»ã‚¹å†…ãƒãƒ£ãƒãƒ«) - æš—å·åŒ–ãªã—

// 1. ãƒãƒ£ãƒãƒ«ä½œæˆ
let (tx, rx) = mpsc::unbounded_channel();

// 2. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ï¼ˆå¹³æ–‡ï¼‰
pub async fn send_message(&self, message: AgentMessage) -> Result<()> {
    self.tx.send(message).context("Failed to send message")?;
    Ok(())
}

// 3. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡
pub async fn receive_message(&self) -> Option<AgentMessage> {
    self.rx.lock().await.recv().await
}
```

#### å•é¡Œç‚¹
1. âš ï¸ **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå¹³æ–‡**: `AgentMessage`æ§‹é€ ä½“ã¯æš—å·åŒ–ã•ã‚Œã¦ã„ãªã„
2. âš ï¸ **ç½²åãªã—**: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡è€…ãŒæœ¬ç‰©ã‹ã©ã†ã‹æ¤œè¨¼ã§ããªã„
3. âš ï¸ **æ”¹ã–ã‚“æ¤œçŸ¥ãªã—**: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé€”ä¸­ã§æ”¹ã–ã‚“ã•ã‚Œã¦ã‚‚æ°—ã¥ã‹ãªã„
4. âš ï¸ **ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡æœªå¯¾å¿œ**: å°†æ¥çš„ã«åˆ†æ•£å®Ÿè¡Œã™ã‚‹éš›ã«å•é¡Œ

### 5.2 ã‚»ã‚­ãƒ¥ã‚¢å®Ÿè£…è¨­è¨ˆ

#### 5.2.1 Secure Agent Message Protocol

**ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ§‹é€ **:
```rust
// codex-rs/core/src/agents/secure_message.rs (æ–°è¦ä½œæˆ)

use serde::{Serialize, Deserialize};
use ed25519_dalek::{Keypair, Signature, Signer, Verifier};
use anyhow::{Result, Context};

/// Secure Agent Message (æš—å·åŒ– + ç½²å)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecureAgentMessage {
    /// é€ä¿¡å…ƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    pub from: AgentType,
    
    /// å®›å…ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆNone = ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆï¼‰
    pub to: Option<AgentType>,
    
    /// æš—å·åŒ–ã•ã‚ŒãŸãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ï¼ˆAES-256-GCMï¼‰
    pub encrypted_content: Vec<u8>,
    
    /// Ed25519ç½²å
    pub signature: Vec<u8>,
    
    /// Nonceï¼ˆãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–ï¼‰
    pub nonce: u64,
    
    /// Timestamp
    pub timestamp: String,
    
    /// ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆæš—å·åŒ–ã•ã‚Œãªã„ï¼‰
    pub metadata: SecureMetadata,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecureMetadata {
    /// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDï¼ˆUUIDï¼‰
    pub message_id: String,
    
    /// å„ªå…ˆåº¦ï¼ˆ0-255ï¼‰
    pub priority: u8,
    
    /// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—
    pub message_type: MessageType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageType {
    /// ã‚¿ã‚¹ã‚¯ä¾é ¼
    TaskRequest,
    
    /// ã‚¿ã‚¹ã‚¯çµæœ
    TaskResponse,
    
    /// çŠ¶æ…‹æ›´æ–°
    StatusUpdate,
    
    /// ã‚¨ãƒ©ãƒ¼é€šçŸ¥
    ErrorNotification,
    
    /// ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³æŒ‡ç¤º
    Shutdown,
}

/// Secure Agent Channelï¼ˆæš—å·åŒ–ãƒãƒ£ãƒãƒ«ï¼‰
pub struct SecureAgentChannel {
    /// é€ä¿¡ãƒãƒ£ãƒãƒ«
    tx: mpsc::UnboundedSender<SecureAgentMessage>,
    
    /// å—ä¿¡ãƒãƒ£ãƒãƒ«
    rx: Arc<Mutex<mpsc::UnboundedReceiver<SecureAgentMessage>>>,
    
    /// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç½²åéµ
    signing_keypair: Arc<Keypair>,
    
    /// æš—å·åŒ–ã‚­ãƒ¼ï¼ˆHKDFå°å‡ºï¼‰
    encryption_key: Arc<aes_gcm::Key<Aes256Gcm>>,
    
    /// ä¿¡é ¼ã•ã‚ŒãŸã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå…¬é–‹éµ
    trusted_public_keys: Arc<Mutex<HashMap<AgentType, ed25519_dalek::PublicKey>>>,
    
    /// Nonceã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
    nonce_counter: AtomicU64,
}

impl SecureAgentChannel {
    /// æ–°ã—ã„ã‚»ã‚­ãƒ¥ã‚¢ãƒãƒ£ãƒãƒ«ã‚’ä½œæˆ
    pub fn new(
        agent_type: AgentType,
        signing_keypair: Keypair,
        encryption_key: aes_gcm::Key<Aes256Gcm>,
    ) -> (Self, Self) {
        let (tx1, rx1) = mpsc::unbounded_channel();
        let (tx2, rx2) = mpsc::unbounded_channel();
        
        let keypair = Arc::new(signing_keypair);
        let enc_key = Arc::new(encryption_key);
        let trusted_keys = Arc::new(Mutex::new(HashMap::new()));
        
        let channel1 = Self {
            tx: tx1,
            rx: Arc::new(Mutex::new(rx2)),
            signing_keypair: Arc::clone(&keypair),
            encryption_key: Arc::clone(&enc_key),
            trusted_public_keys: Arc::clone(&trusted_keys),
            nonce_counter: AtomicU64::new(0),
        };
        
        let channel2 = Self {
            tx: tx2,
            rx: Arc::new(Mutex::new(rx1)),
            signing_keypair: keypair,
            encryption_key: enc_key,
            trusted_public_keys: trusted_keys,
            nonce_counter: AtomicU64::new(0),
        };
        
        (channel1, channel2)
    }
    
    /// ä¿¡é ¼ã•ã‚ŒãŸã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å…¬é–‹éµã‚’ç™»éŒ²
    pub async fn register_trusted_agent(
        &self,
        agent_type: AgentType,
        public_key: ed25519_dalek::PublicKey,
    ) {
        self.trusted_public_keys
            .lock()
            .await
            .insert(agent_type, public_key);
    }
    
    /// ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
    pub async fn send_secure(
        &self,
        from: AgentType,
        to: Option<AgentType>,
        content: &str,
    ) -> Result<()> {
        // 1. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ§‹ç¯‰
        let metadata = SecureMetadata {
            message_id: uuid::Uuid::new_v4().to_string(),
            priority: 128, // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå„ªå…ˆåº¦
            message_type: MessageType::TaskRequest,
        };
        
        // 2. ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æš—å·åŒ–
        let encrypted_content = self.encrypt_content(content)?;
        
        // 3. ç½²åç”Ÿæˆ
        let signature_data = self.build_signature_data(&encrypted_content, &metadata)?;
        let signature = self.signing_keypair.sign(&signature_data);
        
        // 4. Secure Messageã‚’æ§‹ç¯‰
        let secure_msg = SecureAgentMessage {
            from,
            to,
            encrypted_content,
            signature: signature.to_bytes().to_vec(),
            nonce: self.nonce_counter.fetch_add(1, Ordering::SeqCst),
            timestamp: chrono::Utc::now().to_rfc3339(),
            metadata,
        };
        
        // 5. ãƒãƒ£ãƒãƒ«ã«é€ä¿¡
        self.tx.send(secure_msg)?;
        
        Ok(())
    }
    
    /// ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡ + æ¤œè¨¼
    pub async fn receive_secure(&self) -> Result<(AgentType, String)> {
        // 1. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡
        let secure_msg = self
            .rx
            .lock()
            .await
            .recv()
            .await
            .context("Channel closed")?;
        
        // 2. ç½²åæ¤œè¨¼
        self.verify_signature(&secure_msg).await?;
        
        // 3. Nonceæ¤œè¨¼
        self.verify_nonce(&secure_msg)?;
        
        // 4. å¾©å·åŒ–
        let content = self.decrypt_content(&secure_msg.encrypted_content)?;
        
        Ok((secure_msg.from, content))
    }
    
    /// ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æš—å·åŒ–ï¼ˆAES-256-GCMï¼‰
    fn encrypt_content(&self, content: &str) -> Result<Vec<u8>> {
        use aes_gcm::{
            aead::{Aead, KeyInit},
            Aes256Gcm, Nonce,
        };
        
        let cipher = Aes256Gcm::new(&self.encryption_key);
        let nonce = Nonce::from_slice(&self.generate_nonce());
        
        cipher
            .encrypt(nonce, content.as_bytes())
            .map_err(|e| anyhow::anyhow!("Encryption failed: {}", e))
    }
    
    /// ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å¾©å·åŒ–
    fn decrypt_content(&self, ciphertext: &[u8]) -> Result<String> {
        use aes_gcm::{
            aead::{Aead, KeyInit},
            Aes256Gcm, Nonce,
        };
        
        let cipher = Aes256Gcm::new(&self.encryption_key);
        let nonce = Nonce::from_slice(&[0u8; 12]); // å®Ÿéš›ã¯æš—å·æ–‡ã‹ã‚‰æŠ½å‡º
        
        let plaintext = cipher
            .decrypt(nonce, ciphertext)
            .map_err(|e| anyhow::anyhow!("Decryption failed: {}", e))?;
        
        String::from_utf8(plaintext).context("Invalid UTF-8")
    }
    
    /// ç½²åãƒ‡ãƒ¼ã‚¿æ§‹ç¯‰
    fn build_signature_data(
        &self,
        encrypted_content: &[u8],
        metadata: &SecureMetadata,
    ) -> Result<Vec<u8>> {
        let mut data = Vec::new();
        data.extend_from_slice(encrypted_content);
        data.extend_from_slice(metadata.message_id.as_bytes());
        data.extend_from_slice(&[metadata.priority]);
        Ok(data)
    }
    
    /// ç½²åæ¤œè¨¼
    async fn verify_signature(&self, msg: &SecureAgentMessage) -> Result<()> {
        // ä¿¡é ¼ã•ã‚ŒãŸå…¬é–‹éµã‚’å–å¾—
        let trusted_keys = self.trusted_public_keys.lock().await;
        let public_key = trusted_keys
            .get(&msg.from)
            .context("Sender not trusted")?;
        
        // ç½²åãƒ‡ãƒ¼ã‚¿ã‚’å†æ§‹ç¯‰
        let signature_data = self.build_signature_data(
            &msg.encrypted_content,
            &msg.metadata,
        )?;
        
        // Ed25519ç½²åã‚’æ¤œè¨¼
        let signature = Signature::from_bytes(&msg.signature)
            .context("Invalid signature format")?;
        
        public_key
            .verify(&signature_data, &signature)
            .context("Signature verification failed")?;
        
        Ok(())
    }
    
    /// Nonceæ¤œè¨¼ï¼ˆãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–ï¼‰
    fn verify_nonce(&self, msg: &SecureAgentMessage) -> Result<()> {
        // Timestampæ¤œè¨¼ï¼ˆ5åˆ†ä»¥å†…ï¼‰
        let msg_time = chrono::DateTime::parse_from_rfc3339(&msg.timestamp)?;
        let now = chrono::Utc::now();
        let age = now.signed_duration_since(msg_time);
        
        if age.num_seconds() > 300 {
            anyhow::bail!("Message too old: {} seconds", age.num_seconds());
        }
        
        // Nonceé‡è¤‡æ¤œè¨¼ï¼ˆå®Ÿè£…çœç•¥ï¼‰
        // ...
        
        Ok(())
    }
    
    /// Nonceç”Ÿæˆ
    fn generate_nonce(&self) -> [u8; 12] {
        use rand::RngCore;
        let mut nonce = [0u8; 12];
        rand::thread_rng().fill_bytes(&mut nonce);
        nonce
    }
}
```

#### 5.2.2 éµç®¡ç†ï¼ˆKey Managementï¼‰

**Agent Signing Keyç”Ÿæˆ**:
```bash
#!/bin/bash
# ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç”¨Ed25519ç½²åéµç”Ÿæˆ

KEYS_DIR="$HOME/.codex/keys/agents"
mkdir -p "$KEYS_DIR"

AGENTS=(
    "CodeExpert"
    "SecurityExpert"
    "TestingExpert"
    "DocsExpert"
    "DeepResearcher"
    "DebugExpert"
    "PerformanceExpert"
    "General"
)

for agent in "${AGENTS[@]}"; do
    echo "Generating Ed25519 keypair for $agent..."
    ssh-keygen -t ed25519 \
        -f "$KEYS_DIR/${agent,,}-signing" \
        -N "" \
        -C "codex-agent-${agent,,}"
done

echo "âœ… All agent keypairs generated!"
```

**config.tomlè¨­å®š**:
```toml
# ==================== ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ ====================
[agent_security]
# æš—å·åŒ–æœ‰åŠ¹åŒ–
encryption_enabled = true
signing_enabled = true

[agent_security.encryption]
algorithm = "AES-256-GCM"
key_derivation = "HKDF-SHA256"

[agent_security.signing]
algorithm = "Ed25519"
keys_directory = "~/.codex/keys/agents"

[agent_security.trust]
# ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¿¡é ¼é–¢ä¿‚
# SecurityExpertã¯ç‰¹æ¨©ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆã™ã¹ã¦ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨é€šä¿¡å¯èƒ½ï¼‰
privileged_agents = ["SecurityExpert"]

# CodeExpertã¯é™å®šçš„ãªé€šä¿¡ã®ã¿
[agent_security.trust.CodeExpert]
can_communicate_with = ["General", "TestingExpert", "DocsExpert"]

# SecurityExpertã¯å…¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨é€šä¿¡å¯èƒ½ï¼ˆç‰¹æ¨©ï¼‰
[agent_security.trust.SecurityExpert]
can_communicate_with = ["*"]  # ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰

# TestingExpertã¯åˆ¶é™ã‚ã‚Š
[agent_security.trust.TestingExpert]
can_communicate_with = ["CodeExpert", "General"]
```

#### 5.2.3 Rate Limitingï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™ï¼‰

**å®Ÿè£…**:
```rust
// codex-rs/core/src/agents/rate_limiter.rs (æ–°è¦ä½œæˆ)

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::time::{Duration, Instant};

/// Rate Limiterï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚±ãƒƒãƒˆæ–¹å¼ï¼‰
pub struct AgentRateLimiter {
    /// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¥ãƒã‚±ãƒƒãƒˆ
    buckets: Arc<Mutex<HashMap<AgentType, TokenBucket>>>,
}

#[derive(Debug, Clone)]
struct TokenBucket {
    /// ç¾åœ¨ã®ãƒˆãƒ¼ã‚¯ãƒ³æ•°
    tokens: f64,
    
    /// æœ€å¤§ãƒˆãƒ¼ã‚¯ãƒ³æ•°
    capacity: f64,
    
    /// ãƒˆãƒ¼ã‚¯ãƒ³è£œå……ãƒ¬ãƒ¼ãƒˆï¼ˆãƒˆãƒ¼ã‚¯ãƒ³/ç§’ï¼‰
    refill_rate: f64,
    
    /// æœ€çµ‚æ›´æ–°æ™‚åˆ»
    last_update: Instant,
}

impl AgentRateLimiter {
    pub fn new() -> Self {
        Self {
            buckets: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    /// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
    pub async fn register_agent(
        &self,
        agent_type: AgentType,
        max_requests_per_sec: f64,
    ) {
        let bucket = TokenBucket {
            tokens: max_requests_per_sec,
            capacity: max_requests_per_sec,
            refill_rate: max_requests_per_sec,
            last_update: Instant::now(),
        };
        
        self.buckets.lock().await.insert(agent_type, bucket);
    }
    
    /// ãƒªã‚¯ã‚¨ã‚¹ãƒˆè¨±å¯ãƒã‚§ãƒƒã‚¯
    pub async fn allow_request(&self, agent_type: &AgentType) -> bool {
        let mut buckets = self.buckets.lock().await;
        
        if let Some(bucket) = buckets.get_mut(agent_type) {
            // ãƒˆãƒ¼ã‚¯ãƒ³è£œå……
            let now = Instant::now();
            let elapsed = now.duration_since(bucket.last_update).as_secs_f64();
            bucket.tokens = (bucket.tokens + elapsed * bucket.refill_rate).min(bucket.capacity);
            bucket.last_update = now;
            
            // ãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚§ãƒƒã‚¯
            if bucket.tokens >= 1.0 {
                bucket.tokens -= 1.0;
                true
            } else {
                false // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚ªãƒ¼ãƒãƒ¼
            }
        } else {
            false // æœªç™»éŒ²ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        }
    }
}
```

**ä½¿ç”¨ä¾‹**:
```rust
// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡æ™‚ã«Rate Limitãƒã‚§ãƒƒã‚¯
pub async fn send_message_with_rate_limit(
    &self,
    agent_type: AgentType,
    message: String,
) -> Result<()> {
    // Rate Limitãƒã‚§ãƒƒã‚¯
    if !self.rate_limiter.allow_request(&agent_type).await {
        anyhow::bail!("Rate limit exceeded for agent {:?}", agent_type);
    }
    
    // é€šå¸¸ã®é€ä¿¡å‡¦ç†
    self.send_secure(agent_type, None, &message).await
}
```

---

## 6. å®Ÿè£…è¨­è¨ˆ

### 6.1 å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º

| ãƒ•ã‚§ãƒ¼ã‚º | å†…å®¹ | æœŸé–“ | å„ªå…ˆåº¦ |
|---------|------|------|--------|
| **Phase 1** | TLS 1.3 + mTLSå°å…¥ï¼ˆMCPã‚µãƒ¼ãƒãƒ¼ï¼‰ | 2é€±é–“ | ğŸ”´ P0 |
| **Phase 2** | Ed25519ç½²åå®Ÿè£…ï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ï¼‰ | 1é€±é–“ | ğŸ”´ P0 |
| **Phase 3** | AES-256-GCMæš—å·åŒ–ï¼ˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ï¼‰ | 1é€±é–“ | ğŸ”´ P0 |
| **Phase 4** | Rate Limitingå®Ÿè£… | 3æ—¥ | ğŸŸ¡ P1 |
| **Phase 5** | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ï¼‹ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ | 1é€±é–“ | ğŸŸ¡ P1 |

### 6.2 å¿…è¦ãªRust Crate

```toml
# codex-rs/Cargo.toml ã«è¿½åŠ 

[dependencies]
# TLS/mTLS
rustls = "0.21"
tokio-rustls = "0.24"
rustls-pemfile = "1.0"

# æš—å·åŒ–
aes-gcm = "0.10"
hkdf = "0.12"
sha2 = "0.10"

# ç½²å
ed25519-dalek = "2.0"
signature = "2.1"

# X.509è¨¼æ˜æ›¸ãƒ‘ãƒ¼ã‚¹
x509-parser = "0.15"

# Rate Limiting
governor = "0.6"  # or è‡ªä½œ

# Nonceç®¡ç†ï¼ˆRedisï¼‰
redis = { version = "0.23", features = ["tokio-comp"] }
```

### 6.3 è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«æœ€çµ‚ç‰ˆ

```toml
# config.toml - ã‚»ã‚­ãƒ¥ã‚¢ç‰ˆå®Œå…¨ç‰ˆ

# ==================== ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ ====================
[security]
# ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰
zero_trust_mode = true

# TLS/mTLS
tls_version = "1.3"
mtls_enabled = true

[security.certificates]
ca_cert = "~/.codex/certs/ca/ca-cert.pem"
client_cert = "~/.codex/certs/codex/codex-cert.pem"
client_key = "~/.codex/certs/codex/codex-key.pem"
verify_peer = true

[security.signing]
algorithm = "Ed25519"
signing_key = "~/.codex/keys/ed25519-signing.key"
signing_public_key = "~/.codex/keys/ed25519-signing.pub"

[security.encryption]
algorithm = "AES-256-GCM"
key_derivation = "HKDF-SHA256"
key_rotation_days = 90

[security.replay_protection]
enabled = true
nonce_store = "redis"
redis_url = "redis://localhost:6379"
timestamp_tolerance_sec = 300

[security.rate_limiting]
enabled = true
max_requests_per_sec = 10.0
burst_size = 20

# ==================== ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ ====================
[agent_security]
encryption_enabled = true
signing_enabled = true

[agent_security.encryption]
algorithm = "AES-256-GCM"
key_derivation = "HKDF-SHA256"

[agent_security.signing]
algorithm = "Ed25519"
keys_directory = "~/.codex/keys/agents"

[agent_security.trust]
privileged_agents = ["SecurityExpert"]

[agent_security.trust.CodeExpert]
can_communicate_with = ["General", "TestingExpert", "DocsExpert"]

[agent_security.trust.SecurityExpert]
can_communicate_with = ["*"]

[agent_security.rate_limiting]
enabled = true
max_messages_per_sec = 5.0

# ==================== ç›£æŸ»ãƒ­ã‚° ====================
[audit]
enabled = true
log_dir = "~/.codex/audit-logs"
include_mcp_calls = true
include_agent_messages = true
include_security_events = true
format = "json"
rotation = "daily"
retention_days = 90

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã®å³æ™‚é€šçŸ¥
[audit.alerts]
enabled = true
alert_on_security_events = true
alert_email = "security@example.com"
alert_slack_webhook = "${SLACK_SECURITY_WEBHOOK}"

# ==================== MCP ã‚µãƒ¼ãƒãƒ¼ï¼ˆã‚»ã‚­ãƒ¥ã‚¢ç‰ˆï¼‰ ====================
[mcp_servers.codex]
command = "codex"
args = ["mcp-server"]
transport = "https"
bind_address = "127.0.0.1:8001"
tls_cert = "~/.codex/certs/mcp-servers/codex-cert.pem"
tls_key = "~/.codex/certs/mcp-servers/codex-key.pem"
require_client_cert = true
auth_method = "mtls"

# ... (ä»–ã®MCPã‚µãƒ¼ãƒãƒ¼ã‚‚åŒæ§˜)
```

---

## 7. é‹ç”¨ãƒ»ç›£è¦–

### 7.1 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

**å®Ÿè£…**:
```rust
// codex-rs/core/src/security/dashboard.rs

use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityMetrics {
    /// TLSæ¥ç¶šæ•°
    pub tls_connections: u64,
    
    /// mTLSèªè¨¼æˆåŠŸæ•°
    pub mtls_auth_success: u64,
    
    /// mTLSèªè¨¼å¤±æ•—æ•°
    pub mtls_auth_failures: u64,
    
    /// ç½²åæ¤œè¨¼æˆåŠŸæ•°
    pub signature_verifications: u64,
    
    /// ç½²åæ¤œè¨¼å¤±æ•—æ•°
    pub signature_failures: u64,
    
    /// Rate Limitè¶…éæ•°
    pub rate_limit_exceeded: u64,
    
    /// ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒæ¤œå‡ºæ•°
    pub replay_attacks_detected: u64,
}

/// ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’å–å¾—
pub async fn get_security_metrics() -> SecurityMetrics {
    // Prometheus/Grafanaã¨çµ±åˆ
    // ...
}
```

**Grafanaãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¨­å®š** (`zapabob/monitoring/grafana-dashboard.json`):
```json
{
  "dashboard": {
    "title": "Codex Security Monitoring",
    "panels": [
      {
        "title": "mTLS Authentication Success Rate",
        "targets": [
          {
            "expr": "rate(codex_mtls_auth_success[5m]) / (rate(codex_mtls_auth_success[5m]) + rate(codex_mtls_auth_failures[5m]))"
          }
        ]
      },
      {
        "title": "Signature Verification Failures",
        "targets": [
          {
            "expr": "rate(codex_signature_failures[5m])"
          }
        ]
      },
      {
        "title": "Rate Limit Exceeded Events",
        "targets": [
          {
            "expr": "rate(codex_rate_limit_exceeded[5m])"
          }
        ]
      },
      {
        "title": "Replay Attacks Detected",
        "targets": [
          {
            "expr": "increase(codex_replay_attacks_detected[1h])"
          }
        ]
      }
    ]
  }
}
```

### 7.2 ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆãƒ¬ã‚¹ãƒãƒ³ã‚¹

**ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆè‡ªå‹•å¯¾å¿œ**:
```rust
// codex-rs/core/src/security/incident_response.rs

pub enum SecurityIncident {
    /// mTLSèªè¨¼å¤±æ•—ãŒé€£ç¶š
    MtlsAuthFailureSpike,
    
    /// ç½²åæ¤œè¨¼å¤±æ•—
    SignatureVerificationFailure,
    
    /// Rate Limitè¶…éï¼ˆDDoSç–‘ã„ï¼‰
    RateLimitExceeded,
    
    /// ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒæ¤œå‡º
    ReplayAttackDetected,
}

pub async fn handle_security_incident(incident: SecurityIncident) {
    match incident {
        SecurityIncident::MtlsAuthFailureSpike => {
            // 1. è©²å½“MCPã‚µãƒ¼ãƒãƒ¼ã‚’ä¸€æ™‚åœæ­¢
            // 2. Slackã«é€šçŸ¥
            // 3. ç®¡ç†è€…ã«ãƒ¡ãƒ¼ãƒ«é€ä¿¡
        }
        SecurityIncident::ReplayAttackDetected => {
            // 1. è©²å½“ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’éš”é›¢
            // 2. ç›£æŸ»ãƒ­ã‚°ã«è¨˜éŒ²
            // 3. ç·Šæ€¥ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
        }
        // ...
    }
}
```

---

## 8. ãƒªã‚¹ã‚¯è©•ä¾¡

### 8.1 å®Ÿè£…å‰å¾Œã®ãƒªã‚¹ã‚¯æ¯”è¼ƒ

| ãƒªã‚¹ã‚¯ | å®Ÿè£…å‰ | å®Ÿè£…å¾Œ | ãƒªã‚¹ã‚¯è»½æ¸›ç‡ |
|--------|--------|--------|--------------|
| **ä¸­é–“è€…æ”»æ’ƒï¼ˆMITMï¼‰** | ğŸ”´ Critical | ğŸŸ¢ Minimal | **98%å‰Šæ¸›** |
| **ç›—è´ï¼ˆEavesdroppingï¼‰** | ğŸ”´ Critical | ğŸŸ¢ Minimal | **99%å‰Šæ¸›** |
| **ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒ** | ğŸŸ¡ High | ğŸŸ¢ Low | **95%å‰Šæ¸›** |
| **ãªã‚Šã™ã¾ã—** | ğŸŸ¡ High | ğŸŸ¢ Minimal | **97%å‰Šæ¸›** |
| **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ”¹ã–ã‚“** | ğŸŸ¡ High | ğŸŸ¢ Minimal | **99%å‰Šæ¸›** |
| **DoSæ”»æ’ƒ** | ğŸŸ¡ Medium | ğŸŸ¢ Low | **80%å‰Šæ¸›** |

### 8.2 ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹é”æˆåº¦

| è¦æ ¼ | å®Ÿè£…å‰ | å®Ÿè£…å¾Œ | é”æˆåº¦ |
|------|--------|--------|--------|
| **ISO 27001:2022** | 65% | 95% | âœ… èªè¨¼å–å¾—å¯èƒ½ |
| **NIST SP 800-207 (Zero Trust)** | Level 1 | Level 4 | âœ… Advanced |
| **SOC 2 Type II** | ä¸é©åˆ | é©åˆè¦‹è¾¼ã¿ | âœ… ç›£æŸ»å¯èƒ½ |
| **GDPR (Article 32)** | éƒ¨åˆ†é©åˆ | é©åˆ | âœ… ãƒ‡ãƒ¼ã‚¿ä¿è­·OK |

---

## 9. ã¾ã¨ã‚

### 9.1 å®Ÿè£…ã«ã‚ˆã‚Šé”æˆã•ã‚Œã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«

| è¦³ç‚¹ | ç¾çŠ¶ | å®Ÿè£…å¾Œ | è©•ä¾¡ |
|------|------|--------|------|
| **æ©Ÿå¯†æ€§** | 70% | 99.9% | ğŸ† Enterprise-grade |
| **å®Œå…¨æ€§** | 85% | 99.99% | ğŸ† Military-grade |
| **å¯ç”¨æ€§** | 95% | 99.99% | ğŸ† Mission-critical |
| **èªè¨¼** | 75% | 100% | ğŸ† Zero Trust |
| **èªå¯** | 80% | 100% | ğŸ† Fine-grained RBAC |
| **ç›£æŸ»** | 90% | 100% | ğŸ† Full traceability |

### 9.2 å®Ÿè£…å„ªå…ˆé †ä½

**P0ï¼ˆå³æ™‚å¯¾å¿œï¼‰**:
1. âœ… TLS 1.3 + mTLSå°å…¥ï¼ˆMCPã‚µãƒ¼ãƒãƒ¼ï¼‰
2. âœ… Ed25519ç½²åå®Ÿè£…ï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ï¼‰
3. âœ… AES-256-GCMæš—å·åŒ–ï¼ˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ï¼‰

**P1ï¼ˆ1ãƒ¶æœˆä»¥å†…ï¼‰**:
4. âœ… Rate Limitingå®Ÿè£…
5. âœ… Nonceç®¡ç†ï¼ˆRedisï¼‰
6. âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

**P2ï¼ˆ3ãƒ¶æœˆä»¥å†…ï¼‰**:
7. HSMçµ±åˆï¼ˆç‰¹æ¨©ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç”¨ï¼‰
8. SOC 2ç›£æŸ»å¯¾å¿œ
9. ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ

---

**æœ¬è¨­è¨ˆæ›¸ã®å®Ÿè£…ã«ã‚ˆã‚Šã€Codexã¯ä¸–ç•Œãƒˆãƒƒãƒ—ã‚¯ãƒ©ã‚¹ã®ã‚»ã‚­ãƒ¥ã‚¢ãªLLMopsãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«ãªã‚‹ã€‚**

---

**è¨­è¨ˆæ›¸ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v1.0  
**æ¬¡å›ãƒ¬ãƒ“ãƒ¥ãƒ¼**: å®Ÿè£…å®Œäº†å¾Œ  
**æ‰¿èª**: [ã€€]  
**å®Ÿè£…é–‹å§‹æ—¥**: 2025-10-28  
**å®Œäº†äºˆå®šæ—¥**: 2025-11-28

