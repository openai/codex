// @generated
// DO NOT EDIT THIS FILE DIRECTLY.
// Run the following in the crate root to regenerate this file:
//
// ```shell
// ./generate_mcp_types.py
// ```
use serde::Deserialize;
use serde::Serialize;
use serde::de::DeserializeOwned;
use std::convert::TryFrom;

use schemars::JsonSchema;
use ts_rs::TS;

pub const MCP_SCHEMA_VERSION: &str = "2025-11-25";
pub const JSONRPC_VERSION: &str = "2.0";

/// Paired request/response types for the Model Context Protocol (MCP).
pub trait ModelContextProtocolRequest {
    const METHOD: &'static str;
    type Params: DeserializeOwned + Serialize + Send + Sync + 'static;
    type Result: DeserializeOwned + Serialize + Send + Sync + 'static;
}

/// One-way message in the Model Context Protocol (MCP).
pub trait ModelContextProtocolNotification {
    const METHOD: &'static str;
    type Params: DeserializeOwned + Serialize + Send + Sync + 'static;
}

fn default_jsonrpc() -> String {
    JSONRPC_VERSION.to_owned()
}

/// Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Annotations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub audience: Option<Vec<Role>>,
    #[serde(
        rename = "lastModified",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub last_modified: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub priority: Option<f64>,
}

/// Audio provided to or from an LLM.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct AudioContent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub annotations: Option<Annotations>,
    pub data: String,
    #[serde(rename = "mimeType")]
    pub mime_type: String,
    pub r#type: String, // &'static str = "audio"
}

/// Base interface for metadata with name (identifier) and title (display name) properties.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct BaseMetadata {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct BlobResourceContents {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub blob: String,
    #[serde(rename = "mimeType", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mime_type: Option<String>,
    pub uri: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct BooleanSchema {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub default: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "boolean"
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum CallToolRequest {}

impl ModelContextProtocolRequest for CallToolRequest {
    const METHOD: &'static str = "tools/call";
    type Params = CallToolRequestParams;
    type Result = CallToolResult;
}

/// Parameters for a `tools/call` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CallToolRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub arguments: Option<serde_json::Value>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub task: Option<TaskMetadata>,
}

/// The server's response to a tool call.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CallToolResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub content: Vec<ContentBlock>,
    #[serde(rename = "isError", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub is_error: Option<bool>,
    #[serde(
        rename = "structuredContent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub structured_content: Option<serde_json::Value>,
}

impl From<CallToolResult> for serde_json::Value {
    fn from(value: CallToolResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum CancelTaskRequest {}

impl ModelContextProtocolRequest for CancelTaskRequest {
    const METHOD: &'static str = "tasks/cancel";
    type Params = CancelTaskRequestParams;
    type Result = CancelTaskResult;
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CancelTaskRequestParams {
    #[serde(rename = "taskId")]
    pub task_id: String,
}

/// The response to a tasks/cancel request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CancelTaskResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "lastUpdatedAt")]
    pub last_updated_at: String,
    #[serde(
        rename = "pollInterval",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub poll_interval: Option<i64>,
    pub status: TaskStatus,
    #[serde(
        rename = "statusMessage",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub status_message: Option<String>,
    #[serde(rename = "taskId")]
    pub task_id: String,
    pub ttl: i64,
}

impl From<CancelTaskResult> for serde_json::Value {
    fn from(value: CancelTaskResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum CancelledNotification {}

impl ModelContextProtocolNotification for CancelledNotification {
    const METHOD: &'static str = "notifications/cancelled";
    type Params = CancelledNotificationParams;
}

/// Parameters for a `notifications/cancelled` notification.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CancelledNotificationParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub reason: Option<String>,
    #[serde(rename = "requestId", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub request_id: Option<RequestId>,
}

/// Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ClientCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub elicitation: Option<ClientCapabilitiesElicitation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub experimental: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub roots: Option<ClientCapabilitiesRoots>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub sampling: Option<ClientCapabilitiesSampling>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub tasks: Option<ClientCapabilitiesTasks>,
}

/// Present if the client supports task-augmented requests.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ClientCapabilitiesTasks {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub cancel: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub list: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub requests: Option<ClientCapabilitiesTasksRequests>,
}

/// Specifies which request types can be augmented with tasks.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ClientCapabilitiesTasksRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub elicitation: Option<ClientCapabilitiesTasksRequestsElicitation>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub sampling: Option<ClientCapabilitiesTasksRequestsSampling>,
}

/// Task support for sampling-related requests.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ClientCapabilitiesTasksRequestsSampling {
    #[serde(
        rename = "createMessage",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub create_message: Option<serde_json::Value>,
}

/// Task support for elicitation-related requests.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ClientCapabilitiesTasksRequestsElicitation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub create: Option<serde_json::Value>,
}

/// Present if the client supports sampling from an LLM.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ClientCapabilitiesSampling {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub context: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub tools: Option<serde_json::Value>,
}

/// Present if the client supports listing roots.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ClientCapabilitiesRoots {
    #[serde(
        rename = "listChanged",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub list_changed: Option<bool>,
}

/// Present if the client supports elicitation from the server.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ClientCapabilitiesElicitation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub form: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub url: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum ClientNotification {
    CancelledNotification(CancelledNotification),
    InitializedNotification(InitializedNotification),
    ProgressNotification(ProgressNotification),
    TaskStatusNotification(TaskStatusNotification),
    RootsListChangedNotification(RootsListChangedNotification),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(tag = "method", content = "params")]
pub enum ClientRequest {
    #[serde(rename = "initialize")]
    InitializeRequest(<InitializeRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "ping")]
    PingRequest(<PingRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "resources/list")]
    ListResourcesRequest(<ListResourcesRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "resources/templates/list")]
    ListResourceTemplatesRequest(
        <ListResourceTemplatesRequest as ModelContextProtocolRequest>::Params,
    ),
    #[serde(rename = "resources/read")]
    ReadResourceRequest(<ReadResourceRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "resources/subscribe")]
    SubscribeRequest(<SubscribeRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "resources/unsubscribe")]
    UnsubscribeRequest(<UnsubscribeRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "prompts/list")]
    ListPromptsRequest(<ListPromptsRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "prompts/get")]
    GetPromptRequest(<GetPromptRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "tools/list")]
    ListToolsRequest(<ListToolsRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "tools/call")]
    CallToolRequest(<CallToolRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "tasks/get")]
    GetTaskRequest(<GetTaskRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "tasks/result")]
    GetTaskPayloadRequest(<GetTaskPayloadRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "tasks/cancel")]
    CancelTaskRequest(<CancelTaskRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "tasks/list")]
    ListTasksRequest(<ListTasksRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "logging/setLevel")]
    SetLevelRequest(<SetLevelRequest as ModelContextProtocolRequest>::Params),
    #[serde(rename = "completion/complete")]
    CompleteRequest(<CompleteRequest as ModelContextProtocolRequest>::Params),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum ClientResult {
    Result(Result),
    GetTaskResult(GetTaskResult),
    GetTaskPayloadResult(GetTaskPayloadResult),
    CancelTaskResult(CancelTaskResult),
    ListTasksResult(ListTasksResult),
    CreateMessageResult(CreateMessageResult),
    ListRootsResult(ListRootsResult),
    ElicitResult(ElicitResult),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum CompleteRequest {}

impl ModelContextProtocolRequest for CompleteRequest {
    const METHOD: &'static str = "completion/complete";
    type Params = CompleteRequestParams;
    type Result = CompleteResult;
}

/// Parameters for a `completion/complete` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CompleteRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub argument: CompleteRequestParamsArgument,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub context: Option<CompleteRequestParamsContext>,
    pub r#ref: CompleteRequestParamsRef,
}

/// Additional, optional context for completions
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CompleteRequestParamsContext {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub arguments: Option<serde_json::Value>,
}

/// The argument's information
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CompleteRequestParamsArgument {
    pub name: String,
    pub value: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum CompleteRequestParamsRef {
    PromptReference(PromptReference),
    ResourceTemplateReference(ResourceTemplateReference),
}

/// The server's response to a completion/complete request
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CompleteResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub completion: CompleteResultCompletion,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CompleteResultCompletion {
    #[serde(rename = "hasMore", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub has_more: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub total: Option<i64>,
    pub values: Vec<String>,
}

impl From<CompleteResult> for serde_json::Value {
    fn from(value: CompleteResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum ContentBlock {
    TextContent(TextContent),
    ImageContent(ImageContent),
    AudioContent(AudioContent),
    ResourceLink(ResourceLink),
    EmbeddedResource(EmbeddedResource),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum CreateMessageRequest {}

impl ModelContextProtocolRequest for CreateMessageRequest {
    const METHOD: &'static str = "sampling/createMessage";
    type Params = CreateMessageRequestParams;
    type Result = CreateMessageResult;
}

/// Parameters for a `sampling/createMessage` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CreateMessageRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(
        rename = "includeContext",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub include_context: Option<String>,
    #[serde(rename = "maxTokens")]
    pub max_tokens: i64,
    pub messages: Vec<SamplingMessage>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub metadata: Option<serde_json::Value>,
    #[serde(
        rename = "modelPreferences",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub model_preferences: Option<ModelPreferences>,
    #[serde(
        rename = "stopSequences",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub stop_sequences: Option<Vec<String>>,
    #[serde(
        rename = "systemPrompt",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub system_prompt: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub task: Option<TaskMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub temperature: Option<f64>,
    #[serde(
        rename = "toolChoice",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub tool_choice: Option<ToolChoice>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub tools: Option<Vec<Tool>>,
}

/// The client's response to a sampling/createMessage request from the server.
/// The client should inform the user before returning the sampled message, to allow them
/// to inspect the response (human in the loop) and decide whether to allow the server to see it.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CreateMessageResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub content: CreateMessageResultContent,
    pub model: String,
    pub role: Role,
    #[serde(
        rename = "stopReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub stop_reason: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum CreateMessageResultContent {
    TextContent(TextContent),
    ImageContent(ImageContent),
    AudioContent(AudioContent),
    ToolUseContent(ToolUseContent),
    ToolResultContent(ToolResultContent),
    Variant5(Vec<SamplingMessageContentBlock>),
}

impl From<CreateMessageResult> for serde_json::Value {
    fn from(value: CreateMessageResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

/// A response to a task-augmented request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct CreateTaskResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub task: Task,
}

impl From<CreateTaskResult> for serde_json::Value {
    fn from(value: CreateTaskResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Cursor(String);

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ElicitRequest {}

impl ModelContextProtocolRequest for ElicitRequest {
    const METHOD: &'static str = "elicitation/create";
    type Params = ElicitRequestParams;
    type Result = ElicitResult;
}

/// The parameters for a request to elicit non-sensitive information from the user via a form in the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ElicitRequestFormParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub message: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mode: Option<String>,
    #[serde(rename = "requestedSchema")]
    pub requested_schema: ElicitRequestFormParamsRequestedSchema,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub task: Option<TaskMetadata>,
}

/// A restricted subset of JSON Schema.
/// Only top-level properties are allowed, without nesting.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ElicitRequestFormParamsRequestedSchema {
    #[serde(rename = "$schema", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub schema: Option<String>,
    pub properties: serde_json::Value,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub required: Option<Vec<String>>,
    pub r#type: String, // &'static str = "object"
}

/// The parameters for a request to elicit additional information from the user via the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum ElicitRequestParams {
    ElicitRequestURLParams(ElicitRequestURLParams),
    ElicitRequestFormParams(ElicitRequestFormParams),
}

/// The parameters for a request to elicit information from the user via a URL in the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ElicitRequestURLParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(rename = "elicitationId")]
    pub elicitation_id: String,
    pub message: String,
    pub mode: String, // &'static str = "url"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub task: Option<TaskMetadata>,
    pub url: String,
}

/// The client's response to an elicitation request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ElicitResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub action: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub content: Option<serde_json::Value>,
}

impl From<ElicitResult> for serde_json::Value {
    fn from(value: ElicitResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ElicitationCompleteNotification {}

impl ModelContextProtocolNotification for ElicitationCompleteNotification {
    const METHOD: &'static str = "notifications/elicitation/complete";
    type Params = ElicitationCompleteNotificationParams;
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ElicitationCompleteNotificationParams {
    #[serde(rename = "elicitationId")]
    pub elicitation_id: String,
}

/// The contents of a resource, embedded into a prompt or tool call result.
///
/// It is up to the client how best to render embedded resources for the benefit
/// of the LLM and/or the user.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct EmbeddedResource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub annotations: Option<Annotations>,
    pub resource: EmbeddedResourceResource,
    pub r#type: String, // &'static str = "resource"
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum EmbeddedResourceResource {
    TextResourceContents(TextResourceContents),
    BlobResourceContents(BlobResourceContents),
}

pub type EmptyResult = Result;

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum EnumSchema {
    UntitledSingleSelectEnumSchema(UntitledSingleSelectEnumSchema),
    TitledSingleSelectEnumSchema(TitledSingleSelectEnumSchema),
    UntitledMultiSelectEnumSchema(UntitledMultiSelectEnumSchema),
    TitledMultiSelectEnumSchema(TitledMultiSelectEnumSchema),
    LegacyTitledEnumSchema(LegacyTitledEnumSchema),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Error {
    pub code: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub data: Option<serde_json::Value>,
    pub message: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum GetPromptRequest {}

impl ModelContextProtocolRequest for GetPromptRequest {
    const METHOD: &'static str = "prompts/get";
    type Params = GetPromptRequestParams;
    type Result = GetPromptResult;
}

/// Parameters for a `prompts/get` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct GetPromptRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub arguments: Option<serde_json::Value>,
    pub name: String,
}

/// The server's response to a prompts/get request from the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct GetPromptResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    pub messages: Vec<PromptMessage>,
}

impl From<GetPromptResult> for serde_json::Value {
    fn from(value: GetPromptResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum GetTaskPayloadRequest {}

impl ModelContextProtocolRequest for GetTaskPayloadRequest {
    const METHOD: &'static str = "tasks/result";
    type Params = GetTaskPayloadRequestParams;
    type Result = GetTaskPayloadResult;
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct GetTaskPayloadRequestParams {
    #[serde(rename = "taskId")]
    pub task_id: String,
}

/// The response to a tasks/result request.
/// The structure matches the result type of the original request.
/// For example, a tools/call task would return the CallToolResult structure.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct GetTaskPayloadResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
}

impl From<GetTaskPayloadResult> for serde_json::Value {
    fn from(value: GetTaskPayloadResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum GetTaskRequest {}

impl ModelContextProtocolRequest for GetTaskRequest {
    const METHOD: &'static str = "tasks/get";
    type Params = GetTaskRequestParams;
    type Result = GetTaskResult;
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct GetTaskRequestParams {
    #[serde(rename = "taskId")]
    pub task_id: String,
}

/// The response to a tasks/get request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct GetTaskResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "lastUpdatedAt")]
    pub last_updated_at: String,
    #[serde(
        rename = "pollInterval",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub poll_interval: Option<i64>,
    pub status: TaskStatus,
    #[serde(
        rename = "statusMessage",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub status_message: Option<String>,
    #[serde(rename = "taskId")]
    pub task_id: String,
    pub ttl: i64,
}

impl From<GetTaskResult> for serde_json::Value {
    fn from(value: GetTaskResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

/// An optionally-sized icon that can be displayed in a user interface.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Icon {
    #[serde(rename = "mimeType", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mime_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub sizes: Option<Vec<String>>,
    pub src: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub theme: Option<String>,
}

/// Base interface to add `icons` property.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Icons {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub icons: Option<Vec<Icon>>,
}

/// An image provided to or from an LLM.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ImageContent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub annotations: Option<Annotations>,
    pub data: String,
    #[serde(rename = "mimeType")]
    pub mime_type: String,
    pub r#type: String, // &'static str = "image"
}

/// Describes the MCP implementation.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Implementation {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub icons: Option<Vec<Icon>>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub version: String,
    #[serde(
        rename = "websiteUrl",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub website_url: Option<String>,
    // This is an extra field that the Codex MCP server sends as part of InitializeResult.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub user_agent: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum InitializeRequest {}

impl ModelContextProtocolRequest for InitializeRequest {
    const METHOD: &'static str = "initialize";
    type Params = InitializeRequestParams;
    type Result = InitializeResult;
}

/// Parameters for an `initialize` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct InitializeRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub capabilities: ClientCapabilities,
    #[serde(rename = "clientInfo")]
    pub client_info: Implementation,
    #[serde(rename = "protocolVersion")]
    pub protocol_version: String,
}

/// After receiving an initialize request from the client, the server sends this response.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct InitializeResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub capabilities: ServerCapabilities,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub instructions: Option<String>,
    #[serde(rename = "protocolVersion")]
    pub protocol_version: String,
    #[serde(rename = "serverInfo")]
    pub server_info: Implementation,
}

impl From<InitializeResult> for serde_json::Value {
    fn from(value: InitializeResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum InitializedNotification {}

impl ModelContextProtocolNotification for InitializedNotification {
    const METHOD: &'static str = "notifications/initialized";
    type Params = Option<NotificationParams>;
}

/// A response to a request that indicates an error occurred.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct JSONRPCErrorResponse {
    pub error: Error,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub id: Option<RequestId>,
    #[serde(rename = "jsonrpc", default = "default_jsonrpc")]
    pub jsonrpc: String,
}

/// Refers to any valid JSON-RPC object that can be decoded off the wire, or encoded to be sent.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum JSONRPCMessage {
    Request(JSONRPCRequest),
    Notification(JSONRPCNotification),
    ResultResponse(JSONRPCResultResponse),
    ErrorResponse(JSONRPCErrorResponse),
}

/// A notification which does not expect a response.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct JSONRPCNotification {
    #[serde(rename = "jsonrpc", default = "default_jsonrpc")]
    pub jsonrpc: String,
    pub method: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub params: Option<serde_json::Value>,
}

/// A request that expects a response.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct JSONRPCRequest {
    pub id: RequestId,
    #[serde(rename = "jsonrpc", default = "default_jsonrpc")]
    pub jsonrpc: String,
    pub method: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub params: Option<serde_json::Value>,
}

/// A response to a request, containing either the result or error.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum JSONRPCResponse {
    JSONRPCResultResponse(JSONRPCResultResponse),
    JSONRPCErrorResponse(JSONRPCErrorResponse),
}

/// A successful (non-error) response to a request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct JSONRPCResultResponse {
    pub id: RequestId,
    #[serde(rename = "jsonrpc", default = "default_jsonrpc")]
    pub jsonrpc: String,
    pub result: Result,
}

/// Use TitledSingleSelectEnumSchema instead.
/// This interface will be removed in a future version.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct LegacyTitledEnumSchema {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub default: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    pub r#enum: Vec<String>,
    #[serde(rename = "enumNames", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub enum_names: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "string"
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ListPromptsRequest {}

impl ModelContextProtocolRequest for ListPromptsRequest {
    const METHOD: &'static str = "prompts/list";
    type Params = Option<PaginatedRequestParams>;
    type Result = ListPromptsResult;
}

/// The server's response to a prompts/list request from the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ListPromptsResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub next_cursor: Option<String>,
    pub prompts: Vec<Prompt>,
}

impl From<ListPromptsResult> for serde_json::Value {
    fn from(value: ListPromptsResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ListResourceTemplatesRequest {}

impl ModelContextProtocolRequest for ListResourceTemplatesRequest {
    const METHOD: &'static str = "resources/templates/list";
    type Params = Option<PaginatedRequestParams>;
    type Result = ListResourceTemplatesResult;
}

/// The server's response to a resources/templates/list request from the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ListResourceTemplatesResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub next_cursor: Option<String>,
    #[serde(rename = "resourceTemplates")]
    pub resource_templates: Vec<ResourceTemplate>,
}

impl From<ListResourceTemplatesResult> for serde_json::Value {
    fn from(value: ListResourceTemplatesResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ListResourcesRequest {}

impl ModelContextProtocolRequest for ListResourcesRequest {
    const METHOD: &'static str = "resources/list";
    type Params = Option<PaginatedRequestParams>;
    type Result = ListResourcesResult;
}

/// The server's response to a resources/list request from the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ListResourcesResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub next_cursor: Option<String>,
    pub resources: Vec<Resource>,
}

impl From<ListResourcesResult> for serde_json::Value {
    fn from(value: ListResourcesResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ListRootsRequest {}

impl ModelContextProtocolRequest for ListRootsRequest {
    const METHOD: &'static str = "roots/list";
    type Params = Option<RequestParams>;
    type Result = ListRootsResult;
}

/// The client's response to a roots/list request from the server.
/// This result contains an array of Root objects, each representing a root directory
/// or file that the server can operate on.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ListRootsResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub roots: Vec<Root>,
}

impl From<ListRootsResult> for serde_json::Value {
    fn from(value: ListRootsResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ListTasksRequest {}

impl ModelContextProtocolRequest for ListTasksRequest {
    const METHOD: &'static str = "tasks/list";
    type Params = Option<PaginatedRequestParams>;
    type Result = ListTasksResult;
}

/// The response to a tasks/list request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ListTasksResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub next_cursor: Option<String>,
    pub tasks: Vec<Task>,
}

impl From<ListTasksResult> for serde_json::Value {
    fn from(value: ListTasksResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ListToolsRequest {}

impl ModelContextProtocolRequest for ListToolsRequest {
    const METHOD: &'static str = "tools/list";
    type Params = Option<PaginatedRequestParams>;
    type Result = ListToolsResult;
}

/// The server's response to a tools/list request from the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ListToolsResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub next_cursor: Option<String>,
    pub tools: Vec<Tool>,
}

impl From<ListToolsResult> for serde_json::Value {
    fn from(value: ListToolsResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

/// The severity of a log message.
///
/// These map to syslog message severities, as specified in RFC-5424:
/// https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum LoggingLevel {
    #[serde(rename = "alert")]
    Alert,
    #[serde(rename = "critical")]
    Critical,
    #[serde(rename = "debug")]
    Debug,
    #[serde(rename = "emergency")]
    Emergency,
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "notice")]
    Notice,
    #[serde(rename = "warning")]
    Warning,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum LoggingMessageNotification {}

impl ModelContextProtocolNotification for LoggingMessageNotification {
    const METHOD: &'static str = "notifications/message";
    type Params = LoggingMessageNotificationParams;
}

/// Parameters for a `notifications/message` notification.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct LoggingMessageNotificationParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub data: serde_json::Value,
    pub level: LoggingLevel,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub logger: Option<String>,
}

/// Hints to use for model selection.
///
/// Keys not declared here are currently left unspecified by the spec and are up
/// to the client to interpret.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ModelHint {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub name: Option<String>,
}

/// The server's preferences for model selection, requested of the client during sampling.
///
/// Because LLMs can vary along multiple dimensions, choosing the "best" model is
/// rarely straightforward.  Different models excel in different areasâ€”some are
/// faster but less capable, others are more capable but more expensive, and so
/// on. This interface allows servers to express their priorities across multiple
/// dimensions to help clients make an appropriate selection for their use case.
///
/// These preferences are always advisory. The client MAY ignore them. It is also
/// up to the client to decide how to interpret these preferences and how to
/// balance them against other considerations.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ModelPreferences {
    #[serde(
        rename = "costPriority",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub cost_priority: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub hints: Option<Vec<ModelHint>>,
    #[serde(
        rename = "intelligencePriority",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub intelligence_priority: Option<f64>,
    #[serde(
        rename = "speedPriority",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub speed_priority: Option<f64>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum MultiSelectEnumSchema {
    UntitledMultiSelectEnumSchema(UntitledMultiSelectEnumSchema),
    TitledMultiSelectEnumSchema(TitledMultiSelectEnumSchema),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Notification {
    pub method: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub params: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct NotificationParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct NumberSchema {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub default: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub maximum: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub minimum: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct PaginatedRequest {
    pub id: RequestId,
    #[serde(rename = "jsonrpc", default = "default_jsonrpc")]
    pub jsonrpc: String,
    pub method: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub params: Option<PaginatedRequestParams>,
}

/// Common parameters for paginated requests.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct PaginatedRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub cursor: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct PaginatedResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(
        rename = "nextCursor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub next_cursor: Option<String>,
}

impl From<PaginatedResult> for serde_json::Value {
    fn from(value: PaginatedResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum PingRequest {}

impl ModelContextProtocolRequest for PingRequest {
    const METHOD: &'static str = "ping";
    type Params = Option<RequestParams>;
    type Result = Result;
}

/// Restricted schema definitions that only allow primitive types
/// without nested objects or arrays.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum PrimitiveSchemaDefinition {
    StringSchema(StringSchema),
    NumberSchema(NumberSchema),
    BooleanSchema(BooleanSchema),
    UntitledSingleSelectEnumSchema(UntitledSingleSelectEnumSchema),
    TitledSingleSelectEnumSchema(TitledSingleSelectEnumSchema),
    UntitledMultiSelectEnumSchema(UntitledMultiSelectEnumSchema),
    TitledMultiSelectEnumSchema(TitledMultiSelectEnumSchema),
    LegacyTitledEnumSchema(LegacyTitledEnumSchema),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ProgressNotification {}

impl ModelContextProtocolNotification for ProgressNotification {
    const METHOD: &'static str = "notifications/progress";
    type Params = ProgressNotificationParams;
}

/// Parameters for a `notifications/progress` notification.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ProgressNotificationParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub message: Option<String>,
    pub progress: f64,
    #[serde(rename = "progressToken")]
    pub progress_token: ProgressToken,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub total: Option<f64>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, Hash, Eq, JsonSchema, TS)]
#[serde(untagged)]
pub enum ProgressToken {
    String(String),
    Integer(i64),
}

/// A prompt or prompt template that the server offers.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Prompt {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub arguments: Option<Vec<PromptArgument>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub icons: Option<Vec<Icon>>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
}

/// Describes an argument that a prompt can accept.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct PromptArgument {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub required: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum PromptListChangedNotification {}

impl ModelContextProtocolNotification for PromptListChangedNotification {
    const METHOD: &'static str = "notifications/prompts/list_changed";
    type Params = Option<NotificationParams>;
}

/// Describes a message returned as part of a prompt.
///
/// This is similar to `SamplingMessage`, but also supports the embedding of
/// resources from the MCP server.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct PromptMessage {
    pub content: ContentBlock,
    pub role: Role,
}

/// Identifies a prompt.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct PromptReference {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "ref/prompt"
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ReadResourceRequest {}

impl ModelContextProtocolRequest for ReadResourceRequest {
    const METHOD: &'static str = "resources/read";
    type Params = ReadResourceRequestParams;
    type Result = ReadResourceResult;
}

/// Parameters for a `resources/read` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ReadResourceRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub uri: String,
}

/// The server's response to a resources/read request from the client.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ReadResourceResult {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub contents: Vec<ReadResourceResultContents>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum ReadResourceResultContents {
    TextResourceContents(TextResourceContents),
    BlobResourceContents(BlobResourceContents),
}

impl From<ReadResourceResult> for serde_json::Value {
    fn from(value: ReadResourceResult) -> Self {
        // Leave this as it should never fail
        #[expect(clippy::unwrap_used)]
        serde_json::to_value(value).unwrap()
    }
}

/// Metadata for associating messages with a task.
/// Include this in the `_meta` field under the key `io.modelcontextprotocol/related-task`.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct RelatedTaskMetadata {
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Request {
    pub method: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub params: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, Hash, Eq, JsonSchema, TS)]
#[serde(untagged)]
pub enum RequestId {
    String(String),
    Integer(i64),
}

/// Common params for any request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct RequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
}

/// A known resource that the server is capable of reading.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Resource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub annotations: Option<Annotations>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub icons: Option<Vec<Icon>>,
    #[serde(rename = "mimeType", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mime_type: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub uri: String,
}

/// The contents of a specific resource or sub-resource.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ResourceContents {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(rename = "mimeType", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mime_type: Option<String>,
    pub uri: String,
}

/// A resource that the server is capable of reading, included in a prompt or tool call result.
///
/// Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ResourceLink {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub annotations: Option<Annotations>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub icons: Option<Vec<Icon>>,
    #[serde(rename = "mimeType", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mime_type: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "resource_link"
    pub uri: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ResourceListChangedNotification {}

impl ModelContextProtocolNotification for ResourceListChangedNotification {
    const METHOD: &'static str = "notifications/resources/list_changed";
    type Params = Option<NotificationParams>;
}

/// Common parameters when working with resources.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ResourceRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub uri: String,
}

/// A template description for resources available on the server.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ResourceTemplate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub annotations: Option<Annotations>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub icons: Option<Vec<Icon>>,
    #[serde(rename = "mimeType", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mime_type: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    #[serde(rename = "uriTemplate")]
    pub uri_template: String,
}

/// A reference to a resource or resource template definition.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ResourceTemplateReference {
    pub r#type: String, // &'static str = "ref/resource"
    pub uri: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ResourceUpdatedNotification {}

impl ModelContextProtocolNotification for ResourceUpdatedNotification {
    const METHOD: &'static str = "notifications/resources/updated";
    type Params = ResourceUpdatedNotificationParams;
}

/// Parameters for a `notifications/resources/updated` notification.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ResourceUpdatedNotificationParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub uri: String,
}

pub type Result = serde_json::Value;

/// The sender or recipient of messages and data in a conversation.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum Role {
    #[serde(rename = "assistant")]
    Assistant,
    #[serde(rename = "user")]
    User,
}

/// Represents a root directory or file that the server can operate on.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Root {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub name: Option<String>,
    pub uri: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum RootsListChangedNotification {}

impl ModelContextProtocolNotification for RootsListChangedNotification {
    const METHOD: &'static str = "notifications/roots/list_changed";
    type Params = Option<NotificationParams>;
}

/// Describes a message issued to or received from an LLM API.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct SamplingMessage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub content: SamplingMessageContent,
    pub role: Role,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum SamplingMessageContent {
    TextContent(TextContent),
    ImageContent(ImageContent),
    AudioContent(AudioContent),
    ToolUseContent(ToolUseContent),
    ToolResultContent(ToolResultContent),
    Variant5(Vec<SamplingMessageContentBlock>),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum SamplingMessageContentBlock {
    TextContent(TextContent),
    ImageContent(ImageContent),
    AudioContent(AudioContent),
    ToolUseContent(ToolUseContent),
    ToolResultContent(ToolResultContent),
}

/// Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ServerCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub completions: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub experimental: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub logging: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub prompts: Option<ServerCapabilitiesPrompts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub resources: Option<ServerCapabilitiesResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub tasks: Option<ServerCapabilitiesTasks>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub tools: Option<ServerCapabilitiesTools>,
}

/// Present if the server offers any tools to call.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ServerCapabilitiesTools {
    #[serde(
        rename = "listChanged",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub list_changed: Option<bool>,
}

/// Present if the server supports task-augmented requests.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ServerCapabilitiesTasks {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub cancel: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub list: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub requests: Option<ServerCapabilitiesTasksRequests>,
}

/// Specifies which request types can be augmented with tasks.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ServerCapabilitiesTasksRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub tools: Option<ServerCapabilitiesTasksRequestsTools>,
}

/// Task support for tool-related requests.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ServerCapabilitiesTasksRequestsTools {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub call: Option<serde_json::Value>,
}

/// Present if the server offers any resources to read.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ServerCapabilitiesResources {
    #[serde(
        rename = "listChanged",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub list_changed: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub subscribe: Option<bool>,
}

/// Present if the server offers any prompt templates.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ServerCapabilitiesPrompts {
    #[serde(
        rename = "listChanged",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub list_changed: Option<bool>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(tag = "method", content = "params")]
pub enum ServerNotification {
    #[serde(rename = "notifications/cancelled")]
    CancelledNotification(<CancelledNotification as ModelContextProtocolNotification>::Params),
    #[serde(rename = "notifications/progress")]
    ProgressNotification(<ProgressNotification as ModelContextProtocolNotification>::Params),
    #[serde(rename = "notifications/resources/list_changed")]
    ResourceListChangedNotification(
        <ResourceListChangedNotification as ModelContextProtocolNotification>::Params,
    ),
    #[serde(rename = "notifications/resources/updated")]
    ResourceUpdatedNotification(
        <ResourceUpdatedNotification as ModelContextProtocolNotification>::Params,
    ),
    #[serde(rename = "notifications/prompts/list_changed")]
    PromptListChangedNotification(
        <PromptListChangedNotification as ModelContextProtocolNotification>::Params,
    ),
    #[serde(rename = "notifications/tools/list_changed")]
    ToolListChangedNotification(
        <ToolListChangedNotification as ModelContextProtocolNotification>::Params,
    ),
    #[serde(rename = "notifications/tasks/status")]
    TaskStatusNotification(<TaskStatusNotification as ModelContextProtocolNotification>::Params),
    #[serde(rename = "notifications/message")]
    LoggingMessageNotification(
        <LoggingMessageNotification as ModelContextProtocolNotification>::Params,
    ),
    #[serde(rename = "notifications/elicitation/complete")]
    ElicitationCompleteNotification(
        <ElicitationCompleteNotification as ModelContextProtocolNotification>::Params,
    ),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum ServerRequest {
    PingRequest(PingRequest),
    GetTaskRequest(GetTaskRequest),
    GetTaskPayloadRequest(GetTaskPayloadRequest),
    CancelTaskRequest(CancelTaskRequest),
    ListTasksRequest(ListTasksRequest),
    CreateMessageRequest(CreateMessageRequest),
    ListRootsRequest(ListRootsRequest),
    ElicitRequest(ElicitRequest),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ServerResult {
    Result(Result),
    InitializeResult(InitializeResult),
    ListResourcesResult(ListResourcesResult),
    ListResourceTemplatesResult(ListResourceTemplatesResult),
    ReadResourceResult(ReadResourceResult),
    ListPromptsResult(ListPromptsResult),
    GetPromptResult(GetPromptResult),
    ListToolsResult(ListToolsResult),
    CallToolResult(CallToolResult),
    GetTaskResult(GetTaskResult),
    GetTaskPayloadResult(GetTaskPayloadResult),
    CancelTaskResult(CancelTaskResult),
    ListTasksResult(ListTasksResult),
    CompleteResult(CompleteResult),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum SetLevelRequest {}

impl ModelContextProtocolRequest for SetLevelRequest {
    const METHOD: &'static str = "logging/setLevel";
    type Params = SetLevelRequestParams;
    type Result = Result;
}

/// Parameters for a `logging/setLevel` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct SetLevelRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub level: LoggingLevel,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
#[serde(untagged)]
pub enum SingleSelectEnumSchema {
    UntitledSingleSelectEnumSchema(UntitledSingleSelectEnumSchema),
    TitledSingleSelectEnumSchema(TitledSingleSelectEnumSchema),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct StringSchema {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub default: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub format: Option<String>,
    #[serde(rename = "maxLength", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub max_length: Option<i64>,
    #[serde(rename = "minLength", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub min_length: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "string"
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum SubscribeRequest {}

impl ModelContextProtocolRequest for SubscribeRequest {
    const METHOD: &'static str = "resources/subscribe";
    type Params = SubscribeRequestParams;
    type Result = Result;
}

/// Parameters for a `resources/subscribe` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct SubscribeRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub uri: String,
}

/// Data associated with a task.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Task {
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "lastUpdatedAt")]
    pub last_updated_at: String,
    #[serde(
        rename = "pollInterval",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub poll_interval: Option<i64>,
    pub status: TaskStatus,
    #[serde(
        rename = "statusMessage",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub status_message: Option<String>,
    #[serde(rename = "taskId")]
    pub task_id: String,
    pub ttl: i64,
}

/// Common params for any task-augmented request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TaskAugmentedRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub task: Option<TaskMetadata>,
}

/// Metadata for augmenting a request with task execution.
/// Include this in the `task` field of the request parameters.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TaskMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub ttl: Option<i64>,
}

/// The status of a task.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum TaskStatus {
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "input_required")]
    Input_required,
    #[serde(rename = "working")]
    Working,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum TaskStatusNotification {}

impl ModelContextProtocolNotification for TaskStatusNotification {
    const METHOD: &'static str = "notifications/tasks/status";
    type Params = TaskStatusNotificationParams;
}

/// Parameters for a `notifications/tasks/status` notification.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TaskStatusNotificationParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "lastUpdatedAt")]
    pub last_updated_at: String,
    #[serde(
        rename = "pollInterval",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub poll_interval: Option<i64>,
    pub status: TaskStatus,
    #[serde(
        rename = "statusMessage",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub status_message: Option<String>,
    #[serde(rename = "taskId")]
    pub task_id: String,
    pub ttl: i64,
}

/// Text provided to or from an LLM.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TextContent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub annotations: Option<Annotations>,
    pub text: String,
    pub r#type: String, // &'static str = "text"
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TextResourceContents {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(rename = "mimeType", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mime_type: Option<String>,
    pub text: String,
    pub uri: String,
}

/// Schema for multiple-selection enumeration with display titles for each option.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TitledMultiSelectEnumSchema {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub default: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    pub items: TitledMultiSelectEnumSchemaItems,
    #[serde(rename = "maxItems", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub max_items: Option<i64>,
    #[serde(rename = "minItems", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub min_items: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "array"
}

/// Schema for array items with enum options and display labels.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TitledMultiSelectEnumSchemaItems {
    #[serde(rename = "anyOf")]
    pub any_of: Vec<TitledMultiSelectEnumSchemaItemsAnyOf>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TitledMultiSelectEnumSchemaItemsAnyOf {
    pub r#const: String,
    pub title: String,
}

/// Schema for single-selection enumeration with display titles for each option.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TitledSingleSelectEnumSchema {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub default: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(rename = "oneOf")]
    pub one_of: Vec<TitledSingleSelectEnumSchemaOneOf>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "string"
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct TitledSingleSelectEnumSchemaOneOf {
    pub r#const: String,
    pub title: String,
}

/// Definition for a tool the client can call.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct Tool {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub annotations: Option<ToolAnnotations>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub execution: Option<ToolExecution>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub icons: Option<Vec<Icon>>,
    #[serde(rename = "inputSchema")]
    pub input_schema: ToolInputSchema,
    pub name: String,
    #[serde(
        rename = "outputSchema",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub output_schema: Option<ToolOutputSchema>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
}

fn tool_output_schema_type_default_str() -> String {
    "object".to_string()
}

/// An optional JSON Schema object defining the structure of the tool's output returned in
/// the structuredContent field of a CallToolResult.
///
/// Defaults to JSON Schema 2020-12 when no explicit $schema is provided.
/// Currently restricted to type: "object" at the root level.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ToolOutputSchema {
    #[serde(rename = "$schema", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub properties: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub required: Option<Vec<String>>,
    #[serde(default = "tool_output_schema_type_default_str")]
    pub r#type: String, // &'static str = "object"
}

fn tool_input_schema_type_default_str() -> String {
    "object".to_string()
}

/// A JSON Schema object defining the expected parameters for the tool.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ToolInputSchema {
    #[serde(rename = "$schema", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub properties: Option<serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub required: Option<Vec<String>>,
    #[serde(default = "tool_input_schema_type_default_str")]
    pub r#type: String, // &'static str = "object"
}

/// Additional properties describing a Tool to clients.
///
/// NOTE: all properties in ToolAnnotations are **hints**.
/// They are not guaranteed to provide a faithful description of
/// tool behavior (including descriptive properties like `title`).
///
/// Clients should never make tool use decisions based on ToolAnnotations
/// received from untrusted servers.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ToolAnnotations {
    #[serde(
        rename = "destructiveHint",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub destructive_hint: Option<bool>,
    #[serde(
        rename = "idempotentHint",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub idempotent_hint: Option<bool>,
    #[serde(
        rename = "openWorldHint",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub open_world_hint: Option<bool>,
    #[serde(
        rename = "readOnlyHint",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub read_only_hint: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
}

/// Controls tool selection behavior for sampling requests.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ToolChoice {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub mode: Option<String>,
}

/// Execution-related properties for a tool.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ToolExecution {
    #[serde(
        rename = "taskSupport",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub task_support: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum ToolListChangedNotification {}

impl ModelContextProtocolNotification for ToolListChangedNotification {
    const METHOD: &'static str = "notifications/tools/list_changed";
    type Params = Option<NotificationParams>;
}

/// The result of a tool use, provided by the user back to the assistant.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ToolResultContent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub content: Vec<ContentBlock>,
    #[serde(rename = "isError", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub is_error: Option<bool>,
    #[serde(
        rename = "structuredContent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    #[ts(optional)]
    pub structured_content: Option<serde_json::Value>,
    #[serde(rename = "toolUseId")]
    pub tool_use_id: String,
    pub r#type: String, // &'static str = "tool_result"
}

/// A request from the assistant to call a tool.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct ToolUseContent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub id: String,
    pub input: serde_json::Value,
    pub name: String,
    pub r#type: String, // &'static str = "tool_use"
}

/// An error response that indicates that the server requires the client to provide additional information via an elicitation request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct URLElicitationRequiredError {
    pub error: serde_json::Value,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub id: Option<RequestId>,
    #[serde(rename = "jsonrpc", default = "default_jsonrpc")]
    pub jsonrpc: String,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub enum UnsubscribeRequest {}

impl ModelContextProtocolRequest for UnsubscribeRequest {
    const METHOD: &'static str = "resources/unsubscribe";
    type Params = UnsubscribeRequestParams;
    type Result = Result;
}

/// Parameters for a `resources/unsubscribe` request.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct UnsubscribeRequestParams {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub _meta: Option<serde_json::Value>,
    pub uri: String,
}

/// Schema for multiple-selection enumeration without display titles for options.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct UntitledMultiSelectEnumSchema {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub default: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    pub items: UntitledMultiSelectEnumSchemaItems,
    #[serde(rename = "maxItems", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub max_items: Option<i64>,
    #[serde(rename = "minItems", default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub min_items: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "array"
}

/// Schema for the array items.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct UntitledMultiSelectEnumSchemaItems {
    pub r#enum: Vec<String>,
    pub r#type: String, // &'static str = "string"
}

/// Schema for single-selection enumeration without display titles for options.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, JsonSchema, TS)]
pub struct UntitledSingleSelectEnumSchema {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub default: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub description: Option<String>,
    pub r#enum: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[ts(optional)]
    pub title: Option<String>,
    pub r#type: String, // &'static str = "string"
}

impl TryFrom<JSONRPCRequest> for ClientRequest {
    type Error = serde_json::Error;
    fn try_from(req: JSONRPCRequest) -> std::result::Result<Self, Self::Error> {
        match req.method.as_str() {
            "initialize" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <InitializeRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::InitializeRequest(params))
            }
            "ping" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <PingRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::PingRequest(params))
            }
            "resources/list" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <ListResourcesRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::ListResourcesRequest(params))
            }
            "resources/templates/list" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <ListResourceTemplatesRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::ListResourceTemplatesRequest(params))
            }
            "resources/read" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <ReadResourceRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::ReadResourceRequest(params))
            }
            "resources/subscribe" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <SubscribeRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::SubscribeRequest(params))
            }
            "resources/unsubscribe" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <UnsubscribeRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::UnsubscribeRequest(params))
            }
            "prompts/list" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <ListPromptsRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::ListPromptsRequest(params))
            }
            "prompts/get" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <GetPromptRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::GetPromptRequest(params))
            }
            "tools/list" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <ListToolsRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::ListToolsRequest(params))
            }
            "tools/call" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <CallToolRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::CallToolRequest(params))
            }
            "tasks/get" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <GetTaskRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::GetTaskRequest(params))
            }
            "tasks/result" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <GetTaskPayloadRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::GetTaskPayloadRequest(params))
            }
            "tasks/cancel" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <CancelTaskRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::CancelTaskRequest(params))
            }
            "tasks/list" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <ListTasksRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::ListTasksRequest(params))
            }
            "logging/setLevel" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <SetLevelRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::SetLevelRequest(params))
            }
            "completion/complete" => {
                let params_json = req.params.unwrap_or(serde_json::Value::Null);
                let params: <CompleteRequest as ModelContextProtocolRequest>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ClientRequest::CompleteRequest(params))
            }
            _ => Err(serde_json::Error::io(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Unknown method: {}", req.method),
            ))),
        }
    }
}

impl TryFrom<JSONRPCNotification> for ServerNotification {
    type Error = serde_json::Error;
    fn try_from(n: JSONRPCNotification) -> std::result::Result<Self, Self::Error> {
        match n.method.as_str() {
            "notifications/cancelled" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <CancelledNotification as ModelContextProtocolNotification>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ServerNotification::CancelledNotification(params))
            }
            "notifications/progress" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <ProgressNotification as ModelContextProtocolNotification>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ServerNotification::ProgressNotification(params))
            }
            "notifications/resources/list_changed" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <ResourceListChangedNotification as ModelContextProtocolNotification>::Params = serde_json::from_value(params_json)?;
                Ok(ServerNotification::ResourceListChangedNotification(params))
            }
            "notifications/resources/updated" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <ResourceUpdatedNotification as ModelContextProtocolNotification>::Params = serde_json::from_value(params_json)?;
                Ok(ServerNotification::ResourceUpdatedNotification(params))
            }
            "notifications/prompts/list_changed" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <PromptListChangedNotification as ModelContextProtocolNotification>::Params = serde_json::from_value(params_json)?;
                Ok(ServerNotification::PromptListChangedNotification(params))
            }
            "notifications/tools/list_changed" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <ToolListChangedNotification as ModelContextProtocolNotification>::Params = serde_json::from_value(params_json)?;
                Ok(ServerNotification::ToolListChangedNotification(params))
            }
            "notifications/tasks/status" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <TaskStatusNotification as ModelContextProtocolNotification>::Params =
                    serde_json::from_value(params_json)?;
                Ok(ServerNotification::TaskStatusNotification(params))
            }
            "notifications/message" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <LoggingMessageNotification as ModelContextProtocolNotification>::Params = serde_json::from_value(params_json)?;
                Ok(ServerNotification::LoggingMessageNotification(params))
            }
            "notifications/elicitation/complete" => {
                let params_json = n.params.unwrap_or(serde_json::Value::Null);
                let params: <ElicitationCompleteNotification as ModelContextProtocolNotification>::Params = serde_json::from_value(params_json)?;
                Ok(ServerNotification::ElicitationCompleteNotification(params))
            }
            _ => Err(serde_json::Error::io(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Unknown method: {}", n.method),
            ))),
        }
    }
}
