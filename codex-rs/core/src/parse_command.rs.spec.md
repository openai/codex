## Overview
`core::parse_command` classifies shell commands generated by the agent into structured `ParsedCommand` entries. It attempts to identify reads, listings, and searches within nested shell invocations (bash/zsh `-lc`, pipelines, subshells) so the UI can summarize actions and reviewers can understand tool behavior without parsing raw shell strings.

## Detailed Behavior
- `parse_command` is the public entrypoint. It delegates to `parse_command_impl` (defined below in the file) and then collapses consecutive duplicate `ParsedCommand`s to reduce noise in generated summaries.
- The implementation (hidden behind `parse_command_impl`) handles:
  - Shell wrappers (`bash -lc`, `zsh -lc`) by invoking helpers from `crate::bash` (`try_parse_shell`, `try_parse_word_only_commands_sequence`).
  - Command chains separated by `&&`, `||`, `;`, and pipelines. Commands are normalized with `shlex_join` to retain quoting; `shlex_try_join` failures (e.g., embedded NULs) fall back to sentinel text.
  - Path awareness—`cd` segments update the working directory so subsequent reads/searches include resolved paths (`cat foo.txt` after `cd bar` → `ParsedCommand::Read` for `bar/foo.txt`).
- Classification heuristics produce specific variants:
  - `ParsedCommand::Read` for `cat`, `head`, `tail`, etc., capturing file name/path.
  - `ParsedCommand::ListFiles` for `ls` patterns.
  - `ParsedCommand::Search` for `rg`/`grep` using query detection (`--files`, `-n`, path arguments) and pipeline awareness (e.g., `rg --files | head` yields both search and head items).
  - Everything else defaults to `ParsedCommand::Unknown { cmd }`.
- Extensive unit tests (located directly below the function) cover shell wrappers, pipelines, quoting, search query extraction, and formatting command detection (`is_small_formatting_command`). Tests intentionally live atop the module to encourage update-via-tests when heuristics change.

## Broader Context
- Tool orchestration (`tools/handlers/shell.rs`) uses `parse_command` to generate human-readable summaries for approvals and logs. Rollout specs rely on these summaries to contextualize commands in session history.
- The parser works in tandem with `bash` helpers; updates to shell parsing must consider both modules. When new `ParsedCommand` variants are added in `codex_protocol`, this module must be updated to emit them.
- Context can't yet be determined for complex shell features (process substitution, here-docs); unsupported patterns fall back to `Unknown`, ensuring summaries remain safe even when heuristics miss a match.

## Technical Debt
- Parsing logic is intentionally dense and brittle; comments warn against manual edits. Extracting the implementation into smaller, testable helpers (or using a parser combinator) would simplify maintenance.
- Deduplication only removes consecutive duplicates. More holistic collapsing (e.g., identical commands separated by trivial formatters) could further reduce noise in logs.

---
tech_debt:
  severity: medium
  highest_priority_items:
    - Factor `parse_command_impl` into smaller parsing stages so new command classifications are easier to introduce without regressions.
    - Consider richer deduplication heuristics to collapse equivalent command sequences separated by no-op formatting commands.
related_specs:
  - ./bash.rs.spec.md
  - ./tools/handlers/shell.rs.spec.md
  - ../protocol/src/parse_command.rs.spec.md
