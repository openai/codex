/// Builder for loop iteration prompts.
///
/// Implements Auto-Coder style git-based iterative improvement prompts.
pub struct LoopPromptBuilder;

/// Default loop instruction appended to queries after first iteration.
const DEFAULT_LOOP_INSTRUCTION: &str = r#"
Additional instruction: use git log to get the code changes generated by previous
tasks and try to focus on iterative improvements and refinements and make sure to
use git commit command to make a commit after every single file edit."#;

impl LoopPromptBuilder {
    /// Enhance query for loop iterations > 0.
    ///
    /// First iteration (iteration == 0) uses original query unchanged.
    /// Subsequent iterations append loop instructions.
    ///
    /// # Arguments
    ///
    /// * `original` - Original user query
    /// * `iteration` - Current iteration number (0-indexed)
    ///
    /// # Returns
    ///
    /// Enhanced query string
    pub fn build(original: &str, iteration: i32) -> String {
        if iteration == 0 {
            original.to_string()
        } else {
            Self::enhance(original)
        }
    }

    /// Enhance query with loop instructions.
    ///
    /// Appends git-based iterative improvement instructions.
    pub fn enhance(original: &str) -> String {
        format!("{original}\n{DEFAULT_LOOP_INSTRUCTION}")
    }

    /// Build with custom loop instruction.
    ///
    /// Allows users to specify their own loop prompt.
    pub fn build_with_custom(
        original: &str,
        iteration: i32,
        custom_instruction: Option<&str>,
    ) -> String {
        if iteration == 0 {
            original.to_string()
        } else {
            match custom_instruction {
                Some(instruction) => format!("{original}\n\n{instruction}"),
                None => Self::enhance(original),
            }
        }
    }
}

// === Enhanced Context-Aware Prompt Templates ===

use super::context::LoopContext;

/// Complexity assessment prompt - injected on each iteration to guide planning decisions.
///
/// Helps the LLM decide whether to enter Plan Mode for complex tasks.
/// EnterPlanMode/ExitPlanMode are auto-approved in SpawnAgent context.
const COMPLEXITY_ASSESSMENT_PROMPT: &str = r#"<task_assessment>
## Task Complexity Assessment

Before working on this iteration, evaluate the task complexity:

1. **Complexity Check**:
   - Is this a multi-file change? (3+ files)
   - Does it require understanding existing architecture?
   - Could changes break existing functionality?

2. **Decision**:
   - If complex → Use `EnterPlanMode` to explore the codebase and plan first
   - If simple → Proceed directly with implementation

3. **When in Plan Mode**:
   - Explore the codebase to understand patterns and architecture
   - Write your plan to the plan file
   - Call `ExitPlanMode` when ready to implement

Note: EnterPlanMode and ExitPlanMode are auto-approved in this context.
</task_assessment>
"#;

/// Loop context template for enhanced prompts.
const LOOP_CONTEXT_TEMPLATE: &str = r#"<task_context>
## Original Task
{initial_prompt}

{plan_section}## Progress
Iteration: {current} of {total}
Base commit: {base_commit_id}

## Previous Iterations
{iteration_records}
</task_context>

IMPORTANT:
- DO NOT run git commit yourself - the system handles commits automatically
- Focus on making improvements and refinements based on previous work
- You can use git diff/log to review detailed changes if needed
- Each iteration should build upon the previous ones
"#;

/// Plan section template.
const PLAN_SECTION_TEMPLATE: &str = r#"## Plan
{plan_content}

"#;

/// Iteration record template.
const ITERATION_RECORD_TEMPLATE: &str = r#"### Iteration {iteration} → {commit_status}
Files: {files}
Summary: {summary}
"#;

/// Build enhanced prompt with context injection.
///
/// For iteration 0, returns original prompt with complexity assessment.
/// For iteration > 0, prepends context block with history and complexity assessment.
///
/// The complexity assessment prompt is injected on every iteration to guide the LLM
/// to use EnterPlanMode for complex tasks (auto-approved in SpawnAgent context).
pub fn build_enhanced_prompt(original: &str, iteration: i32, context: &LoopContext) -> String {
    if iteration == 0 {
        // First iteration: add complexity assessment before original prompt
        return format!("{COMPLEXITY_ASSESSMENT_PROMPT}\n{original}");
    }

    // Build plan section
    let plan_section = match &context.plan_content {
        Some(plan) => PLAN_SECTION_TEMPLATE.replace("{plan_content}", plan),
        None => String::new(),
    };

    // Build iteration records
    let iteration_records: String = context
        .iterations
        .iter()
        .map(|record| {
            ITERATION_RECORD_TEMPLATE
                .replace("{iteration}", &record.iteration.to_string())
                .replace("{commit_status}", &record.commit_status())
                .replace("{files}", &record.files_display())
                .replace("{summary}", &record.summary)
        })
        .collect::<Vec<_>>()
        .join("\n");

    // Format total
    let total_str = if context.total_iterations > 0 {
        context.total_iterations.to_string()
    } else {
        "ongoing".to_string()
    };

    // Build context block
    let context_block = LOOP_CONTEXT_TEMPLATE
        .replace("{initial_prompt}", &context.initial_prompt)
        .replace("{plan_section}", &plan_section)
        .replace("{current}", &(iteration + 1).to_string()) // 1-indexed for display
        .replace("{total}", &total_str)
        .replace("{base_commit_id}", &context.base_commit_id)
        .replace("{iteration_records}", &iteration_records);

    // Subsequent iterations: context block + complexity assessment + original
    format!("{context_block}\n{COMPLEXITY_ASSESSMENT_PROMPT}\n{original}")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn first_iteration_unchanged() {
        let query = "Implement user auth";
        assert_eq!(LoopPromptBuilder::build(query, 0), query);
    }

    #[test]
    fn subsequent_iterations_enhanced() {
        let query = "Implement user auth";
        let enhanced = LoopPromptBuilder::build(query, 1);

        assert!(enhanced.starts_with(query));
        assert!(enhanced.contains("git log"));
        assert!(enhanced.contains("iterative improvements"));
    }

    #[test]
    fn custom_instruction() {
        let query = "Fix tests";
        let custom = "Focus on edge cases and error handling";
        let result = LoopPromptBuilder::build_with_custom(query, 1, Some(custom));

        assert!(result.contains(query));
        assert!(result.contains(custom));
        assert!(!result.contains("git log")); // No default instruction
    }

    // === Enhanced prompt tests ===

    use crate::loop_driver::context::IterationRecord;

    #[test]
    fn enhanced_prompt_first_iteration() {
        let ctx = LoopContext::new("abc123".to_string(), "Implement X".to_string(), None, 5);
        let result = build_enhanced_prompt("Do the task", 0, &ctx);
        // First iteration includes complexity assessment prompt
        assert!(result.contains("<task_assessment>"));
        assert!(result.contains("Task Complexity Assessment"));
        assert!(result.contains("EnterPlanMode"));
        assert!(result.contains("Do the task"));
    }

    #[test]
    fn enhanced_prompt_with_history() {
        let mut ctx = LoopContext::new(
            "abc123".to_string(),
            "Implement X".to_string(),
            Some("## Plan\n1. Step one".to_string()),
            5,
        );
        ctx.add_iteration(IterationRecord::new(
            0,
            Some("def456789".to_string()),
            vec!["file.rs".to_string()],
            "Did step one".to_string(),
            true,
        ));

        let result = build_enhanced_prompt("Continue work", 1, &ctx);

        assert!(result.contains("<task_context>"));
        assert!(result.contains("## Original Task"));
        assert!(result.contains("Implement X"));
        assert!(result.contains("## Plan"));
        assert!(result.contains("Step one"));
        assert!(result.contains("Iteration: 2 of 5"));
        assert!(result.contains("Base commit: abc123"));
        assert!(result.contains("### Iteration 0"));
        assert!(result.contains("commit def4567"));
        assert!(result.contains("file.rs"));
        assert!(result.contains("Did step one"));
        assert!(result.contains("DO NOT run git commit"));
        assert!(result.contains("Continue work"));
        // Complexity assessment should also be present
        assert!(result.contains("<task_assessment>"));
        assert!(result.contains("EnterPlanMode"));
    }

    #[test]
    fn enhanced_prompt_duration_mode() {
        let ctx = LoopContext::new(
            "abc123".to_string(),
            "Long task".to_string(),
            None,
            -1, // Duration mode
        );

        let result = build_enhanced_prompt("Keep going", 1, &ctx);
        assert!(result.contains("Iteration: 2 of ongoing"));
    }

    #[test]
    fn enhanced_prompt_no_plan() {
        let ctx = LoopContext::new(
            "abc123".to_string(),
            "Task without plan".to_string(),
            None,
            3,
        );

        let result = build_enhanced_prompt("Work", 1, &ctx);
        assert!(!result.contains("## Plan"));
        assert!(result.contains("## Original Task"));
    }
}
