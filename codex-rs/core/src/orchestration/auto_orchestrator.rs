//! Autonomous orchestrator for ClaudeCode-style transparent sub-agent coordination.
//!
//! Automatically analyzes tasks, generates execution plans via Supervisor,
//! and coordinates parallel sub-agent execution with result aggregation.

use crate::agents::AgentResult;
use crate::agents::AgentRuntime;
use crate::orchestration::CollaborationStore;
use crate::orchestration::ConflictResolver;
use crate::orchestration::MergeStrategy;
use crate::orchestration::TaskAnalysis;
use anyhow::Result;
use serde::Deserialize;
use serde::Serialize;
use std::collections::HashMap;
use std::sync::Arc;
use std::time::Instant;
use tracing::debug;
use tracing::info;
use tracing::warn;

/// Result of orchestrated execution.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrchestratedResult {
    /// Whether orchestration was actually used
    pub was_orchestrated: bool,

    /// Agents that were used
    pub agents_used: Vec<String>,

    /// Execution summary
    pub execution_summary: String,

    /// Individual agent results
    pub agent_results: Vec<AgentResult>,

    /// Total execution time in seconds
    pub total_execution_time_secs: f64,

    /// Task analysis that triggered orchestration
    pub task_analysis: TaskAnalysis,
}

/// Execution plan generated by Supervisor.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionPlan {
    /// Goal description
    pub goal: String,

    /// List of tasks to execute
    pub tasks: Vec<PlannedTask>,

    /// Execution strategy
    pub strategy: String,
}

/// A single task in the execution plan.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlannedTask {
    /// Task ID
    pub id: usize,

    /// Task description
    pub description: String,

    /// Agent assigned to this task
    pub agent: String,

    /// Task status
    pub status: String,
}

/// Execution strategy for orchestrated tasks.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ExecutionStrategy {
    /// Execute all tasks in parallel for maximum speed
    Parallel,
    /// Execute tasks sequentially for dependencies
    Sequential,
    /// Hybrid: parallel where possible, sequential where needed
    Hybrid,
}

/// Autonomous orchestrator that coordinates sub-agents transparently.
pub struct AutoOrchestrator {
    /// Agent runtime for executing sub-agents
    runtime: Arc<AgentRuntime>,

    /// Collaboration store for agent communication
    collaboration_store: Arc<CollaborationStore>,

    /// Conflict resolver for file edits
    conflict_resolver: Arc<ConflictResolver>,

    /// Workspace directory
    workspace_dir: std::path::PathBuf,
}

impl AutoOrchestrator {
    /// Create a new auto-orchestrator.
    pub fn new(
        runtime: Arc<AgentRuntime>,
        collaboration_store: Arc<CollaborationStore>,
        workspace_dir: std::path::PathBuf,
    ) -> Self {
        Self::with_merge_strategy(
            runtime,
            collaboration_store,
            workspace_dir,
            MergeStrategy::Sequential,
        )
    }

    /// Create a new auto-orchestrator with a specific merge strategy.
    pub fn with_merge_strategy(
        runtime: Arc<AgentRuntime>,
        collaboration_store: Arc<CollaborationStore>,
        workspace_dir: std::path::PathBuf,
        merge_strategy: MergeStrategy,
    ) -> Self {
        Self {
            runtime,
            collaboration_store,
            conflict_resolver: Arc::new(ConflictResolver::new(merge_strategy)),
            workspace_dir,
        }
    }

    /// Get a reference to the conflict resolver.
    pub fn conflict_resolver(&self) -> Arc<ConflictResolver> {
        self.conflict_resolver.clone()
    }

    /// Orchestrate task execution based on analysis.
    pub async fn orchestrate(
        &self,
        analysis: TaskAnalysis,
        original_goal: String,
    ) -> Result<OrchestratedResult> {
        let start_time = Instant::now();

        info!(
            "ðŸš€ Auto-orchestrating task with complexity {:.2}",
            analysis.complexity_score
        );
        info!("   Recommended agents: {:?}", analysis.recommended_agents);

        // 1. Generate execution plan (simplified - direct agent delegation)
        let plan = self
            .generate_execution_plan(&analysis, &original_goal)
            .await?;

        info!("ðŸ“‹ Execution plan created: {} tasks", plan.tasks.len());

        // 2. Execute agents from plan
        let results = self.execute_agents_from_plan(&plan, &analysis).await?;

        // 3. Merge results
        let execution_summary = self.merge_results(&results);

        let total_time = start_time.elapsed().as_secs_f64();

        Ok(OrchestratedResult {
            was_orchestrated: true,
            agents_used: results.iter().map(|r| r.agent_name.clone()).collect(),
            execution_summary,
            agent_results: results,
            total_execution_time_secs: total_time,
            task_analysis: analysis,
        })
    }

    /// Generate execution plan based on task analysis.
    async fn generate_execution_plan(
        &self,
        analysis: &TaskAnalysis,
        original_goal: &str,
    ) -> Result<ExecutionPlan> {
        // For now, create a simple plan based on recommended agents
        // In full implementation, this would call codex-supervisor MCP tool

        let mut tasks = Vec::new();

        for (idx, agent) in analysis.recommended_agents.iter().enumerate() {
            let description = if idx < analysis.subtasks.len() {
                analysis.subtasks[idx].clone()
            } else {
                format!("Execute {agent} for: {original_goal}")
            };

            tasks.push(PlannedTask {
                id: idx + 1,
                description,
                agent: agent.clone(),
                status: "pending".to_string(),
            });
        }

        Ok(ExecutionPlan {
            goal: original_goal.to_string(),
            tasks,
            strategy: "parallel".to_string(),
        })
    }

    /// Execute agents from the execution plan.
    async fn execute_agents_from_plan(
        &self,
        plan: &ExecutionPlan,
        _analysis: &TaskAnalysis,
    ) -> Result<Vec<AgentResult>> {
        let mut results = Vec::new();

        // Prepare agent tasks for parallel execution
        let mut agent_configs = Vec::new();

        for task in &plan.tasks {
            let mut inputs = HashMap::new();
            inputs.insert("goal".to_string(), task.description.clone());
            inputs.insert(
                "workspace".to_string(),
                self.workspace_dir.display().to_string(),
            );
            inputs.insert("task_id".to_string(), task.id.to_string());

            // Add context from other completed agents
            let completed_summary = self.collaboration_store.get_results_summary();
            if !completed_summary.is_empty() {
                inputs.insert("previous_results".to_string(), completed_summary);
            }

            agent_configs.push((task.agent.clone(), task.description.clone(), inputs, None));
        }

        // Execute agents in parallel
        info!("â³ Executing {} agents in parallel...", agent_configs.len());

        match self
            .runtime
            .delegate_parallel(agent_configs.clone(), None)
            .await
        {
            Ok(agent_results) => {
                // Store results in collaboration store
                for result in &agent_results {
                    self.collaboration_store
                        .store_agent_result(result.agent_name.clone(), result.clone());
                }
                results.extend(agent_results);
            }
            Err(e) => {
                warn!("âš ï¸  Parallel execution failed: {}", e);
                // Fallback: execute sequentially
                for (agent_name, goal, inputs, budget) in agent_configs {
                    match self
                        .runtime
                        .delegate(&agent_name, &goal, inputs.clone(), budget, None)
                        .await
                    {
                        Ok(result) => {
                            self.collaboration_store
                                .store_agent_result(result.agent_name.clone(), result.clone());
                            results.push(result);
                        }
                        Err(agent_err) => {
                            warn!("âš ï¸  Agent {} failed: {}", agent_name, agent_err);
                        }
                    }
                }
            }
        }

        if results.is_empty() {
            anyhow::bail!("All agents failed to execute");
        }

        info!(
            "âœ… Orchestration completed: {} agents executed",
            results.len()
        );

        Ok(results)
    }

    /// Merge results from multiple agents into a summary.
    fn merge_results(&self, results: &[AgentResult]) -> String {
        let mut summary = String::from("# Orchestrated Execution Summary\n\n");

        summary.push_str(&format!(
            "Executed {} specialized agents:\n\n",
            results.len()
        ));

        for (idx, result) in results.iter().enumerate() {
            summary.push_str(&format!(
                "## Agent {} / {}: {}\n\n",
                idx + 1,
                results.len(),
                result.agent_name
            ));

            summary.push_str(&format!("**Status**: {:?}\n\n", result.status));
            summary.push_str(&format!(
                "**Execution Time**: {:.2}s\n\n",
                result.duration_secs
            ));

            // Include tokens used
            summary.push_str(&format!("**Tokens Used**: {}\n\n", result.tokens_used));

            // Include error if any
            if let Some(ref error) = result.error {
                summary.push_str("**Error**:\n\n");
                for line in error.lines().take(5) {
                    summary.push_str(&format!("{line}\n"));
                }
                summary.push('\n');
            }

            // Include artifacts if any
            if !result.artifacts.is_empty() {
                summary.push_str("**Artifacts**:\n\n");
                for artifact in &result.artifacts {
                    summary.push_str(&format!("- {artifact}\n"));
                }
                summary.push('\n');
            }

            summary.push_str("---\n\n");
        }

        summary
    }

    /// Select agents dynamically based on task analysis.
    ///
    /// Analyzes task requirements and selects the most appropriate agents.
    /// Uses heuristics based on:
    /// - Required skills (from task analysis)
    /// - Task complexity
    /// - Domain specificity
    pub fn select_agents_for_task(&self, analysis: &TaskAnalysis) -> Vec<String> {
        debug!("Selecting agents for task analysis");
        let mut selected_agents = Vec::new();

        // Use recommended agents from analysis as baseline
        for agent in &analysis.recommended_agents {
            selected_agents.push(agent.clone());
        }

        // Add specialized agents based on detected keywords
        for keyword in &analysis.detected_keywords {
            match keyword.as_str() {
                "testing" | "test" => {
                    if !selected_agents.contains(&"test-gen".to_string()) {
                        debug!("Adding test-gen agent for testing keyword");
                        selected_agents.push("test-gen".to_string());
                    }
                }
                "security" | "audit" => {
                    if !selected_agents.contains(&"sec-audit".to_string()) {
                        debug!("Adding sec-audit agent for security keyword");
                        selected_agents.push("sec-audit".to_string());
                    }
                }
                "research" | "investigation" => {
                    if !selected_agents.contains(&"researcher".to_string()) {
                        debug!("Adding researcher agent for research skill");
                        selected_agents.push("researcher".to_string());
                    }
                }
                "code-review" | "review" => {
                    if !selected_agents.contains(&"code-reviewer".to_string()) {
                        debug!("Adding code-reviewer agent for review skill");
                        selected_agents.push("code-reviewer".to_string());
                    }
                }
                _ => {}
            }
        }

        // Ensure at least one agent is selected
        if selected_agents.is_empty() {
            debug!("No agents selected, defaulting to code-reviewer");
            selected_agents.push("code-reviewer".to_string());
        }

        info!(
            "Selected {} agents for task: {:?}",
            selected_agents.len(),
            selected_agents
        );

        selected_agents
    }

    /// Determine execution strategy based on task characteristics.
    ///
    /// Analyzes task to decide whether parallel, sequential, or hybrid execution is best.
    pub fn determine_execution_strategy(&self, task: &PlannedTask) -> ExecutionStrategy {
        debug!(
            "Determining execution strategy for task: {}",
            task.description
        );

        // Check for keywords indicating sequential dependencies
        let description_lower = task.description.to_lowercase();
        let has_dependencies = description_lower.contains("after")
            || description_lower.contains("then")
            || description_lower.contains("depends on")
            || description_lower.contains("based on");

        if has_dependencies {
            debug!("Task has dependencies, using Sequential strategy");
            return ExecutionStrategy::Sequential;
        }

        // Check for file editing conflicts
        let has_file_edits = description_lower.contains("edit")
            || description_lower.contains("modify")
            || description_lower.contains("change");

        if has_file_edits {
            debug!("Task involves file edits, using Hybrid strategy");
            return ExecutionStrategy::Hybrid;
        }

        // Default to parallel for independent tasks
        debug!("Task appears independent, using Parallel strategy");
        ExecutionStrategy::Parallel
    }

    /// Aggregate results from multiple agents with conflict resolution.
    ///
    /// Combines results while resolving any conflicts in file edits.
    pub fn aggregate_results(&self, results: Vec<AgentResult>) -> Result<OrchestratedResult> {
        debug!("Aggregating {} agent results", results.len());

        let start_time = Instant::now();
        let agents_used: Vec<String> = results.iter().map(|r| r.agent_name.clone()).collect();

        // Merge results using the conflict resolver
        let execution_summary = self.merge_results(&results);

        // Check for conflicts in file edits
        let mut _has_conflicts = false;
        for result in &results {
            if !matches!(result.status, crate::agents::AgentStatus::Completed) {
                _has_conflicts = true;
                let error_msg = result
                    .error
                    .as_ref()
                    .map(ToString::to_string)
                    .unwrap_or_else(|| "Unknown error".to_string());
                warn!("Agent {} failed: {}", result.agent_name, error_msg);
            }
        }

        let task_analysis = TaskAnalysis {
            complexity_score: 0.5,
            detected_keywords: vec![],
            recommended_agents: agents_used.clone(),
            subtasks: vec![],
            original_input: String::new(),
        };

        Ok(OrchestratedResult {
            was_orchestrated: true,
            agents_used,
            execution_summary,
            agent_results: results,
            total_execution_time_secs: start_time.elapsed().as_secs_f64(),
            task_analysis,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::agents::AgentStatus;
    use crate::agents::TokenBudgeter;
    use crate::orchestration::TaskAnalyzer;

    #[test]
    fn test_execution_plan_generation() {
        // This would require async runtime and mocked dependencies
        // Placeholder for future implementation
    }

    #[test]
    fn test_result_merging() {
        let _collab_store = Arc::new(CollaborationStore::new());
        let _workspace = std::path::PathBuf::from("/tmp/test");

        // Create mock runtime (would need proper mocking)
        // For now, we can't easily test without full setup

        // Test merge_results directly
        let results = vec![
            AgentResult {
                agent_name: "test-agent-1".to_string(),
                status: AgentStatus::Completed,
                artifacts: vec!["output1.md".to_string()],
                tokens_used: 1500,
                duration_secs: 2.5,
                error: None,
            },
            AgentResult {
                agent_name: "test-agent-2".to_string(),
                status: AgentStatus::Completed,
                artifacts: vec![],
                tokens_used: 1200,
                duration_secs: 1.5,
                error: None,
            },
        ];

        // We need a runtime instance to test merge_results
        // This is just a structure test
        assert_eq!(results.len(), 2);
    }
}
