pub(crate) const SPEC_SYSTEM_PROMPT: &str = "You are an application security engineer documenting how a project is built. Produce an architecture specification that focuses on components, flows, and controls. Stay within the provided code locations, ground claims in concrete evidence, and keep the output in markdown.";
pub(crate) const SPEC_COMBINE_SYSTEM_PROMPT: &str = "You are consolidating multiple specification drafts into a single, cohesive project specification. Merge overlapping content, keep terminology consistent, and follow the supplied template. Preserve every security-relevant detail; when in doubt, include rather than summarize away content.";
pub(crate) const SPEC_PROMPT_TEMPLATE: &str = "You have access to the source code inside the following locations:\n{project_locations}\nRepository root (use absolute paths in tool calls): {repo_root}\n\nFocus on {target_label}.\nGenerate a security-focused project specification. Before drafting, identify whether the target behaves like a backend service, desktop or mobile client, SDK/library, firmware, CLI, or mixed topology. Adapt the structure and diagrams to match that shape:\n- For services, emphasise request routing, data persistence, and external integrations.\n- For SDKs/libraries, highlight module responsibilities, host-application touchpoints, and API usage sequences.\n- For clients or firmware, show local process boundaries, platform APIs, and sync/telemetry flows.\n\nCapture the concrete flows, component responsibilities, runtime/distribution model, and exposed surfaces so the final markdown can include fit-for-purpose diagrams (architecture overview, component interactions, sequence diagrams) grounded in real handlers, modules, or functions. Do not diagram low-level runtime details (e.g., container startup sequences, helper scripts, or test utilities). When a section does not apply, state `- Not applicable (reason)` instead of leaving it blank.\n\nParallelize discovery when enumerating files and avoid spending time on tests, vendored dependencies, or build artefacts. When you already know a set of files or directories to open, issue a single parallel batch of READ calls instead of one-by-one requests.\n\nUse the available tools directly without restating how to call them. While reading files, collect exact handler names, structs, RPCs, public APIs, and configuration fields you will reference in the diagrams and Sources sections. Start by inspecting the current directory layout (READ a directory path to list entries) and open the key files you need to understand behaviour before drafting. SEARCH is unavailable. Make a few grounded tool calls before returning the final markdown.\n\nTemplate:\n{spec_template}\n";
pub(crate) const CONVERT_CLASSIFICATION_TO_JSON_PROMPT_TEMPLATE: &str = r#"
Read the project specification below and extract a normalized Data Classification list.

<specification>
{spec_markdown}
</specification>

# Goal
Produce newline-delimited JSON (NDJSON), one object per classified data type with keys:
- data_type (string — e.g., PII, PHI, PCI, credentials, secrets, telemetry)
- sensitivity (exactly one of: high, medium, low)
- storage_location (string)
- retention (short policy or duration)
- encryption_at_rest (string; use "unknown" if not stated)
- in_transit (string; use "unknown" if not stated)
- accessed_by (string describing services/roles/users)

# Guidance
- Prefer the specification's Data Classification section; infer from context when necessary.
- Merge duplicate data types, choosing the strictest sensitivity.
- Keep values concise and human-readable.

# Output
Emit only NDJSON lines. Each JSON object must contain exactly the keys listed above (no arrays, extra keys, or prose).
"#;
pub(crate) const MARKDOWN_OUTPUT_GUARD: &str = "\n# Output Guard (strict)\n    - Output only the final markdown content requested.\n    - Do not include goal, analysis, planning, chain-of-thought, or step lists.\n    - Do not echo prompt sections like \"Task\", \"Steps\", \"Output\", or \"Important\".\n    - Do not include any XML/angle-bracket blocks (e.g., <...> inputs) in the output.\n    - Do not wrap the entire response in code fences; use code fences only for code snippets.\n    - Do not include apologies, disclaimers, or references to being an AI model.\n";
pub(crate) const MARKDOWN_FIX_SYSTEM_PROMPT: &str = "You are a meticulous technical editor. Polish markdown formatting while preserving the original security analysis content. Focus on fixing numbering, bullet spacing, code fences, and diagram syntax without adding or removing information.";
pub(crate) const SPEC_COMBINE_PROMPT_TEMPLATE: &str = "You previously generated specification drafts for the following code locations:\n{project_locations}\n\nDraft content (each draft may include an \"API Entry Points\" section summarizing externally exposed interfaces):\n{spec_drafts}\n\nTask: merge these drafts into one comprehensive specification that describes the entire project. Remove duplication, keep terminology consistent, and ensure the final document reads as a single report that preserves API coverage. Follow the template exactly and return only markdown.\n\nNon-negotiable requirements:\n- Carry forward every concrete security-relevant fact, list, table, code block, and data classification entry from the drafts unless it is an exact duplicate.\n- When multiple drafts contribute to the same template section, include the union of their paragraphs and bullet points. If details differ, keep both and attribute them with inline labels such as `(from {location_label})` rather than dropping information.\n- Preserve API entry points verbatim (including tables) and incorporate them into the appropriate section without shortening columns.\n- Keep all identifiers (component names, queue names, environment variables, secrets, external services, metric names) exactly as written; do not rename or generalize.\n- Follow the template's structure exactly: populate every section, create the requested subsections, and include the explicit `Sources:` lines and bullet styles. Do not leave the instructional text in place or drop mandatory sections.\n- Populate the \"Relevant Source Files\" section with 6–12 bullet points that reference each draft's location label and the highest-signal file paths mentioned in the drafts. Prefer directories over long lists of individual files.\n- Ensure the \"Data Classification\" section exists even when the drafts were sparse; aggregate and preserve every classification detail there.\n- If multiple drafts contain tabular data (APIs, components, data classification), merge rows from all drafts and maintain duplicates when the sources disagree so the consumer can reconcile manually.\n- Do not introduce new speculation or remove nuance from mitigations, caveats, or risk descriptions provided in the drafts. Err on the side of length; the final document should be at least as detailed as the most verbose draft.\n\n# Available tools\n- READ: respond with `READ: <relative path>#Lstart-Lend` (range optional) to open code or draft files. Use paths relative to the repository root.\n- GREP_FILES: respond with `GREP_FILES: {\"pattern\": \"...\", \"include\": \"*.rs\", \"path\": \"subdir\", \"limit\": 200}` to list files whose contents match.\nEmit at most one tool command in a single message and wait for the tool output before continuing. Prefer READ for prose context; SEARCH is not available during this step.\n\nTemplate:\n{combined_template}\n";
pub(crate) const SPEC_DIR_FILTER_SYSTEM_PROMPT: &str = r#"
You triage directories for a security review specification. Only choose directories that hold core product or security-relevant code.
- Prefer application source directories (services, packages, libs) and entry points that process real traffic or data.
- Exclude tests, fixtures, scripts/tooling, examples, database migrations or seeding folders, build artifacts, vendored dependencies, generated code, or documentation-only folders. Do not select paths containing "migration", "migrations", "seed", or "seeder" unless no other application code exists.
- If a directory looks like helper utils (path util, user util, lfs util) or only contains migrations/seeding, skip it unless it is the only place core logic lives.
Respond with a newline-separated list containing only the directory paths chosen from the provided list. Respond with `ALL` if every directory should be included. Do not add quotes or extra commentary.
"#;
pub(crate) const SPEC_MARKDOWN_TEMPLATE: &str = "# Project Specification\n- Location: {target_label}\n- Prepared by: {model_name}\n- Date: {date}\n- In-scope paths:\n```\n{project_locations}\n```\n\n## Overview\nSummarize what the project delivers, who uses it, and why it matters. Call out the most security-relevant entry points.\n\n### Relevant Source Files\nList 6–12 bullet points total (no more than 12), each with an inline-code path plus a short note describing what it covers. Prefer directories over individual files; do not enumerate every file in the repo.\n\n## Overall Architecture\nDescribe how control and data move through the system. Tailor the narrative to the project type:\n- Services: show request routing, data stores, and external integrations.\n- SDKs/libraries: show host application calls into the library and any upstream services.\n- Clients/firmware: show local processes, platform APIs, and sync/telemetry paths.\nKeep this section prose-only (no end-to-end components diagrams). The threat model should carry the single components/trust-boundary diagram; use per-component diagrams below only when they materially clarify interactions. If you add more than one diagram anywhere in the spec, insert a `title <descriptive name>` line inside each mermaid block so rendered output shows distinct labels. Finish with `Sources:` pointing to the code that backs the description.\n\n## Core Components\nOpen with a sentence or two describing the component landscape. When it clarifies relationships, include a compact `mermaid flowchart` that shows the major components/modules and their interactions.\n\nCreate `### <Component name>` subsections for roughly 5-8 components (map to services, crates/packages, critical subsystems, or hardware modules depending on the project). Within each subsection include bullet points covering:\n- Primary responsibilities and scope (be concrete about behaviours and data handled)\n- Key dependencies, integrations, or hardware/software interfaces\n- Security-relevant behaviour or controls (validation, auth checks, rate limiting, sandboxing, etc.)\nInclude a focused `mermaid flowchart` for this component when it helps show detail that would clutter the overall architecture diagram. End every subsection with a line that starts with `Sources:` referencing the supporting directories or modules. If a component does not exist for this architecture, omit the subsection. Do not add an extra, section-level `Sources:` block after listing the components; the per-component sources are sufficient.\n\n## Usage & Execution Flows\nDocument the critical workflows. For each important flow, create a `### <Flow name>` subsection that:\n- Explains the trigger and actors\n- Lists the main steps or states (bullets)\n- Includes a `mermaid sequenceDiagram` or flowchart grounded in real functions/handlers/commands\n- Ends with `Sources:` citing the relevant code\nIf authentication or authorization occurs, dedicate subsections to those flows; otherwise, state `- Not applicable (reason)`.\n\n## Configuration & Policy Model\nSummarize how runtime behaviour is configured (files, env vars, feature flags, build-time toggles, device settings). Mention validation routines, defaults, and how secrets or credentials enter the system. Include a small diagram or table when it helps. End with `Sources:`.\n\n## Runtime & Deployment Model\nOutline how the project is packaged and delivered (e.g., binaries, firmware images, mobile bundles, library artifacts), supported deployment modes, and operational differences that affect security. A compact flowchart or table is welcome. End with `Sources:`.\n\n## Security Controls\n### Authentication\nDetail identity providers, credential flows, session handling, and token management (or state `- Not applicable (reason)`). Include libraries or helpers used and finish with `Sources:`.\n\n### Authorization\nExplain enforcement points, policy evaluation, privilege separation, and escalation safeguards (or mark as not applicable). Include `Sources:`.\n\n### Auditing & Observability\nCover logging, metrics, traces, and alerting hooks used to monitor security-sensitive behaviour. Call out log redaction or PII handling. Include `Sources:`.\n\n## API & Interfaces\nDescribe externally reachable or embeddable surfaces.\n\n### Server APIs\nProvide a markdown table with the exact columns:\n- endpoint path\n- authN method\n- authZ type\n- request parameters\n- example request (params, body, or method)\n- code location\n- parsing/validation logic (include auth/rate limiting/abuse controls if present)\nIf the project exposes no server APIs, write `- Not applicable (library/client-only)` (or similar) instead of a table.\n\n### Client/SDK APIs\nWhen the project ships a library, client SDK, CLI, mobile surface, or firmware commands, provide a table with columns:\n- api name (module.func, CLI command, or message)\n- module/package (or binary/component)\n- summary\n- parameters (omit if noisy)\n- returns / side effects (omit if noisy)\n- stability (public/official/internal/experimental)\n- code location\nIf there is no callable client surface, state `- Not applicable (reason)`.\n\n### Other Interfaces\nCapture message queues, hardware interfaces, scheduled jobs, or integrations that do not fit the tables above. Use bullets, note security expectations, and include `Sources:` when added.\n\n## Data Classification\nIdentify sensitive data types handled by the project and where they are stored or transmitted. Prefer markdown tables that consolidate the details (data type, sensitivity, storage location, retention, transport protections). End with `Sources:`.\n\n## Secrets, Error Handling, and Logging\nEnumerate required secrets (API keys, certificates, hardware tokens), how absence or invalid values fail, and any logging or error paths that could leak input or credentials. Mention rotation, storage, and masking practices. Include `Sources:`.\n";
pub(crate) const SPEC_COMBINED_MARKDOWN_TEMPLATE: &str = r#"# Project Specification
Provide a 2–3 sentence executive overview summarizing the system's purpose, primary users, and the highest-value assets or flows that matter for security.

## Relevant Source Files
List 6–12 bullet points for the key files and directories covered by the drafts (no more than 12). Use inline code formatting for paths (for example, `src/service.rs`) and briefly note what each covers. Ensure every draft's location label appears at least once; prefer directories over long lists of individual files.

## Overall Architecture
Provide a concise overview of how control and data move through the system, adapted to the project type (services, SDKs/libraries, clients/firmware). Keep this section prose-only (no end-to-end components diagrams); the threat model should carry the single components/trust-boundary diagram. If the combined document includes diagrams elsewhere, add a `title <descriptive label>` line inside each mermaid block so rendered output shows distinct titles. End with a `Sources:` line enumerating the supporting modules.

## Core Components
Create `### <Component name>` subsections for the union of the 4–8 major components across drafts (services, packages, subsystems, or hardware modules as appropriate). Within each subsection, merge bullets covering:
- Primary responsibilities and scope (be concrete about behaviours and data handled)
- Key dependencies, integrations, or interfaces
- Security-relevant behaviour or controls
Include a compact `mermaid flowchart` when it clarifies interactions, and use it to show detail that would clutter the overall architecture diagram. End every subsection with a `Sources:` line referencing the supporting directories (prefer directories over individual file paths unless only files were cited).

## Usage & Execution Flows
Merge the critical workflows from the drafts. Provide at least `### Authentication Flow` and `### Authorization Flow` when applicable; add other flow subsections as needed. For each flow, combine the steps, keep or merge mermaid diagrams (preserve multiple when they differ, adding descriptive titles), and finish with `Sources:` that cite every contributing draft.

## Configuration & Policy Model
Combine descriptions of configuration surfaces, policy definitions, validation, and dynamic behaviours. Merge diagrams or tables and end with `Sources:` listing every referenced module.

## Runtime & Deployment Model
Aggregate deployment or distribution details (binaries, libraries, mobile bundles, firmware images, service topologies). Note mode differences and security implications. Include diagrams or tables when present. Conclude with `Sources:`.

## Security Controls
### Authentication
Merge authentication-related details (identity providers, credential flows, session handling). Cite all sources.

### Authorization
Combine policy evaluation, enforcement points, and privilege separation details. Cite all sources.

### Auditing & Observability
Aggregate logging, metrics, tracing, and alerting content. Cite all sources.

## API & Interfaces
Union all externally facing surfaces. Preserve and merge tables for server APIs, client/SDK APIs, and other interfaces exactly (include duplicate rows when the drafts disagree). Cite all sources.

## Data Classification
Aggregate the data classification entries from the drafts into a single table or list. Keep duplicates when values differ so the consumer can reconcile them. End with `Sources:`.

## Secrets, Error Handling, and Logging
Combine guidance on secrets management, error handling, logging, and potential leakage paths. Include every relevant source citation.

"#;
