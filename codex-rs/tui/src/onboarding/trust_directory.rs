use std::path::PathBuf;

use codex_core::config::set_project_trusted;
use codex_core::git_info::resolve_root_git_project_for_trust;
use codex_core::util::is_inside_git_repo;
use crossterm::event::KeyCode;
use crossterm::event::KeyEvent;
use ratatui::buffer::Buffer;
use ratatui::layout::Rect;
use ratatui::prelude::Widget;
use ratatui::style::Color;
use ratatui::style::Modifier;
use ratatui::style::Style;
use ratatui::style::Stylize;
use ratatui::text::Line;
use ratatui::text::Span;
use ratatui::widgets::Paragraph;
use ratatui::widgets::WidgetRef;
use ratatui::widgets::Wrap;

use crate::onboarding::onboarding_screen::KeyboardHandler;
use crate::onboarding::onboarding_screen::StepStateProvider;

use super::onboarding_screen::StepState;

pub(crate) struct TrustDirectoryWidget {
    pub codex_home: PathBuf,
    pub cwd: PathBuf,
    pub is_repo: bool,
    pub selection: Option<TrustDirectorySelection>,
    pub highlighted: TrustDirectorySelection,
    pub error: Option<String>,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TrustDirectorySelection {
    Trust,
    DontTrust,
}

impl WidgetRef for &TrustDirectoryWidget {
    fn render_ref(&self, area: Rect, buf: &mut Buffer) {
        let mut lines: Vec<Line> = vec![
            Line::from(vec![
                Span::raw("> "),
                Span::styled(
                    "You are running Codex in ",
                    Style::default().add_modifier(Modifier::BOLD),
                ),
                Span::raw(self.cwd.to_string_lossy().to_string()),
            ]),
            Line::from(""),
        ];

        if self.is_repo {
            lines.push(Line::from(
                "  Since this folder is version controlled, you may wish to allow Codex",
            ));
            lines.push(Line::from(
                "  to work in this folder without asking for approval.",
            ));
        } else {
            lines.push(Line::from(
                "  Since this folder is not version controlled, we recommend requiring",
            ));
            lines.push(Line::from("  approval of all edits and commands."));
        }
        lines.push(Line::from(""));

        let create_option =
            |idx: usize, option: TrustDirectorySelection, text: &str| -> Line<'static> {
                let is_selected = self.highlighted == option;
                if is_selected {
                    Line::from(format!("> {}. {text}", idx + 1)).cyan()
                } else {
                    Line::from(format!("  {}. {}", idx + 1, text))
                }
            };

        if self.is_repo {
            lines.push(create_option(
                0,
                TrustDirectorySelection::Trust,
                "Yes, allow Codex to work in this folder without asking for approval",
            ));
            lines.push(create_option(
                1,
                TrustDirectorySelection::DontTrust,
                "No, ask me to approve edits and commands",
            ));
        } else {
            lines.push(create_option(
                0,
                TrustDirectorySelection::Trust,
                "Allow Codex to work in this folder without asking for approval",
            ));
            lines.push(create_option(
                1,
                TrustDirectorySelection::DontTrust,
                "Require approval of edits and commands",
            ));
        }
        lines.push(Line::from(""));
        if let Some(error) = &self.error {
            lines.push(Line::from(format!("  {error}")).fg(Color::Red));
            lines.push(Line::from(""));
        }
        // AE: Following styles.md, this should probably be Cyan because it's a user input tip.
        //     But leaving this for a future cleanup.
        lines.push(Line::from("  Press Enter to continue").add_modifier(Modifier::DIM));

        Paragraph::new(lines)
            .wrap(Wrap { trim: false })
            .render(area, buf);
    }
}

impl KeyboardHandler for TrustDirectoryWidget {
    fn handle_key_event(&mut self, key_event: KeyEvent) {
        match key_event.code {
            KeyCode::Up | KeyCode::Char('k') => {
                self.highlighted = TrustDirectorySelection::Trust;
            }
            KeyCode::Down | KeyCode::Char('j') => {
                self.highlighted = TrustDirectorySelection::DontTrust;
            }
            KeyCode::Char('1') => self.handle_trust(),
            KeyCode::Char('2') => self.handle_dont_trust(),
            KeyCode::Enter => match self.highlighted {
                TrustDirectorySelection::Trust => self.handle_trust(),
                TrustDirectorySelection::DontTrust => self.handle_dont_trust(),
            },
            _ => {}
        }
    }
}

impl StepStateProvider for TrustDirectoryWidget {
    fn get_step_state(&self) -> StepState {
        match self.selection {
            Some(_) => StepState::Complete,
            None => StepState::InProgress,
        }
    }
}

impl TrustDirectoryWidget {
    fn handle_trust(&mut self) {
        // Only try to resolve the Git project root when `cwd` is inside a Git repo.
        let target = if is_inside_git_repo(&self.cwd) {
            resolve_root_git_project_for_trust(&self.cwd).unwrap_or_else(|| self.cwd.clone())
        } else {
            self.cwd.clone()
        };

        if let Err(e) = set_project_trusted(&self.codex_home, &target) {
            tracing::error!("Failed to set project trusted: {e:?}");
            self.error = Some(format!("Failed to set trust for {}: {e}", target.display()));
        }

        self.selection = Some(TrustDirectorySelection::Trust);
    }

    fn handle_dont_trust(&mut self) {
        self.highlighted = TrustDirectorySelection::DontTrust;
        self.selection = Some(TrustDirectorySelection::DontTrust);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    fn create_test_widget(cwd: PathBuf, is_repo: bool) -> TrustDirectoryWidget {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        TrustDirectoryWidget {
            codex_home: temp_dir.path().to_path_buf(),
            cwd,
            is_repo,
            selection: None,
            highlighted: TrustDirectorySelection::Trust,
            error: None,
        }
    }

    async fn create_test_git_repo(temp_dir: &TempDir) -> PathBuf {
        let repo_path = temp_dir.path().join("repo");
        fs::create_dir(&repo_path).expect("Failed to create repo dir");

        let envs = vec![
            ("GIT_CONFIG_GLOBAL", "/dev/null"),
            ("GIT_CONFIG_NOSYSTEM", "1"),
        ];

        // Initialize git repo
        tokio::process::Command::new("git")
            .envs(envs.clone())
            .args(["init"])
            .current_dir(&repo_path)
            .output()
            .await
            .expect("Failed to init git repo");

        // Configure git user (required for commits)
        tokio::process::Command::new("git")
            .envs(envs.clone())
            .args(["config", "user.name", "Test User"])
            .current_dir(&repo_path)
            .output()
            .await
            .expect("Failed to set git user name");

        tokio::process::Command::new("git")
            .envs(envs.clone())
            .args(["config", "user.email", "test@example.com"])
            .current_dir(&repo_path)
            .output()
            .await
            .expect("Failed to set git user email");

        // Create a test file and commit it
        let test_file = repo_path.join("test.txt");
        fs::write(&test_file, "test content").expect("Failed to write test file");

        tokio::process::Command::new("git")
            .envs(envs.clone())
            .args(["add", "."])
            .current_dir(&repo_path)
            .output()
            .await
            .expect("Failed to add files");

        tokio::process::Command::new("git")
            .envs(envs.clone())
            .args(["commit", "-m", "Initial commit"])
            .current_dir(&repo_path)
            .output()
            .await
            .expect("Failed to commit");

        repo_path
    }

    #[test]
    fn test_handle_trust_non_git_directory() {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let non_git_path = temp_dir.path().join("not_git");
        fs::create_dir(&non_git_path).expect("Failed to create non-git dir");

        let mut widget = create_test_widget(non_git_path.clone(), false);

        widget.handle_trust();

        // Should complete without error and set selection to Trust
        assert_eq!(widget.selection, Some(TrustDirectorySelection::Trust));
        assert!(widget.error.is_none());
    }

    #[test]
    fn test_handle_trust_non_git_repo() {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let non_git_path = temp_dir.path().join("not_git");
        fs::create_dir(&non_git_path).expect("Failed to create non-git dir");
        let sapling_dir = non_git_path.join(".sl");
        fs::create_dir(&sapling_dir).expect("Failed to create test cwd");

        let mut widget = create_test_widget(non_git_path.clone(), false);

        widget.handle_trust();

        // Should complete without error and set selection to Trust
        assert_eq!(widget.selection, Some(TrustDirectorySelection::Trust));
        assert!(widget.error.is_none());
    }

    #[tokio::test]
    async fn test_handle_trust_git_directory() {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let git_repo_path = create_test_git_repo(&temp_dir).await;

        let mut widget = create_test_widget(git_repo_path.clone(), true);

        widget.handle_trust();

        // Should complete without error and set selection to Trust
        assert_eq!(widget.selection, Some(TrustDirectorySelection::Trust));
        assert!(widget.error.is_none());
    }

    #[tokio::test]
    async fn test_handle_trust_git_subdirectory() {
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let git_repo_path = create_test_git_repo(&temp_dir).await;
        let subdir = git_repo_path.join("subdir");
        fs::create_dir(&subdir).expect("Failed to create subdir");

        let mut widget = create_test_widget(subdir.clone(), true);

        widget.handle_trust();

        // Should complete without error and set selection to Trust
        assert_eq!(widget.selection, Some(TrustDirectorySelection::Trust));
        assert!(widget.error.is_none());
    }
}
