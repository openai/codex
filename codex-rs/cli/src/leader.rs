use std::path::PathBuf;
use std::process::Stdio;

use anyhow::Context;
use anyhow::Result;
use anyhow::anyhow;
use anyhow::ensure;
use clap::ArgAction;
use clap::Parser;
use codex_common::CliConfigOverrides;
use codex_core::config::Config;
use codex_core::config::ConfigOverrides;
use tokio::process::Child;
use tokio::process::Command;
use uuid::Uuid;

const MAX_WORKERS_PER_LEADER: u8 = 10;

#[derive(Clone, Debug, Default)]
struct TaskEnvelope {
    prompt: Option<String>,
    run_shell: Option<String>,
    files: Vec<String>,
}

impl TaskEnvelope {
    fn from_leader(cmd: &LeaderCommand) -> Option<Self> {
        if cmd.prompt.is_none() && cmd.run_shell.is_none() && cmd.files.is_empty() {
            return None;
        }
        Some(Self {
            prompt: cmd.prompt.clone(),
            run_shell: cmd.run_shell.clone(),
            files: cmd.files.clone(),
        })
    }

    fn from_worker(cmd: &WorkerCommand) -> Option<Self> {
        if cmd.prompt.is_none() && cmd.run_shell.is_none() && cmd.files.is_empty() {
            return None;
        }
        Some(Self {
            prompt: cmd.prompt.clone(),
            run_shell: cmd.run_shell.clone(),
            files: cmd.files.clone(),
        })
    }

    fn exec_args(&self) -> Result<Vec<String>> {
        let mut args = Vec::new();
        if let Some(prompt) = &self.prompt {
            args.push("--prompt".to_string());
            args.push(prompt.clone());
        }
        if let Some(run_shell) = &self.run_shell {
            args.push("--run-shell".to_string());
            args.push(run_shell.clone());
        }
        for file in &self.files {
            args.push("--file".to_string());
            args.push(file.clone());
        }
        ensure!(!args.is_empty(), "no prompt/run-shell/file hints provided");
        Ok(args)
    }
}

#[derive(Debug, Parser)]
pub struct LeaderCommand {
    #[clap(flatten)]
    pub config_overrides: CliConfigOverrides,

    /// Number of worker processes to spawn. Defaults to `[leader_worker].default_worker_count`.
    #[arg(long = "workers")]
    pub workers: Option<u8>,

    /// Working directory to use for each worker.
    #[arg(long)]
    pub cwd: Option<PathBuf>,

    /// Prompt forwarded to each worker via `codex exec --prompt` when no `--` payload is provided.
    #[arg(long)]
    pub prompt: Option<String>,

    /// Shell command forwarded via `codex exec --run-shell` when no `--` payload is provided.
    #[arg(long = "run-shell")]
    pub run_shell: Option<String>,

    /// Restrict worker context to specific files (`codex exec --file`).
    #[arg(long = "file", value_name = "PATH", action = ArgAction::Append)]
    pub files: Vec<String>,

    /// Suppress per-worker spawn messages.
    #[arg(long)]
    pub quiet: bool,

    /// Arguments forwarded to each worker after "--".
    #[arg(value_name = "WORKER_ARGS", last = true)]
    pub worker_args: Vec<String>,
}

#[derive(Debug, Parser)]
pub struct WorkerCommand {
    #[clap(flatten)]
    pub config_overrides: CliConfigOverrides,

    /// ID of the leader process this worker is attached to.
    #[arg(long = "leader-id")]
    pub leader_id: String,

    /// Worker identifier (auto-generated by the leader when omitted).
    #[arg(long = "worker-id")]
    pub worker_id: String,

    /// Optional working directory override for this worker.
    #[arg(long)]
    pub cwd: Option<PathBuf>,

    /// Prompt forwarded to `codex exec --prompt`.
    #[arg(long)]
    pub prompt: Option<String>,

    /// Shell command forwarded via `codex exec --run-shell`.
    #[arg(long = "run-shell")]
    pub run_shell: Option<String>,

    /// Restrict worker context to specific files (`codex exec --file`).
    #[arg(long = "file", value_name = "PATH", action = ArgAction::Append)]
    pub files: Vec<String>,

    /// Arguments forwarded to `codex exec` after "--".
    #[arg(value_name = "EXEC_ARGS", last = true)]
    pub exec_args: Vec<String>,
}

pub async fn run_leader_command(mut cmd: LeaderCommand) -> Result<()> {
    let exe = std::env::current_exe().context("failed to resolve current executable")?;
    let override_flags = config_override_flags(&cmd.config_overrides);
    let cli_overrides = cmd
        .config_overrides
        .parse_overrides()
        .map_err(|err| anyhow!(err))?;
    let config = Config::load_with_cli_overrides(cli_overrides, ConfigOverrides::default()).await?;
    ensure!(
        config.leader_worker.enabled,
        "Leaderâ€“worker workflow is disabled. Set `[leader_worker].enabled = true` in your Codex config to use `codex leader`."
    );

    let max_allowed = config.leader_worker.max_workers.min(MAX_WORKERS_PER_LEADER);
    ensure!(
        max_allowed > 0,
        "leader_worker.max_workers must be at least 1"
    );

    let worker_count = cmd
        .workers
        .unwrap_or(config.leader_worker.default_worker_count)
        .max(1);
    ensure!(
        worker_count <= max_allowed,
        "requested {worker_count} workers but leader_worker.max_workers is set to {max_allowed}. Update your config or use a lower --workers value."
    );

    let leader_id = Uuid::new_v4();
    let mut children: Vec<(String, Child)> = Vec::new();

    let envelope = TaskEnvelope::from_leader(&cmd);

    for index in 0..worker_count {
        let worker_id = format!("worker-{}", index + 1);
        let mut command = Command::new(&exe);
        // Propagate config overrides so each worker inherits leader-level flags.
        for flag in &override_flags {
            command.arg(flag);
        }
        command.arg("worker");
        command.arg("--leader-id").arg(leader_id.to_string());
        command.arg("--worker-id").arg(&worker_id);
        if let Some(cwd) = &cmd.cwd {
            command.arg("--cwd").arg(cwd);
        }
        if let Some(env) = &envelope {
            if let Some(prompt) = &env.prompt {
                command.arg("--prompt").arg(prompt);
            }
            if let Some(run_shell) = &env.run_shell {
                command.arg("--run-shell").arg(run_shell);
            }
            for file in &env.files {
                command.arg("--file").arg(file);
            }
        }
        if !cmd.worker_args.is_empty() {
            command.arg("--");
            command.args(&cmd.worker_args);
        }
        command.stdin(Stdio::null());
        if cmd.quiet {
            command.stdout(Stdio::null());
        } else {
            command.stdout(Stdio::inherit());
        }
        command.stderr(Stdio::inherit());

        let child = command
            .spawn()
            .with_context(|| format!("failed to spawn worker {worker_id}"))?;
        if !cmd.quiet {
            if let Some(pid) = child.id() {
                eprintln!("spawned {worker_id} (pid {pid})");
            } else {
                eprintln!("spawned {worker_id}");
            }
        }
        children.push((worker_id, child));
    }

    for (worker_id, mut child) in children {
        let status = child
            .wait()
            .await
            .with_context(|| format!("failed to wait for {worker_id}"))?;
        if !status.success() {
            return Err(anyhow!("{worker_id} exited with status {status}"));
        }
    }

    Ok(())
}

pub async fn run_worker_command(cmd: WorkerCommand) -> Result<()> {
    if let Some(cwd) = &cmd.cwd {
        std::env::set_current_dir(cwd)
            .with_context(|| format!("failed to switch worker cwd to {}", cwd.display()))?;
    }

    let exe = std::env::current_exe().context("failed to resolve current executable")?;
    let override_flags = config_override_flags(&cmd.config_overrides);
    let exec_args = if !cmd.exec_args.is_empty() {
        cmd.exec_args.clone()
    } else if let Some(envelope) = TaskEnvelope::from_worker(&cmd) {
        envelope.exec_args()?
    } else {
        Vec::new()
    };

    if exec_args.is_empty() {
        eprintln!(
            "Worker {} connected to leader {} (idle; no work provided)",
            cmd.worker_id, cmd.leader_id
        );
        return Ok(());
    }

    let mut command = Command::new(exe);
    for flag in &override_flags {
        command.arg(flag);
    }
    command.arg("exec");
    command.args(&exec_args);
    command.stdin(Stdio::null());
    command.stdout(Stdio::inherit());
    command.stderr(Stdio::inherit());

    let status = command.status().await.context("worker task failed")?;
    if !status.success() {
        return Err(anyhow!(
            "worker {} task exited with status {}",
            cmd.worker_id,
            status
        ));
    }

    Ok(())
}

fn config_override_flags(overrides: &CliConfigOverrides) -> Vec<String> {
    let mut flags = Vec::with_capacity(overrides.raw_overrides.len() * 2);
    for raw in &overrides.raw_overrides {
        flags.push("-c".to_string());
        flags.push(raw.clone());
    }
    flags
}
