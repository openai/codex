#!/usr/bin/env python3

import argparse
import re
import sys
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path

"""
Generates docs/codex_cli_docs_map.md for Codex CLI.

h/t Simon Willison for the "docs map" pattern:
https://simonwillison.net/2025/Oct/24/claude-code-docs-map/
"""


HEADING_RE = re.compile(r"^(#{1,6})\s+(.+?)\s*$")
FENCE_RE = re.compile(r"^(```+|~~~+)")  # ```lang or ~~~lang
CREDIT_URL = "https://simonwillison.net/2025/Oct/24/claude-code-docs-map/"


@dataclass(frozen=True)
class Heading:
    level: int
    text: str


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate a docs map and embedded system-skill bundle for Codex CLI docs."
    )
    parser.add_argument(
        "--docs-dir",
        type=Path,
        default=None,
        help="Docs directory to scan (defaults to <repo>/docs).",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Output file path (defaults to <docs-dir>/codex_cli_docs_map.md).",
    )
    parser.add_argument(
        "--skill-output",
        type=Path,
        default=None,
        help="System skill SKILL.md output path (defaults to codex-rs/core/src/skills/assets/samples/codex-cli-docs/SKILL.md).",
    )
    args = parser.parse_args()

    repo_root = Path(__file__).resolve().parents[1]
    docs_dir = args.docs_dir or (repo_root / "docs")
    output_path = args.output or (docs_dir / "codex_cli_docs_map.md")
    skill_output_path = args.skill_output or (
        repo_root
        / "codex-rs/core/src/skills/assets/samples/codex-cli-docs/SKILL.md"
    )

    docs = find_docs(docs_dir, output_path)
    groups = group_docs(docs_dir, docs)
    output = render_map(docs_dir, groups)

    output_path.write_text(output, encoding="utf-8")
    write_skill_bundle(docs_dir, docs, groups, skill_output_path)
    return 0


def find_docs(docs_dir: Path, output_path: Path) -> list[Path]:
    docs_dir = docs_dir.resolve()
    if not docs_dir.is_dir():
        raise SystemExit(f"docs dir does not exist: {docs_dir}")

    output_path = output_path.resolve()
    docs: list[Path] = []
    for path in sorted(docs_dir.rglob("*.md")):
        if path.resolve() == output_path:
            continue
        if path.name.startswith("."):
            continue
        docs.append(path)
    return docs


def group_docs(docs_dir: Path, docs: list[Path]) -> dict[str, list[Path]]:
    groups: dict[str, list[Path]] = defaultdict(list)
    for doc in docs:
        rel = doc.relative_to(docs_dir)
        # group = top-level directory under docs/, or "Docs" for root files
        group = "Docs"
        if len(rel.parts) > 1:
            group = rel.parts[0].upper()
        groups[group].append(doc)
    # Ensure stable ordering
    return {k: sorted(v) for k, v in sorted(groups.items(), key=lambda kv: kv[0])}


def write_skill_bundle(
    docs_dir: Path, docs: list[Path], groups: dict[str, list[Path]], output_path: Path
) -> None:
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(render_skill(docs_dir, docs, groups), encoding="utf-8")


def render_map(docs_dir: Path, groups: dict[str, list[Path]]) -> str:
    lines: list[str] = []
    lines.append("# Codex CLI Documentation Map")
    lines.append("")
    lines.append(
        "This is a comprehensive map of Codex CLI documentation pages with their headings, designed for easy navigation by LLMs."
    )
    lines.append("")
    lines.append(
        "> **Note:** This file is auto-generated by `scripts/generate_codex_cli_docs_map.py`. Do not edit manually."
    )
    lines.append("")
    lines.append("## Document Structure")
    lines.append("")
    lines.append("This map uses a hierarchical structure:")
    lines.append("")
    lines.append("* **##** marks documentation groups")
    lines.append("* **###** marks individual documentation pages")
    lines.append("* Nested bullets show the heading structure within each page")
    lines.append("* Each page title links to the full documentation")
    lines.append("")

    for group, docs in groups.items():
        lines.append(f"## {group}")
        lines.append("")
        for doc in docs:
            rel = doc.relative_to(docs_dir)  # path under docs/
            doc_id = rel.as_posix().removesuffix(".md")
            link = f"./{rel.as_posix()}"

            lines.append(f"### [{doc_id}]({link})")
            lines.append("")

            headings = parse_headings(doc)
            bullet_lines = headings_to_bullets(headings)
            lines.extend(bullet_lines or ["* (no headings)"])
            lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def render_skill(docs_dir: Path, docs: list[Path], groups: dict[str, list[Path]]) -> str:
    lines: list[str] = []
    lines.append("---")
    lines.append("name: codex-cli-docs")
    lines.append(
        "description: Codex CLI documentation bundle (docs map + repo docs)."
    )
    lines.append("metadata:")
    lines.append("  short-description: Codex CLI docs bundle")
    lines.append("---")
    lines.append("")
    lines.append("# Codex CLI docs bundle (embedded)")
    lines.append("")
    lines.append(
        "This file is auto-generated by `scripts/generate_codex_cli_docs_map.py` and is installed as a system skill by default."
    )
    lines.append("")
    lines.append(f"h/t Simon Willison for the docs map pattern: {CREDIT_URL}")
    lines.append("")
    lines.append("## Docs map")
    lines.append("")
    lines.extend(render_map(docs_dir, groups).rstrip().splitlines())
    lines.append("")
    lines.append("## Repo docs")
    lines.append("")

    for doc in docs:
        rel = doc.relative_to(docs_dir).as_posix()
        lines.append(f"### docs/{rel}")
        lines.append("")
        content = doc.read_text(encoding="utf-8").rstrip()
        if content:
            lines.extend(content.splitlines())
        else:
            lines.append("(empty)")
        lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def parse_headings(path: Path) -> list[Heading]:
    text = path.read_text(encoding="utf-8")
    in_fence = False
    headings: list[Heading] = []

    for line in text.splitlines():
        if FENCE_RE.match(line.strip()):
            in_fence = not in_fence
            continue
        if in_fence:
            continue

        m = HEADING_RE.match(line)
        if not m:
            continue

        level = len(m.group(1))
        heading_text = clean_heading_text(m.group(2))
        if not heading_text:
            continue
        headings.append(Heading(level=level, text=heading_text))

    return headings


def clean_heading_text(text: str) -> str:
    # Strip closing hashes (e.g. "Title ##") and surrounding whitespace
    cleaned = text.strip()
    cleaned = re.sub(r"\s#+\s*$", "", cleaned).strip()
    return cleaned


def headings_to_bullets(headings: list[Heading]) -> list[str]:
    # Drop the top-level page title if present (usually a single # heading).
    filtered = [h for h in headings if h.level != 1]
    if not filtered:
        return []

    base_level = min(h.level for h in filtered)
    lines: list[str] = []
    for h in filtered:
        indent = "  " * max(0, h.level - base_level)
        lines.append(f"{indent}* {h.text}")
    return lines


if __name__ == "__main__":
    sys.exit(main())
